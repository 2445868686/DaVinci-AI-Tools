
local SCRIPT_NAME = "DaVinci Sub Tool"
local SCRIPT_VERSION = "1.1.5"
local SCRIPT_AUTHOR = "HEIBA"
print(string.format("%s | %s | %s", SCRIPT_NAME, SCRIPT_VERSION, SCRIPT_AUTHOR))
local SCRIPT_KOFI_URL = "https://ko-fi.com/heiba"
local SCRIPT_TAOBAO_URL = "https://shop120058726.taobao.com/"
local SCRIPT_BILIBILI_URL = "https://space.bilibili.com/385619394"

local App = {
    Utils = {},
    Storage = {},
    Services = {
        HttpClient = {},
        Azure = {},
        DeepL = {},
        OpenAIFormat = {},
        GLM = {},
        Parallel = {},
        ChatProviders = {},
    },
    Subtitle = {},
    Translate = {},
    UI = {
        Events = {},
        Windows = {},
    },
    Cache = {},
}

local Utils = App.Utils
local Storage = App.Storage
local Services = App.Services
local Subtitle = App.Subtitle
local Translate = App.Translate
local UI = App.UI
local Azure = Services.Azure
local DeepL = Services.DeepL
local OpenAIService = Services.OpenAIFormat
local GLMService = Services.GLM
local ParallelServices = Services.Parallel
local ChatProviders = Services.ChatProviders
local httpClient = Services.HttpClient
local SCREEN_WIDTH, SCREEN_HEIGHT = 1920, 1080
local WINDOW_WIDTH, WINDOW_HEIGHT = 625, 600
local X_CENTER = math.floor((SCREEN_WIDTH - WINDOW_WIDTH ) / 2)
local Y_CENTER = math.floor((SCREEN_HEIGHT - WINDOW_HEIGHT) / 2)
local LOADING_WINDOW_WIDTH, LOADING_WINDOW_HEIGHT = 220, 120
local LOADING_X = math.floor((SCREEN_WIDTH - LOADING_WINDOW_WIDTH) / 2)
local LOADING_Y = math.floor((SCREEN_HEIGHT - LOADING_WINDOW_HEIGHT) / 2)
local QR_PAYPAL_BASE64 = [[
/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABkAAD/4QMxaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA5LjEtYzAwMyA3OS45NjkwYTg3ZmMsIDIwMjUvMDMvMDYtMjA6NTA6MTYgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCAyNy4xIChNYWNpbnRvc2gpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjBGNDZCRjQwQ0ZFMzExRjA5M0U2QUVBMDE0OTI2RURFIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjBGNDZCRjQxQ0ZFMzExRjA5M0U2QUVBMDE0OTI2RURFIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6RjAwMkVDN0ZDRjQyMTFGMDkzRTZBRUEwMTQ5MjZFREUiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6RjAwMkVDODBDRjQyMTFGMDkzRTZBRUEwMTQ5MjZFREUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7/7gAmQWRvYmUAZMAAAAABAwAVBAMGCg0AAB0fAABmOAAA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
]]
local QR_WECHAT_BASE64 = [[
/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABkAAD/4QMxaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA5LjEtYzAwMyA3OS45NjkwYTg3ZmMsIDIwMjUvMDMvMDYtMjA6NTA6MTYgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCAyNy4xIChNYWNpbnRvc2gpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkYwMDJFQzdEQ0Y0MjExRjA5M0U2QUVBMDE0OTI2RURFIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkYwMDJFQzdFQ0Y0MjExRjA5M0U2QUVBMDE0OTI2RURFIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6RjAwMkVDN0JDRjQyMTFGMDkzRTZBRUEwMTQ5MjZFREUiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6RjAwMkVDN0NDRjQyMTFGMDkzRTZBRUEwMTQ5MjZFREUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7/7gAmQWRvYmUAZMAAAAABAwAVBAMGCg0AAB54AABssQAA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
]]
local resolve = resolve or Resolve()
if not resolve then
    print("Resolve API ")
    return
end

local fusion = resolve:Fusion()
if not fusion then
    print("Fusion ")
    return
end

function Utils.deepCopy(value)
    if type(value) ~= "table" then
        return value
    end
    local copy = {}
    for k, v in pairs(value) do
        copy[k] = Utils.deepCopy(v)
    end
    return copy
end

local ui = fusion.UIManager
local disp = bmd.UIDispatcher(ui)
local json = require('dkjson')

local TRANSLATE_PROVIDER_AZURE_LABEL = "Microsoft"
local TRANSLATE_PROVIDER_DEEPL_LABEL = "DeepL                  ( API Key )"
local TRANSLATE_PROVIDER_SILICONFLOW_LABEL = "SiliconFlow         ( Free AI  )"
local TRANSLATE_PROVIDER_GL_LABEL = "GLM-4-Flash       ( Free AI  )"
local TRANSLATE_PROVIDER_OPENAI_LABEL = "OpenAI Format  ( API Key )"
local TRANSLATE_PROVIDER_LIST = {
    TRANSLATE_PROVIDER_AZURE_LABEL,
    TRANSLATE_PROVIDER_SILICONFLOW_LABEL,
    TRANSLATE_PROVIDER_GL_LABEL,
    TRANSLATE_PROVIDER_OPENAI_LABEL,
    TRANSLATE_PROVIDER_DEEPL_LABEL,
}
local PROVIDER_LANG_MAP_KEYS = {
    [TRANSLATE_PROVIDER_AZURE_LABEL] = "azure",
    [TRANSLATE_PROVIDER_DEEPL_LABEL] = "deepl",
    [TRANSLATE_PROVIDER_SILICONFLOW_LABEL] = "google",
    [TRANSLATE_PROVIDER_GL_LABEL] = "google",
    [TRANSLATE_PROVIDER_OPENAI_LABEL] = "google",
}
function Translate.isSupportedProvider(label)
    for _, value in ipairs(TRANSLATE_PROVIDER_LIST) do
        if value == label then
            return true
        end
    end
    return false
end
local DEFAULT_TRANSLATE_CONCURRENCY = 5
local TRANSLATE_CONCURRENCY_OPTIONS = {
    { labelKey = "concurrency_option_low", value = 1 },
    { labelKey = "concurrency_option_standard", value = 5 },
    { labelKey = "concurrency_option_high", value = 15 },
}
local TRANSLATE_CONTEXT_WINDOW = 1
local AZURE_DEFAULT_BASE_URL = "https://api.cognitive.microsofttranslator.com"
local AZURE_DEFAULT_REGION = ""
local AZURE_FALLBACK_REGION = "eastus"
local AZURE_TIMEOUT = 10
local AZURE_REGISTER_URL = "https://azure.microsoft.com/"
local DEEPL_FREE_API_URL = "https://api-free.deepl.com/v2/translate"
local DEEPL_PRO_API_URL = "https://api.deepl.com/v2/translate"
local DEEPL_TIMEOUT = 10
local DEEPL_REGISTER_URL = "https://www.deepl.com/pro-api"
local GLM_API_URL = "https://open.bigmodel.cn/api/paas/v4/chat/completions"
local GLM_MODEL = "GLM-4-Flash"
local GLM_MAX_RETRY = 1
local GLM_TIMEOUT = 10
local SILICONFLOUW_API_URL = "https://api.siliconflow.cn/v1/chat/completions"
local SILICONFLOUW_MODEL = "THUDM/GLM-4-9B-0414"
local SILICONFLOUW_SUPABASE_PROVIDER = "SILICONFLOUW"
local AZURE_SUPABASE_PROVIDER = "AZURE"
local GLM_SUPABASE_PROVIDER = "BIGMODEL"
local OPENAI_FORMAT_DEFAULT_BASE_URL = "https://api.openai.com"
local OPENAI_FORMAT_DEFAULT_TEMPERATURE = 0.3
local OPENAI_FORMAT_TIMEOUT = 10
local DEFAULT_OPENAI_MODELS = {}

local TRANSLATE_PREFIX_PROMPT = [[
You are a professional {target_lang} subtitle translation engine.
Task: Translate ONLY the sentence shown after the tag <<< Sentence >>> into {target_lang}.
---
]]

local TRANSLATE_SYSTEM_PROMPT = [[Strict rules you MUST follow:

1. Keep every proper noun, personal name, brand, product name, code snippet, file path, URL, and any other non-translatable element EXACTLY as it appears. Do NOT transliterate or translate these.

2. Follow subtitle style: short, concise, natural, and easy to read.

3. Output ONLY the translated sentence. No tags, no explanations, no extra spaces.
]]

local TRANSLATE_SUFFIX_PROMPT = [[
---
Note:
- The messages with role=assistant are only CONTEXT; do NOT translate them or include them in your output.
- Translate ONLY the line after <<< Sentence >>>
]]

local OPENAI_DEFAULT_SYSTEM_PROMPT = TRANSLATE_SYSTEM_PROMPT

local LANG_CODE_MAPS = {}

Translate.secretCache = {}


App.State = {
    entries = {},
    fps = 24.0,
    startFrame = 0,
    timeline = nil,
    resolve = resolve,
    selectedIndex = nil,
    activeTrackIndex = nil,
    language = "en",
    lastStatusKey = nil,
    lastStatusArgs = nil,
    findQuery = "",
    findMatches = nil,
    findIndex = nil,
    currentMatchPos = nil,
    suppressTreeSelection = false,
    currentMatchHighlight = nil,
    stickyHighlights = {},
    highlightedRows = {},
    updateInfo = nil,
    loadingLabel = nil,
    autoFollow = true,
    lastFollowIndex = nil,
    manualJumpFrame = nil,
    manualJumpAt = nil,
    translate = {
        entries = {},
        populated = false,
        busy = false,
        selectedIndex = nil,
        provider = TRANSLATE_PROVIDER_AZURE_LABEL,
        targetLabel = nil,
        targetCode = nil,
        targetCodes = {},
        concurrency = DEFAULT_TRANSLATE_CONCURRENCY,
        totalTokens = 0,
        lastStatusKey = "idle",
        lastStatusArgs = nil,
        failed = {},
    },
}

local state = App.State

state.openaiFormat = {
    baseUrl = OPENAI_FORMAT_DEFAULT_BASE_URL,
    apiKey = "",
    temperature = OPENAI_FORMAT_DEFAULT_TEMPERATURE,
    models = Utils.deepCopy(DEFAULT_OPENAI_MODELS),
    customModels = {},
    selectedIndex = 1,
    systemPrompt = OPENAI_DEFAULT_SYSTEM_PROMPT,
}
state.azure = {
    apiKey = "",
    region = AZURE_DEFAULT_REGION,
    baseUrl = AZURE_DEFAULT_BASE_URL,
}
state.deepl = {
    apiKey = "",
}
math.randomseed(os.time() + tonumber(tostring({}):sub(8), 16))
state.sessionCode = string.format("%04X", math.random(0, 0xFFFF))

local findHighlightColor = { R = 0.40, G = 0.40, B = 0.40, A = 0.60 } --  / 
local transparentColor = { R = 0.0, G = 0.0, B = 0.0, A = 0.0 } -- 
local translateFailureColor = { R = 0.90, G = 0.25, B = 0.25, A = 0.35 } -- 
local editorProgrammatic = false
local translateEditorProgrammatic = false
local languageProgrammatic = false
local unpack = table.unpack or unpack
local configDir
local settingsFile

local uiText = {
    cn = {
        find_next_button = "",
        find_previous_button = "",
        all_replace_button = "",
        single_replace_button = "",
        refresh_button = "",
        update_button = "",
        find_placeholder = "",
        replace_placeholder = "",
        editor_placeholder = "",
        tree_headers = { "#", "/", "" },
        translate_tree_headers = { "#", "/", "", "" },
        lang_cn = "",
        lang_en = "EN",
        tabs = { "", "", "" },
        donation = "  ",
        copyright = "  2025,  " .. SCRIPT_AUTHOR,
        translate_provider_label = "",
        translate_target_label = "",
        translate_provider_placeholder = "",
        translate_target_placeholder = "",
        translate_trans_button = "",
        translate_update_button = "",
        translate_selected_button = "",
        auto_follow_check = "",
        translate_retry_failed_button = "",
        translate_editor_placeholder = "",
        openai_config_label = "OpenAI Format",
        openai_config_button = "",
        azure_config_label = "Azure API",
        azure_config_button = "",
        azure_config_window_title = "Azure API",
        azure_config_header = " Azure API ",
        azure_region_label = "",
        azure_api_key_label = "",
        azure_confirm_button = "",
        azure_register_button = "",
        deepl_config_label = "DeepL API",
        deepl_config_button = "",
        deepl_config_window_title = "DeepL API",
        deepl_config_header = " DeepL API ",
        deepl_api_key_label = "",
        deepl_confirm_button = "",
        deepl_register_button = "",
        concurrency_label = "",
        concurrency_option_low = "",
        concurrency_option_standard = "",
        concurrency_option_high = "",
        openai_config_window_title = "OpenAI Format API",
        openai_config_header = " API ",
        openai_model_label = "",
        openai_model_name_label = "",
        openai_base_url_label = "* Base URL",
        openai_api_key_label = "* API Key",
        openai_temperature_label = "",
        system_prompt_label = "* ",
        openai_verify_button = "",
        openai_add_button = "",
        openai_delete_button = "",
        openai_close_button = "",
        openai_new_model_display_label = "* ",
        openai_new_model_name_label = "*  ID",
        openai_add_model_title = " OpenAI ",
        openai_status_ready = "",
        openai_delete_builtin_warning = "",
        openai_verify_success = "",
        openai_verify_failed = "%s",
        openai_add_success = "",
        openai_add_duplicate = "",
        openai_missing_fields = "",
        openai_delete_success = "",
    },
    en = {
        find_next_button = "Next",
        find_previous_button = "Previous",
        all_replace_button = "All Replace",
        single_replace_button = "Replace",
        refresh_button = "Load Timeline Subtitles",
        update_button = "Update Timeline Subtitles",
        find_placeholder = "Find text",
        replace_placeholder = "Replace with",
        editor_placeholder = "Edit selected subtitle here",
        tree_headers = { "#", "Start/End", "Subtitle" },
        translate_tree_headers = { "#", "Start/End", "Original", "Translation" },
        lang_cn = "",
        lang_en = "EN",
        tabs = { "Edit", "Translate", "Settings" },
        donation = " Explore More Features ",
        copyright = "  2025, copyright by " .. SCRIPT_AUTHOR,
        translate_provider_label = "Provider",
        translate_target_label = "To",
        translate_provider_placeholder = "Select provider",
        translate_target_placeholder = "Select target language",
        translate_trans_button = "Translate",
        translate_update_button = "Import Translation to Timeline",
        translate_selected_button = "Translate Selected",
        auto_follow_check = "Follow Playhead",
        translate_retry_failed_button = "Retry Failed",
        translate_editor_placeholder = "Edit translation here",
        openai_config_label = "OpenAI Format",
        openai_config_button = "Config",
        azure_config_label = "Azure API",
        azure_config_button = "Config",
        azure_config_window_title = "Azure API",
        azure_config_header = "Azure API",
        azure_region_label = "Region",
        azure_api_key_label = "Key",
        azure_confirm_button = "OK",
        azure_register_button = "Register",
        deepl_config_label = "DeepL API",
        deepl_config_button = "Config",
        deepl_config_window_title = "DeepL API",
        deepl_config_header = "DeepL API",
        deepl_api_key_label = "Key",
        deepl_confirm_button = "OK",
        deepl_register_button = "Register",
        concurrency_label = "Mode",
        concurrency_option_low = "Low",
        concurrency_option_standard = "Medium",
        concurrency_option_high = "High",
        openai_config_window_title = "OpenAI Format API",
        openai_config_header = "Fill API Info",
        openai_model_label = "Model",
        openai_model_name_label = "Model ID",
        openai_base_url_label = "* Base URL",
        openai_api_key_label = "* API Key",
        openai_temperature_label = "* Temperature",
        system_prompt_label = "* System Prompt",
        openai_verify_button = "Verify",
        openai_add_button = "Add Model",
        openai_delete_button = "Delete Model",
        openai_close_button = "Close",
        openai_new_model_display_label = "* Display Name",
        openai_new_model_name_label = "* Model Name",
        openai_add_model_title = "Add OpenAI Format Model",
        openai_status_ready = "",
        openai_delete_builtin_warning = "Built-in models cannot be removed",
        openai_verify_success = "Model verified successfully",
        openai_verify_failed = "Model verification failed: %s",
        openai_add_success = "Model added",
        openai_add_duplicate = "Model already exists",
        openai_missing_fields = "Fill in all required fields",
        openai_delete_success = "Model removed",
    }
}

local messages = {
    current_total = { cn = "%d", en = "Total subtitles: %d" },
    loaded_count = { cn = " %d ", en = "Loaded %d subtitles" },
    loading_started = { cn = "...", en = "Loading subtitles..." },
    loading_progress = { cn = "%d/%d", en = "Loading subtitles: %d/%d" },
    loading_tracks = { cn = "...", en = "Locating subtitle tracks..." },
    loading_collect = { cn = " %d ", en = "Subtitle track found, preparing to read %d subtitles" },
    loading_sorting = { cn = "...", en = "Sorting subtitles..." },
    loading_empty = { cn = "", en = "No subtitles found on the timeline" },
    enter_find_text = { cn = "", en = "Enter text to find" },
    no_find_results = { cn = "", en = "No matching subtitles" },
    find_match_count = { cn = " %d ", en = "%d subtitles matched" },
    replace_no_find = { cn = "", en = "Enter text to replace" },
    no_replace = { cn = "", en = "No replacements made" },
    replace_done = { cn = " %d ", en = "Replaced %d occurrence(s)" },
    no_entries_update = { cn = "", en = "No subtitles to update" },
    write_failed = { cn = " SRT ", en = "Failed to write SRT" },
    import_failed = { cn = " SRT ", en = "Failed to import SRT" },
    updated_success = { cn = "", en = "Timeline subtitles updated" },
    jump_failed = { cn = "", en = "Unable to jump to timecode" },
    jump_success = { cn = " %s", en = "Jumped to %s" },
    no_timeline = { cn = "/", en = "No active project or timeline" },
    cannot_read_subtitles = { cn = "", en = "Unable to read subtitles" },
    create_srt_folder_failed = { cn = " srt ", en = "Unable to create 'srt' media pool folder" },
    append_failed = { cn = "", en = "Failed to append subtitles to timeline" },
    match_progress = { cn = " %d  %d ", en = "Match: result %d of %d" },
    matches_rows_occ = { cn = "%d %d ", en = "Rows: %d; Occurrences: %d" },
    retry_no_failed = { cn = "", en = "No failed subtitles to retry." },

}

local translateStatusTemplates = {
    idle = { cn = "", en = "Ready to translate" },
    copying = { cn = "...", en = "Copying subtitles..." },
    no_entries = { cn = "", en = "No subtitles to translate" },
    fetching_key = { cn = "...", en = "Fetching translator credential..." },
    progress = { cn = " %d/%d  :%d", en = "Translating %d/%d  Tokens:%d" },
    success = { cn = " %d %d %d :%d", en = "Translation finished: %d subtitles, %d succeeded, %d failed. Tokens:%d" },
    failed = { cn = "%s", en = "Translation failed: %s" },
    updating = { cn = " SRT...", en = "Generating and importing SRT..." },
    updated = { cn = "", en = "Translated subtitles imported" },
}

local translateErrorMessages = {
    missing_key = { cn = "", en = "Unable to fetch service credential. Please try again later." },
    request_failed = { cn = "", en = "Network request failed. Please check your connection." },
    decode_failed = { cn = "", en = "Failed to decode service response." },
    translation_failed = { cn = "", en = "Translation failed. Please try again." },
    empty_translation = { cn = "", en = "The service returned an empty result." },
    provider_not_supported = { cn = "", en = "The selected provider is not supported yet." },
    no_timeline = { cn = "", en = "No active timeline available." },
    invalid_response = { cn = "", en = "Service returned an invalid payload." },
    no_selection = { cn = "", en = "Select a row to translate first." },
    missing_target_lang = { cn = "", en = "Select a target language." },
    openai_missing_key = { cn = " OpenAI API Key", en = "Enter the OpenAI API key in settings." },
    openai_missing_base = { cn = " OpenAI Base URL", en = "Enter the OpenAI Base URL in settings." },
    openai_missing_model = { cn = " OpenAI ", en = "Select a valid OpenAI model." },
    openai_parallel_failed = { cn = "", en = "Parallel requests failed; affected lines were marked with error text." },
    deepl_missing_key = { cn = " DeepL API Key", en = "Enter the DeepL API key in settings." },
}

local SUPABASE_URL = "https://tbjlsielfxmkxldzmokc.supabase.co"
local SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRiamxzaWVsZnhta3hsZHptb2tjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgxMDc3MDIsImV4cCI6MjA3MzY4MzcwMn0.FTgYJJ-GlMcQKOSWu63TufD6Q_5qC_M4cvcd3zpcFJo"
local SUPABASE_TIMEOUT = 5

------------------------------------------------------------------
-- runShellCommand
------------------------------------------------------------------


local runHiddenWindowsCommand, runShellCommand
local winfs
do
    local okHttps, https = pcall(require, "ssl.https")
    local okLtn12, ltn12 = pcall(require, "ltn12")
    if okHttps and okLtn12 and https and ltn12 then
        httpClient.https = {
            get = function(url, headers, timeout)
                local sinkTable = {}
                local requestHeaders = {}
                if headers then
                    for k, v in pairs(headers) do
                        requestHeaders[k] = v
                    end
                end
                requestHeaders["content-length"] = "0"
                local ok, statusCode, respHeaders, statusLine = https.request({
                    url = url,
                    method = "GET",
                    headers = requestHeaders,
                    sink = ltn12.sink.table(sinkTable),
                    protocol = "tlsv1_2",
                    verify = "none",
                    timeout = timeout or SUPABASE_TIMEOUT,
                })
                if not ok then
                    return nil, statusCode or statusLine or "request_failed"
                end
                local body = table.concat(sinkTable)
                local code = tonumber(statusCode) or tonumber(respHeaders and respHeaders.status) or statusCode
                return body, code
            end,
            postJson = function(url, payload, headers, timeout)
                local sinkTable = {}
                local requestHeaders = {}
                if headers then
                    for k, v in pairs(headers) do
                        requestHeaders[k] = v
                    end
                end
                local bodyStr = payload or ""
                requestHeaders["content-type"] = "application/json"
                requestHeaders["content-length"] = tostring(#bodyStr)
                local ok, statusCode, respHeaders, statusLine = https.request({
                    url = url,
                    method = "POST",
                    headers = requestHeaders,
                    source = ltn12.source.string(bodyStr),
                    sink = ltn12.sink.table(sinkTable),
                    protocol = "tlsv1_2",
                    verify = "none",
                    timeout = timeout or SUPABASE_TIMEOUT,
                })
                if not ok then
                    return nil, statusCode or statusLine or "request_failed"
                end
                local body = table.concat(sinkTable)
                local code = tonumber(statusCode) or tonumber(respHeaders and respHeaders.status) or statusCode
                return body, code
            end
        }
    end
end

function Services.httpGet(url, headers, timeout)
    if httpClient.https then
        local body, code = httpClient.https.get(url, headers, timeout)
        if body then return body, code end
    end

    local headerParts = {}
    if headers then
        for k, v in pairs(headers) do
            local cleanValue = tostring(v):gsub('"', '\\"')
            table.insert(headerParts, string.format('-H "%s: %s"', k, cleanValue))
        end
    end
    local maxTime = timeout or SUPABASE_TIMEOUT
    local curlCommand = string.format('curl -sS -m %d %s "%s"', maxTime, table.concat(headerParts, " "), url)
    local sep = package.config:sub(1, 1)

    if sep == "\\" then
        local outPath, err = Utils.makeTempPath("out")
        if not outPath then return nil, "tmpname_failed:" .. tostring(err) end
        local redirected = string.format('%s > "%s" 2>nul', curlCommand, outPath)
        local ok = runShellCommand and runShellCommand(redirected)
        local body = Utils.readFile(outPath) or ""
        os.remove(outPath)
        if not ok then return nil, "curl_hidden_failed" end
        if body == "" then return nil, "empty_response" end
        return body, nil
    end

    curlCommand = curlCommand .. " 2>/dev/null"
    local pipe = io.popen(curlCommand, "r")
    if not pipe then return nil, "curl_popen_failed" end
    local body = pipe:read("*a") or ""
    pipe:close()
    if body == "" then return nil, "empty_response" end
    return body, nil
end


function Services.httpPostJson(url, payload, headers, timeout)
    local bodyStr = payload or ""
    if httpClient.https and httpClient.https.postJson then
        local body, code = httpClient.https.postJson(url, bodyStr, headers, timeout)
        if body then return body, code end
    end

    local headerParts, hasContentType = {}, false
    if headers then
        for k, v in pairs(headers) do
            local cleanValue = tostring(v):gsub('"', '\\"')
            table.insert(headerParts, string.format('-H "%s: %s"', k, cleanValue))
            if type(k) == "string" and k:lower() == "content-type" then
                hasContentType = true
            end
        end
    end
    if not hasContentType then
        table.insert(headerParts, '-H "Content-Type: application/json"')
    end

    local maxTime = timeout or SUPABASE_TIMEOUT
    local sep = package.config:sub(1, 1)

    -- 
    local tempPayload, err1 = Utils.makeTempPath("json")
    if not tempPayload then return nil, "tmpname_failed:" .. tostring(err1) end
    local okWrite, err2 = Utils.writeFile(tempPayload, bodyStr)
    if not okWrite then return nil, "payload_tmp_open_failed:" .. tostring(err2) end

    if sep == "\\" then
        local outputPath, err3 = Utils.makeTempPath("out")
        if not outputPath then os.remove(tempPayload); return nil, "tmpname_failed:" .. tostring(err3) end

        local curlCommand = string.format(
            'curl -sS -m %d -X POST %s --data-binary "@%s" "%s"',
            maxTime, table.concat(headerParts, " "), tempPayload, url
        )
        local redirected = string.format('%s > "%s" 2>nul', curlCommand, outputPath)
        local ok = runShellCommand and runShellCommand(redirected)

        local body = Utils.readFile(outputPath) or ""
        os.remove(outputPath)
        os.remove(tempPayload)

        if not ok then return nil, "curl_hidden_failed" end
        if body == "" then return nil, "empty_response" end
        return body, nil
    else
        local curlCommand = string.format(
            'curl -sS -m %d -X POST %s --data-binary @%q "%s" 2>/dev/null',
            maxTime, table.concat(headerParts, " "), tempPayload, url
        )
        local pipe = io.popen(curlCommand, "r")
        if not pipe then os.remove(tempPayload); return nil, "curl_popen_failed" end
        local body = pipe:read("*a") or ""
        pipe:close()
        os.remove(tempPayload)
        if body == "" then return nil, "empty_response" end
        return body, nil
    end
end


-- Services.Parallel: shared curl-based parallel executor
function ParallelServices.runCurlParallel(tasks, options)
    if not tasks or #tasks == 0 then
        return {}, nil
    end
    local tempDir = Utils.getTempDir()
    if not Utils.ensureDir(tempDir) then
        return nil, "temp_dir_failed"
    end
    options = options or {}
    local apiUrl = options.apiUrl or GLM_API_URL
    if not apiUrl or apiUrl == "" then
        return nil, "invalid_api_url"
    end
    local timeout = options.timeout or GLM_TIMEOUT
    local limit = math.max(1, math.min(options.parallelLimit or #tasks, #tasks))
    local payloadPrefix = options.payloadPrefix or "chat_payload"
    local outputPrefix = options.outputPrefix or "chat_output"
    local headers = {}
    if type(options.headers) == "table" then
        for _, header in ipairs(options.headers) do
            if type(header) == "string" and Utils.trim(header) ~= "" then
                table.insert(headers, header)
            end
        end
    end
    local parser = options.parseResponse
    if type(parser) ~= "function" then
        parser = GLMService.parseResponseBody
    end
    local commandParts = { "curl", "-sS", "--show-error", "--parallel", "--parallel-immediate", string.format("--parallel-max %d", limit), string.format("-m %d", timeout) }
    local artifacts = {}
    local createdCount = 0
    local function cleanupArtifacts()
        for _, art in ipairs(artifacts) do
            if art.output then os.remove(art.output) end
            if art.payload then os.remove(art.payload) end
        end
    end
    for idx, task in ipairs(tasks) do
        local payloadName = string.format("%s_%s_%d_%d.json", payloadPrefix, state.sessionCode or "sess", os.time(), idx + createdCount)
        local outputName = string.format("%s_%s_%d_%d.json", outputPrefix, state.sessionCode or "sess", os.time(), idx + createdCount)
        createdCount = createdCount + 1
        local payloadPath = Utils.joinPath(tempDir, payloadName)
        local outputPath = Utils.joinPath(tempDir, outputName)
        local okWrite, err = Utils.writeFile(payloadPath, task.payload or "")
        if not okWrite then cleanupArtifacts(); return nil, string.format("payload_tmp_open_failed: %s", tostring(err)) end
        table.insert(artifacts, { index = task.index, payload = payloadPath, output = outputPath })
        table.insert(commandParts, "-X")
        table.insert(commandParts, "POST")
        for _, header in ipairs(headers) do
            table.insert(commandParts, "-H")
            table.insert(commandParts, string.format("%q", header))
        end
        table.insert(commandParts, "--data-binary")
        table.insert(commandParts, string.format("@%q", payloadPath))
        table.insert(commandParts, "-o")
        table.insert(commandParts, string.format("%q", outputPath))
        table.insert(commandParts, string.format("%q", task.url or apiUrl))
        if idx < #tasks then table.insert(commandParts, "--next") end
    end
    local command = table.concat(commandParts, " ")
    local ok = runShellCommand(command)
    if not ok then cleanupArtifacts(); return nil, "parallel_execution_failed" end
    local results = {}
    local anyOutput = false
    for _, art in ipairs(artifacts) do
        local body = Utils.readFile(art.output)
        if body and body ~= "" then
            anyOutput = true
            local translation, extra, errMsg = parser(body)
            if translation then
                results[art.index] = { success = true, translation = translation, tokens = extra or 0, meta = extra }
            else
                results[art.index] = { success = false, err = errMsg or "translation_failed" }
            end
        else
            results[art.index] = { success = false, err = "empty_response" }
        end
        if art.output then os.remove(art.output) end
        if art.payload then os.remove(art.payload) end
    end
    if not anyOutput then return nil, "parallel_execution_failed" end
    return results, nil
end

function Services.supabaseCheckUpdate(pluginId)
    if not pluginId or pluginId == "" then
        return nil
    end
    local url = string.format("%s/functions/v1/check_update?pid=%s", SUPABASE_URL, Utils.urlEncode(pluginId))
    local headers = {
        Authorization = "Bearer " .. SUPABASE_ANON_KEY,
        apikey = SUPABASE_ANON_KEY,
        ["Content-Type"] = "application/json",
        ["User-Agent"] = string.format("%s/%s", SCRIPT_NAME, SCRIPT_VERSION),
    }
    local body, status = Services.httpGet(url, headers, SUPABASE_TIMEOUT)
    if not body then
        if status then
            print(string.format("[Update] Supabase request failed: %s", tostring(status)))
        end
        return nil
    end
    if status and status ~= 200 then
        if status ~= 400 and status ~= 404 then
            print(string.format("[Update] Unexpected status code: %s", tostring(status)))
        end
        return nil
    end
    local decoded, pos, err = json.decode(body)
    if type(decoded) ~= "table" then
        print(string.format("[Update] Invalid response: %s (pos=%s, err=%s)", tostring(body), tostring(pos), tostring(err)))
        return nil
    end
    return decoded
end

local SEP = package.config:sub(1, 1)

local IS_WINDOWS = (SEP == "\\")

-- Windows helpers (ffi): hidden command + UTF-8 safe file IO
if IS_WINDOWS then
    local okFfi, ffi = pcall(require, "ffi")
    if okFfi and ffi then
        local okKernel, kernel32 = pcall(ffi.load, "kernel32")
        local okMsvcrt, msvcrt = pcall(ffi.load, "msvcrt")

        if okKernel and kernel32 then
            local CP_UTF8 = 65001
            local CREATE_NO_WINDOW = 0x08000000
            local STARTF_USESHOWWINDOW = 0x00000001
            local INFINITE = 0xFFFFFFFF

            pcall(ffi.cdef, [[
                typedef unsigned short WORD;
                typedef unsigned long DWORD;
                typedef int BOOL;
                typedef void* HANDLE;
                typedef wchar_t* LPWSTR;
                typedef const wchar_t* LPCWSTR;
                typedef void* LPVOID;
                typedef unsigned char BYTE;

                typedef struct _STARTUPINFOW {
                    DWORD cb;
                    LPWSTR lpReserved;
                    LPWSTR lpDesktop;
                    LPWSTR lpTitle;
                    DWORD dwX;
                    DWORD dwY;
                    DWORD dwXSize;
                    DWORD dwYSize;
                    DWORD dwXCountChars;
                    DWORD dwYCountChars;
                    DWORD dwFillAttribute;
                    DWORD dwFlags;
                    WORD wShowWindow;
                    WORD cbReserved2;
                    BYTE *lpReserved2;
                    HANDLE hStdInput;
                    HANDLE hStdOutput;
                    HANDLE hStdError;
                } STARTUPINFOW;

                typedef struct _PROCESS_INFORMATION {
                    HANDLE hProcess;
                    HANDLE hThread;
                    DWORD dwProcessId;
                    DWORD dwThreadId;
                } PROCESS_INFORMATION;

                BOOL CreateProcessW(
                    LPCWSTR lpApplicationName,
                    LPWSTR lpCommandLine,
                    LPVOID lpProcessAttributes,
                    LPVOID lpThreadAttributes,
                    BOOL bInheritHandles,
                    DWORD dwCreationFlags,
                    LPVOID lpEnvironment,
                    LPCWSTR lpCurrentDirectory,
                    STARTUPINFOW *lpStartupInfo,
                    PROCESS_INFORMATION *lpProcessInformation
                );

                DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
                BOOL GetExitCodeProcess(HANDLE hProcess, DWORD *lpExitCode);
                BOOL CloseHandle(HANDLE hObject);
                DWORD GetLastError(void);
                int MultiByteToWideChar(unsigned int CodePage, DWORD dwFlags,
                                        const char *lpMultiByteStr, int cbMultiByte,
                                        wchar_t *lpWideCharStr, int cchWideChar);
            ]])

            local function utf8ToWideBuffer(str)
                local okReq, required = pcall(function()
                    return kernel32.MultiByteToWideChar(CP_UTF8, 0, str, -1, nil, 0)
                end)
                if not okReq or required == 0 then
                    return nil
                end
                local buffer = ffi.new("wchar_t[?]", required)
                local okFill, filled = pcall(function()
                    return kernel32.MultiByteToWideChar(CP_UTF8, 0, str, -1, buffer, required)
                end)
                if not okFill or filled == 0 then
                    return nil
                end
                return buffer
            end

            local okCreate = pcall(function() return kernel32.CreateProcessW end)
            local okM2W = pcall(function() return kernel32.MultiByteToWideChar end)
            if okCreate and okM2W then
                runHiddenWindowsCommand = function(command)
                    local comspec = os.getenv("COMSPEC") or "C:\\Windows\\System32\\cmd.exe"
                    local fullCommand = string.format('"%s" /c %s', comspec, command)
                    local cmdBuffer = utf8ToWideBuffer(fullCommand)
                    if not cmdBuffer then
                        return false, "command_encoding_failed"
                    end

                    local startupInfo = ffi.new("STARTUPINFOW")
                    startupInfo.cb = ffi.sizeof(startupInfo)
                    startupInfo.dwFlags = STARTF_USESHOWWINDOW
                    startupInfo.wShowWindow = 0 -- SW_HIDE

                    local processInfo = ffi.new("PROCESS_INFORMATION")
                    local created = kernel32.CreateProcessW(
                        nil,
                        cmdBuffer,
                        nil,
                        nil,
                        false,
                        CREATE_NO_WINDOW,
                        nil,
                        nil,
                        startupInfo,
                        processInfo
                    )

                    if created == 0 then
                        return false, kernel32.GetLastError()
                    end

                    kernel32.WaitForSingleObject(processInfo.hProcess, INFINITE)
                    local exitCodeArr = ffi.new("DWORD[1]", 0)
                    kernel32.GetExitCodeProcess(processInfo.hProcess, exitCodeArr)
                    kernel32.CloseHandle(processInfo.hProcess)
                    kernel32.CloseHandle(processInfo.hThread)

                    return exitCodeArr[0] == 0, exitCodeArr[0]
                end
            end
        end

        if okKernel and okMsvcrt and kernel32 and msvcrt then
            local CP_UTF8 = 65001

            local okSizeT = pcall(function() return ffi.sizeof("size_t") end)
            if not okSizeT then
                pcall(ffi.cdef, [[ typedef unsigned long size_t; ]])
            end

            pcall(ffi.cdef, [[
                typedef struct _iobuf FILE;
                FILE* _wfopen(const wchar_t* filename, const wchar_t* mode);
                int fclose(FILE* stream);
                size_t fread(void* ptr, size_t size, size_t count, FILE* stream);
                size_t fwrite(const void* ptr, size_t size, size_t count, FILE* stream);
                int fseek(FILE* stream, long offset, int origin);
                long ftell(FILE* stream);
            ]])

            local okM2W = pcall(function() return kernel32.MultiByteToWideChar end)
            local okWfopen = pcall(function() return msvcrt._wfopen end)
            local okFclose = pcall(function() return msvcrt.fclose end)
            local okFseek = pcall(function() return msvcrt.fseek end)
            local okFtell = pcall(function() return msvcrt.ftell end)
            local okFread = pcall(function() return msvcrt.fread end)
            local okFwrite = pcall(function() return msvcrt.fwrite end)
            local canWinfs = okM2W and okWfopen and okFclose and okFseek and okFtell and okFread and okFwrite

            if canWinfs then
                local function utf8ToWide(str)
                    local okReq, needed = pcall(function()
                        return kernel32.MultiByteToWideChar(CP_UTF8, 0, str, -1, nil, 0)
                    end)
                    if not okReq or needed == 0 then
                        return nil
                    end
                    local buf = ffi.new("wchar_t[?]", needed)
                    local okFill, filled = pcall(function()
                        return kernel32.MultiByteToWideChar(CP_UTF8, 0, str, -1, buf, needed)
                    end)
                    if not okFill or filled == 0 then
                        return nil
                    end
                    return buf
                end

                local function openWide(path, mode)
                    local wpath = utf8ToWide(path or "")
                    local wmode = utf8ToWide(mode or "rb")
                    if not wpath or not wmode then
                        return nil, "path_encoding_failed"
                    end
                    local f = msvcrt._wfopen(wpath, wmode)
                    if f == nil then
                        return nil, "wfopen_failed"
                    end
                    return f
                end

                winfs = {}

                function winfs.readFile(path)
                    local f, err = openWide(path, "rb")
                    if not f then
                        return nil, err
                    end
                    msvcrt.fseek(f, 0, 2)
                    local size = tonumber(msvcrt.ftell(f)) or 0
                    if size < 0 then
                        size = 0
                    end
                    msvcrt.fseek(f, 0, 0)
                    if size == 0 then
                        msvcrt.fclose(f)
                        return ""
                    end
                    local buf = ffi.new("char[?]", size)
                    local read = tonumber(msvcrt.fread(buf, 1, size, f)) or 0
                    msvcrt.fclose(f)
                    return ffi.string(buf, read)
                end

                function winfs.writeFile(path, content)
                    local f, err = openWide(path, "wb")
                    if not f then
                        return false, err
                    end
                    local data = content or ""
                    local len = #data
                    local written = tonumber(msvcrt.fwrite(data, 1, len, f)) or 0
                    msvcrt.fclose(f)
                    if written ~= len then
                        return false, "write_failed"
                    end
                    return true, nil
                end

                function winfs.fileExists(path)
                    local f = select(1, openWide(path, "rb"))
                    if f then
                        msvcrt.fclose(f)
                        return true
                    end
                    return false
                end

                function winfs.getFileSize(path)
                    local f = select(1, openWide(path, "rb"))
                    if not f then
                        return nil
                    end
                    msvcrt.fseek(f, 0, 2)
                    local size = tonumber(msvcrt.ftell(f))
                    msvcrt.fclose(f)
                    return size
                end
            end
        end
    end
end

function runShellCommand(command)
    if IS_WINDOWS and type(runHiddenWindowsCommand) == "function" then
        local ok, code = runHiddenWindowsCommand(command)
        if not ok then
            print(string.format("Command failed (exit=%s)", tostring(code)))
        end
        return ok == true, tonumber(code) or 0
    end

    -- *nixos.execute  Lua 
    local res, how, code = os.execute(command)
    if type(res) == "number" then
        return res == 0, res
    end
    if res == true then
        if how == "exit" then
            return (code or 0) == 0, (code or 0)
        end
        return true, 0
    end
    return false, (type(code) == "number" and code or 1)
end
------------------------------------------------------------------
-- runShellCommand
------------------------------------------------------------------

function Utils.trim(s)
    if type(s) ~= "string" then
        return ""
    end
    return (s:gsub("^%s+", ""):gsub("%s+$", ""))
end

function Utils.urlEncode(str)
    if not str then
        return ""
    end
    return tostring(str):gsub("([^%w%-_%.%~])", function(c)
        return string.format("%%%02X", string.byte(c))
    end)
end


function Utils.scriptDir()
    local sep = package.config:sub(1,1)
    local source = debug.getinfo(1, "S").source
    if source:sub(1, 1) == "@" then
        source = source:sub(2)
    end
    local pattern = "(.*" .. sep .. ")"
    if sep == "\\" then
        pattern = "(.*[\\/])" -- 
    end
    return source:match(pattern) or ""
end

function Utils.joinPath(a, b)
    local sep = package.config:sub(1,1)
    if a == "" then
        return b
    end
    if a:sub(-1) == sep then
        return a .. b
    end
    return a .. sep .. b
end
function Utils.makeTempPath(ext)
    local dir = Utils.getTempDir()
    Utils.ensureDir(dir)
    local ts  = tostring(os.time())
    local rnd = string.format("%06d", math.random(0, 999999))
    local base = string.format("tmp_%s_%s_%s", tostring(state.sessionCode or "0000"), ts, rnd)
    if ext and ext ~= "" then
        if not ext:match("^%.") then ext = "." .. ext end
    else
        ext = ""
    end
    local path = Utils.joinPath(dir, base .. ext)
    local i = 0
    while Utils.fileExists(path) do
        i = i + 1
        path = Utils.joinPath(dir, base .. "_" .. i .. ext)
        if i > 1000 then return nil, "temp_name_exhausted" end
    end
    return path
end
function Utils.getTempDir()
    return Utils.joinPath(Utils.scriptDir(), "temp")
end


-- 
function Utils.sanitizeFilename(name)
    name = tostring(name or "timeline")
    name = name:gsub("[%c%z]", "")
    name = name:gsub("[/\\:%*%?%\"]", "_")
    name = name:gsub("[<>|]", "_")
    name = name:gsub("%s+", "_")
    name = name:gsub("^_+", ""):gsub("_+$", "")
    if name == "" then name = "timeline" end
    return name
end

-- 
function Utils.listFiles(dir)
    local sep = package.config:sub(1,1)
    local cmd
    if sep == "\\" then
        cmd = string.format('dir /b "%s"', dir)
    else
        cmd = string.format('ls -1 "%s"', dir:gsub('"','\\"'))
    end
    local p = io.popen(cmd)
    if not p then return {} end
    local t = {}
    for line in p:lines() do
        table.insert(t, line)
    end
    p:close()
    return t
end

function Utils.escapePlainPattern(text)
    return text:gsub("([^%w])", "%%%1")
end

function Utils.ensureDir(path)
    if path == "" then
        return true
    end
    if bmd and bmd.fileexists and bmd.fileexists(path) then
        return true
    end
    if IS_WINDOWS then
        if not runShellCommand(string.format('if not exist "%s" mkdir "%s"', path, path)) then
            print("Failed to create directory: " .. path)
            return false
        end
    else
        local escaped = path:gsub("'", "'\\''")
        if not runShellCommand("mkdir -p '" .. escaped .. "'") then
            print("Failed to create directory: " .. path)
            return false
        end
    end
    return true
end

function Utils.fileExists(path)
    if IS_WINDOWS and winfs and winfs.fileExists then
        return winfs.fileExists(path)
    end
    local f = io.open(path, "rb")
    if f then
        f:close()
        return true
    end
    return false
end

function Utils.getFileSize(path)
    if IS_WINDOWS and winfs and winfs.getFileSize then
        return tonumber(winfs.getFileSize(path)) or 0
    end
    local f = io.open(path, "rb")
    if not f then
        return 0
    end
    local size = f:seek("end") or 0
    f:close()
    return size
end

function Utils.readFile(path)
    if IS_WINDOWS and winfs and winfs.readFile then
        return winfs.readFile(path)
    end
    local f, err = io.open(path, "rb")
    if not f then
        return nil, err
    end
    local content = f:read("*a")
    f:close()
    return content or ""
end

function Utils.writeFile(path, content)
    if IS_WINDOWS and winfs and winfs.writeFile then
        return winfs.writeFile(path, content)
    end
    local f, err = io.open(path, "wb")
    if not f then
        return false, err
    end
    f:write(content or "")
    f:close()
    return true
end

function Utils.removeDir(path)
    if not path or path == "" then
        return
    end
    if IS_WINDOWS then
        if not runShellCommand(string.format('rmdir /S /Q "%s"', path)) then
            print("Failed to remove directory: " .. path)
        end
    else
        local escaped = path:gsub("'", "'\\''")
        if not runShellCommand("rm -rf '" .. escaped .. "'") then
            print("Failed to remove directory: " .. path)
        end
    end
end

function Utils.openExternalUrl(url)
    if not url or url == "" then
        return
    end
    if bmd and bmd.openurl then
        local ok, err = pcall(bmd.openurl, url)
        if not ok then
            print("openurl failed: " .. tostring(err))
        end
        return
    end
    if IS_WINDOWS then
        runShellCommand(string.format('start "" "%s"', url))
        return
    end
    local escaped = url:gsub("'", "'\\''")
    local ok = runShellCommand("open '" .. escaped .. "'")
    if not ok then
        runShellCommand("xdg-open '" .. escaped .. "'")
    end
end



--  Lua Base64 
function Utils.base64Decode(data)
    data = data:gsub("[^%w%+%/%=]", "")
    local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    local t = {}
    local pad = 0
    if data:sub(-2) == "==" then pad = 2
    elseif data:sub(-1) == "=" then pad = 1 end
    for i=1, #data, 4 do
        local n = 0
        for j=0,3 do
            local c = data:sub(i+j, i+j)
            if c ~= "=" and c ~= "" then
                n = n * 64 + (b:find(c,1,true) - 1)
            else
                n = n * 64
            end
        end
        local bytes = string.char(math.floor(n/65536)%256, math.floor(n/256)%256, n%256)
        t[#t+1] = bytes
    end
    local out = table.concat(t)
    if pad > 0 then out = out:sub(1, #out - pad) end
    return out
end

--  Base64 
function Utils.createImageFromBase64(base64Data, destinationPath)
    local ok, bytes = pcall(Utils.base64Decode, base64Data)
    if not ok or not bytes then
        print("Base64 : " .. tostring(bytes))
        return false
    end

    local okWrite, err = Utils.writeFile(destinationPath, bytes)
    if not okWrite then
        print(": " .. tostring(err))
        return false
    end
    return true
end


-- ========= Fraction & FPS helpers =========
Subtitle.Fraction = {}

local function _gcd(a, b)
    a, b = math.abs(a), math.abs(b)
    while b ~= 0 do a, b = b, a % b end
    return a
end

local function _normalize(num, den)
    if den == 0 then return 0, 1 end
    if den < 0 then num, den = -num, -den end
    local g = _gcd(num, den)
    return math.floor(num / g), math.floor(den / g)
end

--  fps number / "30000/1001" / "23.976" / table{num,den}
function Subtitle.fpsToFraction(v)
    if type(v) == "table" and v.num and v.den then
        local n, d = _normalize(tonumber(v.num) or 0, tonumber(v.den) or 1)
        if n <= 0 or d <= 0 then return { num = 24, den = 1 } end
        return { num = n, den = d }
    end
    if type(v) == "string" then
        v = v:match("^%s*(.-)%s*$")
        local a, b = v:match("^(%d+)%s*/%s*(%d+)$")
        if a and b then
            local n, d = _normalize(tonumber(a), tonumber(b))
            return { num = n, den = d }
        end
        --  NTSC 
        if v == "23.976" then return { num = 24000, den = 1001 } end
        if v == "29.97"  then return { num = 30000, den = 1001 } end
        if v == "59.94"  then return { num = 60000, den = 1001 } end
        if v == "47.952" then return { num = 48000, den = 1001 } end
        if v == "119.88" then return { num = 120000, den = 1001 } end
    end
    -- number fps 
    if type(v) == "number" then
        local f = v
        local function near(x,y) return math.abs(x - y) < 1e-3 end
        if near(f, 23.976) then return { num = 24000, den = 1001 } end
        if near(f, 29.97 ) then return { num = 30000, den = 1001 } end
        if near(f, 59.94 ) then return { num = 60000, den = 1001 } end
        if near(f, 47.952) then return { num = 48000, den = 1001 } end
        if near(f, 119.88) then return { num = 120000, den = 1001 } end
        if f > 0 then return { num = math.floor(f + 0.5), den = 1 } end
    end
    return { num = 24, den = 1 }
end

function Subtitle.fpsAsFloat(frac)
    if type(frac) == "table" and frac.num and frac.den then
        return frac.num / frac.den
    end
    local f = Subtitle.fpsToFraction(frac)
    return f.num / f.den
end

--  HH:MM:SS:FF FF Whisper  round 
function Subtitle.fpsTimebase(frac)
    local f = Subtitle.fpsAsFloat(frac)
    return math.floor(f + 0.5) -- 23.97624, 29.9730, 59.9460 
end

function Subtitle.framesToSeconds(frames, frac)
    local f = Subtitle.fpsToFraction(frac)
    return (frames * f.den) / f.num
end

function Subtitle.secondsToFrames(seconds, frac)
    local f = Subtitle.fpsToFraction(frac)
    return math.floor(seconds * f.num / f.den + 0.5)
end

--  fps HH:MM:SS,mmm
function Subtitle.framesToSrtTimestamp(frames, fps_spec)
    local f = Subtitle.fpsToFraction(fps_spec)
    local fr = math.max(0, math.floor(frames or 0))
    -- total_ms = round(frames * 1000 * den / num)
    local total_ms = math.floor(fr * 1000 * f.den / f.num + 0.5)

    local s  = math.floor(total_ms / 1000)
    local ms = total_ms - s * 1000
    local hh = math.floor(s / 3600); s = s - hh * 3600
    local mm = math.floor(s / 60);   s = s - mm * 60
    local ss = s
    return string.format("%02d:%02d:%02d,%03d", hh, mm, ss, ms)
end

--  = round(fps)HH:MM:SS:FF
function Subtitle.framesToTimecode(frames, fps_spec)
    local f = Subtitle.fpsToFraction(fps_spec)
    local base = Subtitle.fpsTimebase(f) -- e.g. 23.976 -> 24
    local fr = math.max(0, math.floor(frames or 0))

    local frames_per_hour = base * 3600
    local frames_per_min  = base * 60

    local hh = math.floor(fr / frames_per_hour); fr = fr - hh * frames_per_hour
    local mm = math.floor(fr / frames_per_min);  fr = fr - mm * frames_per_min
    local ss = math.floor(fr / base)
    local ff = fr - ss * base

    return string.format("%02d:%02d:%02d:%02d", hh, mm, ss, ff)
end


function Subtitle.timecodeToFrames(tc, fps_spec)
    if not tc or tc == "" then
        return nil
    end
    local hh, mm, ss, ff = tc:match("^(%d+):(%d+):(%d+):(%d+)$")
    if not hh then
        hh, mm, ss, ff = tc:match("^(%d+):(%d+):(%d+);(%d+)$")
    end
    if not hh then
        return nil
    end
    hh, mm, ss, ff = tonumber(hh), tonumber(mm), tonumber(ss), tonumber(ff)
    if not (hh and mm and ss and ff) then
        return nil
    end
    local frac = Subtitle.fpsToFraction(fps_spec)
    local base = Subtitle.fpsTimebase(frac)
    local totalFrames = (((hh * 60) + mm) * 60 + ss) * base + ff

    return totalFrames
end

function Subtitle.getTimelineContext()
    local pm = resolve:GetProjectManager()
    if not pm then
        return nil
    end
    local project = pm:GetCurrentProject()
    if not project then
        return nil
    end
    local timeline = project:GetCurrentTimeline()
    if not timeline then
        return nil
    end
    local mediaPool = project:GetMediaPool()
    if not mediaPool then
        return nil
    end
    local rootFolder = mediaPool:GetRootFolder()
    return {
        project = project,
        timeline = timeline,
        mediaPool = mediaPool,
        rootFolder = rootFolder,
    }
end

function Subtitle.sortEntries(entries)
    table.sort(entries, function(a, b)
        if a.startFrame == b.startFrame then
            return a.endFrame < b.endFrame
        end
        return a.startFrame < b.startFrame
    end)
end

function Subtitle.collectSubtitles(opts)
    if type(opts) ~= "table" then
        opts = {}
    end
    local onProgress = type(opts.onProgress) == "function" and opts.onProgress or nil
    local onStage = type(opts.onStage) == "function" and opts.onStage or nil
    local ctx = Subtitle.getTimelineContext()
    if not ctx then
        return false, "no_timeline"
    end
    local timeline = ctx.timeline
    state.timeline = timeline
    local fpsSetting = timeline:GetSetting("timelineFrameRate")
    if not fpsSetting then
        fpsSetting = ctx.project:GetSetting("timelineFrameRate")
    end
    state.fps_frac = Subtitle.fpsToFraction(fpsSetting)       --  
    state.fps_timebase = Subtitle.fpsTimebase(state.fps_frac) --  
    state.fps = state.fps_frac.num / state.fps_frac.den
    local startFrame = timeline:GetStartFrame()
    state.startFrame = startFrame or 0

    local trackCount = timeline:GetTrackCount("subtitle") or 0
    local entries = {}
    state.activeTrackIndex = nil

    if onStage then
        onStage("loading_tracks")
    end

    for track = 1, trackCount do
        local enabled = timeline:GetIsTrackEnabled("subtitle", track)
        if enabled ~= false then
            local itemList = timeline:GetItemListInTrack("subtitle", track)
                if itemList and #itemList > 0 then
                    state.activeTrackIndex = track
                    local totalItems = #itemList
                    if onStage then
                        onStage("loading_collect", totalItems)
                    end
                    if onProgress then
                        onProgress(0, totalItems)
                    end
                    for _, item in ipairs(itemList) do
                        local startValue = item:GetStart() or 0
                        local endValue = item:GetEnd() or startValue
                        local name = item:GetName() or ""
                        local startFrame = math.floor(startValue + 0.5)
                        local endFrame = math.floor(endValue + 0.5)
                        table.insert(entries, {
                            startFrame = startFrame,
                            endFrame = endFrame,
                            startText  = Subtitle.framesToTimecode(startFrame, state.fps_frac),
                            endText    = Subtitle.framesToTimecode(endFrame,   state.fps_frac),
                            text = name,
                        })
                        if onProgress then
                            onProgress(#entries, totalItems)
                        end
                    end
                    break
                end
            end
        end

    if onStage then
        if #entries == 0 then
            onStage("loading_empty")
        else
            onStage("loading_sorting")
        end
    end

    Subtitle.sortEntries(entries)
    local totalEntries = #entries
    for idx, entry in ipairs(entries) do
        local startFrame = entry.startFrame or 0
        local endFrame = entry.endFrame or startFrame
        local nextEntry = entries[idx + 1]
        local nextStart = nextEntry and nextEntry.startFrame or nil
        local endExclusive = (endFrame or startFrame) + 1
        if nextStart and nextStart < endExclusive then
            endExclusive = nextStart
        end
        local intervalEnd = math.max(startFrame + 1, endExclusive)
        entry._intervalEnd = intervalEnd
    end
    if onProgress then
        if totalEntries > 0 then
            onProgress(totalEntries, totalEntries)
        end
    end
    state.entries = entries
    return true
end



function Subtitle.cleanupTempDir()
    local tempDir = Utils.getTempDir()
    if tempDir == "" then
        return
    end
    Utils.removeDir(tempDir)
end

function Subtitle.writeSrt(entries, path, startFrame, fps)
    if not entries or #entries == 0 then
        return false, "no_entries_update"
    end
    --   fps
    local effFps = nil
    if type(fps) == "number" and fps > 0 then
        effFps = fps
    elseif state and type(state.fps) == "number" and state.fps > 0 then
        effFps = state.fps
    else
        local ctx = Subtitle.getTimelineContext()
        if ctx and ctx.timeline then
            local fpsSetting = ctx.timeline:GetSetting("timelineFrameRate")
                or (ctx.project and ctx.project:GetSetting("timelineFrameRate"))
        end
    end
    if not effFps or effFps <= 0 then effFps = 24.0 end  -- 

    local dir = path:match("^(.*)[/\\][^/\\]+$")
    if dir and dir ~= "" then Utils.ensureDir(dir) end
    local chunks = {}

    local baseStart = startFrame or 0
    for idx, entry in ipairs(entries) do
        local s = math.max(0, (entry.startFrame or 0) - baseStart)
        local e = math.max(s + 1, (entry.endFrame   or 0) - baseStart)  
        local sText = Subtitle.framesToSrtTimestamp(s, effFps)
        local eText = Subtitle.framesToSrtTimestamp(e, effFps)
        chunks[#chunks + 1] = string.format("%d\n", idx)
        chunks[#chunks + 1] = string.format("%s --> %s\n", sText, eText)
        chunks[#chunks + 1] = (entry.text or "") .. "\n\n"
    end
    local okWrite, err = Utils.writeFile(path, table.concat(chunks))
    if not okWrite then return false, err or "open_failed" end
    return true
end


function Subtitle.findClipByName(clips, name)
    if not clips then
        return nil
    end
    for _, clip in ipairs(clips) do
        if clip:GetName() == name then
            return clip
        end
    end
    return nil
end

function Subtitle.importSrtToTimeline(path)
    local ctx = Subtitle.getTimelineContext()
    if not ctx then
        return false, "no_timeline"
    end
    local timeline = ctx.timeline
    local mediaPool = ctx.mediaPool
    local root = ctx.rootFolder

    local trackCount = timeline:GetTrackCount("subtitle") or 0
    local targetIndex = nil

    for i = 1, trackCount do
        local enabled = timeline:GetIsTrackEnabled("subtitle", i)
        timeline:SetTrackEnable("subtitle", i, false)

        if not targetIndex then
            local items = timeline:GetItemListInTrack("subtitle", i)
            if not items or #items == 0 then
                targetIndex = i
            end
        end
    end

    if not targetIndex then
        timeline:AddTrack("subtitle")
        local newCount = timeline:GetTrackCount("subtitle")
        if newCount and newCount > trackCount then
            trackCount = newCount
            targetIndex = trackCount
        else
            targetIndex = trackCount > 0 and trackCount or 1
        end
    end

    timeline:SetTrackEnable("subtitle", targetIndex, true)
    state.activeTrackIndex = targetIndex

    local srtFolder = nil
    local subFolders = root and root:GetSubFolderList() or {}
    for _, folder in ipairs(subFolders) do
        if folder:GetName() == "srt" then
            srtFolder = folder
            break
        end
    end
    if not srtFolder then
        srtFolder = mediaPool:AddSubFolder(root, "srt")
    end
    if not srtFolder then
        return false, "create_srt_folder_failed"
    end
    mediaPool:SetCurrentFolder(srtFolder)

    local imported = mediaPool:ImportMedia({ path })
    local mediaItem = nil
    if type(imported) == "table" and #imported > 0 then
        mediaItem = imported[#imported]
    end
    if not mediaItem then
        local baseName = path:match("[^/\\]+$")
        local clips = srtFolder:GetClipList()
        mediaItem = Subtitle.findClipByName(clips, baseName)
    end
    if not mediaItem then
        return false, "import_failed"
    end

    timeline:SetCurrentTimecode(timeline:GetStartTimecode())
    local appendOk = mediaPool:AppendToTimeline({ mediaItem })

    local finalCount = timeline:GetTrackCount("subtitle") or trackCount
    for i = 1, finalCount do
        if i ~= targetIndex then
            timeline:SetTrackEnable("subtitle", i, false)
        end
    end
    timeline:SetTrackEnable("subtitle", targetIndex, true)

    if appendOk == false or appendOk == nil then
        return false, "append_failed"
    end
    return true
end



function Storage.sanitizeOpenAIModelEntry(entry)
    if type(entry) ~= "table" then
        return nil
    end
    local name = Utils.trim(entry.name or entry.model or "")
    if name == "" then
        return nil
    end
    local display = Utils.trim(entry.display or entry.title or entry.label or name)
    local cleaned = {
        name = name,
        display = display ~= "" and display or name,
        builtin = entry.builtin == true,
    }
    return cleaned
end

function Storage.sortModelList(list)
    table.sort(list, function(a, b)
        local ad = a.display or a.name or ""
        local bd = b.display or b.name or ""
        if (a.builtin and not b.builtin) then
            return true
        end
        if (b.builtin and not a.builtin) then
            return false
        end
        if ad == bd then
            return (a.name or "") < (b.name or "")
        end
        return ad < bd
    end)
end

function Storage.ensureOpenAIModelList(config)
    if type(config) ~= "table" then
        return
    end
    local models = {}
    local indexByName = {}

    local function append(entry, builtinFlag)
        local sanitized = Storage.sanitizeOpenAIModelEntry(entry)
        if not sanitized then
            return
        end
        if indexByName[sanitized.name] then
            return
        end
        sanitized.builtin = builtinFlag or sanitized.builtin == true
        table.insert(models, sanitized)
        indexByName[sanitized.name] = sanitized
    end

    for _, entry in ipairs(DEFAULT_OPENAI_MODELS or {}) do
        append(entry, true)
    end
    if type(config.customModels) == "table" then
        for _, entry in ipairs(config.customModels) do
            append(entry, false)
        end
    end
    if type(config.models) == "table" then
        for _, entry in ipairs(config.models) do
            append(entry, entry.builtin)
        end
    end

    Storage.sortModelList(models)
    config.models = models
    if type(config.selectedIndex) ~= "number" or config.selectedIndex < 1 or config.selectedIndex > #models then
        config.selectedIndex = (#models > 0) and 1 or nil
    end
end

function Storage.getOpenAISelectedModel(config)
    if type(config) ~= "table" then
        return nil
    end
    Storage.ensureOpenAIModelList(config)
    if type(config.selectedIndex) ~= "number" then
        return nil
    end
    return config.models and config.models[config.selectedIndex]
end

function Storage.serializeOpenAIConfig(config)
    if type(config) ~= "table" then
        return nil
    end
    Storage.ensureOpenAIModelList(config)
    local payload = {
        baseUrl = Utils.trim(config.baseUrl or ""),
        apiKey = config.apiKey or "",
        temperature = tonumber(config.temperature) or OPENAI_FORMAT_DEFAULT_TEMPERATURE,
        selectedIndex = config.selectedIndex or 1,
        systemPrompt = config.systemPrompt or OPENAI_DEFAULT_SYSTEM_PROMPT,
        models = {},
    }
    if type(config.models) == "table" then
        for _, entry in ipairs(config.models) do
            table.insert(payload.models, {
                name = entry.name,
                display = entry.display,
                builtin = entry.builtin == true,
            })
        end
    end
    if type(config.customModels) == "table" then
        payload.customModels = {}
        for _, entry in ipairs(config.customModels) do
            table.insert(payload.customModels, {
                name = entry.name,
                display = entry.display,
            })
        end
    end
    return payload
end

Storage.ensureOpenAIModelList(state.openaiFormat)


function UI.runWithLoading(action)
    if type(action) ~= "function" then
        return
    end
    if not (disp and ui) then
        return action()
    end

    local loadingWin = disp:AddWindow({
        ID = "LoadingWindow",
        WindowTitle = string.format("%s Loading", SCRIPT_NAME),
        Geometry = { LOADING_X, LOADING_Y, LOADING_WINDOW_WIDTH, LOADING_WINDOW_HEIGHT },
    }, ui:VGroup{
        ID = "LoadingRoot",
        Weight = 1,
        ui:Label{
            ID = "LoadingLabel",
            Weight = 1,
            Alignment = { AlignHCenter = true, AlignVCenter = true },
            WordWrap = true,
            Text = " loading...",
        },
    })

    if not loadingWin then
        return action()
    end

    local items = loadingWin:GetItems()
    local label = items and items.LoadingLabel

    if label then
        label.Text = UI.messageString("loading_started") or "loading..."
    end

    local previousLoadingLabel = state.loadingLabel
    if label then
        state.loadingLabel = label
    end

    loadingWin:Show()

    local ok, result = pcall(action)

    loadingWin:Hide()


    if loadingWin.DeleteLater then
        loadingWin:DeleteLater()
    end

    state.loadingLabel = previousLoadingLabel

    if not ok then
        error(result)
    end
    return result
end

configDir = Utils.joinPath(Utils.scriptDir(), "config")
Utils.ensureDir(configDir)
settingsFile = Utils.joinPath(configDir, "subedit_settings.json")
local storedSettings
local modelsFile = Utils.joinPath(configDir, "models.json")
local langCodeMapPath = Utils.joinPath(configDir, "lang_code_map.json")
local openAIModelStore = { builtin = {}, custom = {} }
Storage.settingsKeyOrder = {
    "TranslateProviderCombo",
    "TranslateTargetCombo",
    "TranslateConcurrencyCombo",
    "AzureRegion",
    "AzureApiKey",
    "DeepLApiKey",
    "OpenAIFormatModelCombo",
    "OpenAIFormatBaseURL",
    "OpenAIFormatApiKey",
    "OpenAIFormatTemperatureSpinBox",
    "SystemPromptTxt",
    "LangCnCheckBox",
    "LangEnCheckBox",
}





function Storage.refreshDefaultModelsFromStore()
    DEFAULT_OPENAI_MODELS = {}
    if type(openAIModelStore.builtin) ~= "table" then
        openAIModelStore.builtin = {}
    end
    for display, info in pairs(openAIModelStore.builtin) do
        table.insert(DEFAULT_OPENAI_MODELS, {
            display = display,
            name = (info and info.model) or display,
            builtin = true,
        })
    end
    Storage.sortModelList(DEFAULT_OPENAI_MODELS)
end

function Storage.rebuildCustomModelListFromStore()
    state.openaiFormat.customModels = {}
    for display, info in pairs(openAIModelStore.custom or {}) do
        table.insert(state.openaiFormat.customModels, {
            display = display,
            name = (info and info.model) or display,
            builtin = false,
        })
    end
    Storage.sortModelList(state.openaiFormat.customModels)
end

function Storage.saveSettings(path, values, keyorder)
    if not values then
        return
    end
    Utils.ensureDir(configDir)
    
    --  JSON 
    local content
    if type(keyorder) == "table" then
        content = json.encode(values, { keyorder = keyorder })
    else
        content = json.encode(values)
    end

    local okWrite, err = Utils.writeFile(path, content)
    if not okWrite then
        print(string.format(" %s: %s", tostring(path), tostring(err)))
    end
end

function Storage.saveOpenAIModelStore()
    Storage.saveSettings(modelsFile, {
        models = openAIModelStore.builtin or {},
        custom_models = openAIModelStore.custom or {},
    })
end

function Storage.loadSettings(path)
    local content = Utils.readFile(path)
    if not content then
        return nil
    end
    if not content or content == "" then
        return nil
    end
    
    --  pcall  JSON 
    local ok, settings_table = pcall(json.decode, content)
    
    -- 
    if not ok or type(settings_table) ~= "table" then
        print("JSON settings decode failed. Using default.")
        return nil
    end

    return settings_table
end

function Storage.loadLangCodeMaps(path)
    if not Utils.fileExists(path) then
        error(string.format("Language code map file missing: %s", tostring(path)))
    end
    local content = Utils.readFile(path)
    if not content or content == "" then
        error(string.format("Language code map file is empty: %s", tostring(path)))
    end
    local ok, data = pcall(json.decode, content)
    if not ok or type(data) ~= "table" then
        error(string.format("Language code map decode failed: %s", tostring(path)))
    end

    local providers = data.providers
    local labels = data.labels
    local popular = data.popular
    if type(providers) ~= "table" then
        error("Language code map 'providers' must be a table.")
    end
    if type(labels) ~= "table" then
        error("Language code map 'labels' must be a table.")
    end
    if type(popular) ~= "table" then
        error("Language code map 'popular' must be a table.")
    end

    for _, key in ipairs({ "google", "azure", "deepl" }) do
        if type(providers[key]) ~= "table" then
            error(string.format("Language code map 'providers.%s' must be a list.", key))
        end
        if type(popular[key]) ~= "table" then
            error(string.format("Language code map 'popular.%s' must be a list.", key))
        end
    end

    for _, langKey in ipairs({ "en", "cn" }) do
        if type(labels[langKey]) ~= "table" then
            error(string.format("Language code map 'labels.%s' must be a table.", langKey))
        end
        for _, key in ipairs({ "google", "azure", "deepl" }) do
            if type(labels[langKey][key]) ~= "table" then
                error(string.format("Language code map 'labels.%s.%s' must be a table.", langKey, key))
            end
        end
    end
    return data
end

LANG_CODE_MAPS = Storage.loadLangCodeMaps(langCodeMapPath)

function Storage.loadOpenAIModelStore()
    Utils.ensureDir(configDir)
    if not Utils.fileExists(modelsFile) then
        Storage.saveSettings(modelsFile, { models = {}, custom_models = {} })
    end
    local config = Storage.loadSettings(modelsFile)
    if type(config) ~= "table" then
        config = {}
    end
    openAIModelStore.builtin = config.models or openAIModelStore.builtin or {}
    openAIModelStore.custom = config.custom_models or openAIModelStore.custom or {}
    Storage.refreshDefaultModelsFromStore()
    Storage.rebuildCustomModelListFromStore()
    state.openaiFormat.models = Utils.deepCopy(DEFAULT_OPENAI_MODELS)
    Storage.ensureOpenAIModelList(state.openaiFormat)
end

Storage.loadOpenAIModelStore()

function Subtitle.nextSrtPathForTimeline(timeline)
    local tempDir = Utils.getTempDir()
    Utils.ensureDir(tempDir)

    local tlName = "timeline"
    if timeline and timeline.GetName then
        tlName = timeline:GetName() or tlName
    end
    --  UTF-8 
    local safeName = Utils.sanitizeFilename(tlName)
    local rand = state.sessionCode or "0000"

    local prefix = string.format("%s_subtitle_update_%s_", safeName, rand)
    local files = Utils.listFiles(tempDir)

    --  tempDir  .srt
    local maxN = 0
    local pat = "^" .. Utils.escapePlainPattern(prefix) .. "(%d+)%.srt$"
    for _, f in ipairs(files) do
        local n = f:match(pat)
        if n then
            n = tonumber(n) or 0
            if n > maxN then maxN = n end
        end
    end

    local nextIdx = maxN + 1
    local filename = string.format("%s%03d.srt", prefix, nextIdx)
    return Utils.joinPath(tempDir, filename)
end

function UI.currentLanguage()
    if state.language == "en" then
        return "en"
    end
    return "cn"
end

function UI.uiString(key)
    local lang = UI.currentLanguage()
    local pack = uiText[lang]
    if pack and pack[key] ~= nil then
        return pack[key]
    end
    pack = uiText.cn
    if pack and pack[key] ~= nil then
        return pack[key]
    end
    return ""
end

function UI.messageString(key)
    local bucket = messages[key]
    if not bucket then
        return nil
    end
    local lang = UI.currentLanguage()
    return bucket[lang] or bucket.cn
end



function UI.currentHeaders()
    local lang = UI.currentLanguage()
   local pack = uiText[lang]
   return (pack and pack.tree_headers) or uiText.cn.tree_headers
end

function UI.currentTranslateHeaders()
    local lang = UI.currentLanguage()
    local pack = uiText[lang]
    return (pack and pack.translate_tree_headers) or uiText.cn.translate_tree_headers
end

local function getLangMapKey(provider)
    local key = PROVIDER_LANG_MAP_KEYS[provider]
    if not key then
        error(string.format("Unsupported provider for language map: %s", tostring(provider)))
    end
    return key
end

local function getProviderCodes(provider)
    local key = getLangMapKey(provider)
    local codes = LANG_CODE_MAPS.providers and LANG_CODE_MAPS.providers[key]
    if type(codes) ~= "table" then
        error(string.format("Missing provider codes for: %s", tostring(key)))
    end
    return codes
end

local function getPopularCodes(provider)
    local key = getLangMapKey(provider)
    local codes = LANG_CODE_MAPS.popular and LANG_CODE_MAPS.popular[key]
    if type(codes) ~= "table" then
        error(string.format("Missing popular codes for: %s", tostring(key)))
    end
    return codes
end

local function getLabelMap(provider, lang)
    local key = getLangMapKey(provider)
    local labelMap = LANG_CODE_MAPS.labels and LANG_CODE_MAPS.labels[lang] and LANG_CODE_MAPS.labels[lang][key]
    if type(labelMap) ~= "table" then
        error(string.format("Missing labels for %s.%s", tostring(lang), tostring(key)))
    end
    return labelMap
end

local function buildOrderedTargetCodes(provider)
    local providerCodes = getProviderCodes(provider)
    local popularCodes = getPopularCodes(provider)
    local ordered = {}
    local seen = {}
    local providerSet = {}
    for _, code in ipairs(providerCodes) do
        providerSet[code] = true
    end
    for _, code in ipairs(popularCodes) do
        if providerSet[code] and not seen[code] then
            table.insert(ordered, code)
            seen[code] = true
        end
    end
    for _, code in ipairs(providerCodes) do
        if not seen[code] then
            table.insert(ordered, code)
            seen[code] = true
        end
    end
    return ordered
end

local function getTargetCodeFromIndex(provider, index)
    local codes = state.translate and state.translate.targetCodes
    if type(codes) ~= "table" or #codes == 0 then
        codes = buildOrderedTargetCodes(provider)
        if state.translate then
            state.translate.targetCodes = codes
        end
    end
    if type(index) ~= "number" or index < 0 or index >= #codes then
        return nil
    end
    return codes[index + 1]
end

function Translate.getLangOptions(provider)
    local useProvider = provider or (state.translate and state.translate.provider) or TRANSLATE_PROVIDER_AZURE_LABEL
    local langKey = UI.currentLanguage()
    local codes = buildOrderedTargetCodes(useProvider)
    local labelMap = getLabelMap(useProvider, langKey)
    local labels = {}
    for idx, code in ipairs(codes) do
        local label = labelMap[code]
        if not label then
            error(string.format("Missing label for %s: %s", tostring(useProvider), tostring(code)))
        end
        labels[idx] = label
    end
    return labels, codes, labelMap
end




    storedSettings = Storage.loadSettings(settingsFile)
if storedSettings then
    if storedSettings.LangEnCheckBox == true  then
        state.language = "en"
    elseif storedSettings.LangCnCheckBox == true  then
        state.language = "cn"
    end

    local provider = storedSettings.TranslateProviderCombo 
    if type(provider) == "string" and Translate.isSupportedProvider(provider) then
        state.translate.provider = provider
    end

    local targetLabel = storedSettings.TranslateTargetCombo 
    if type(targetLabel) == "string" and targetLabel ~= "" then
        state.translate.targetLabel = targetLabel
    end

    local concurrencyValue = tonumber(storedSettings.TranslateConcurrencyCombo)
    if concurrencyValue and concurrencyValue >= 1 then
        state.translate.concurrency = math.floor(concurrencyValue)
    end

    local azureKey = storedSettings.AzureApiKey
    if type(azureKey) == "string" and Utils.trim(azureKey) ~= "" then
        state.azure.apiKey = Utils.trim(azureKey)
    end

    local azureRegion = storedSettings.AzureRegion 
    if type(azureRegion) == "string" and Utils.trim(azureRegion) ~= "" then
        state.azure.region = Utils.trim(azureRegion)
    end

    local deeplKey = storedSettings.DeepLApiKey
    if type(deeplKey) == "string" and Utils.trim(deeplKey) ~= "" then
        state.deepl.apiKey = Utils.trim(deeplKey)
    end

    local baseUrl = storedSettings.OpenAIFormatBaseURL
    if type(baseUrl) == "string" then
        baseUrl = Utils.trim(baseUrl)
        if baseUrl ~= "" then
            state.openaiFormat.baseUrl = baseUrl
        end
    end

    local apiKey = storedSettings.OpenAIFormatApiKey
    if type(apiKey) == "string" and apiKey ~= "" then
        state.openaiFormat.apiKey = apiKey
    end

    local temperatureValue = tonumber(storedSettings.OpenAIFormatTemperatureSpinBox)
    if temperatureValue then
        state.openaiFormat.temperature = temperatureValue
    end

    local systemPrompt = storedSettings.SystemPromptTxt
    if type(systemPrompt) == "string" and Utils.trim(systemPrompt) ~= "" then
        state.openaiFormat.systemPrompt = systemPrompt 
    end

    local selectedDisplay = storedSettings.OpenAIFormatModelCombo
    if type(selectedDisplay) == "string" and selectedDisplay ~= "" then
        Storage.ensureOpenAIModelList(state.openaiFormat)
        local models = state.openaiFormat.models or {}
        for idx, entry in ipairs(models) do
            if entry.display == selectedDisplay or entry.name == selectedDisplay then
                state.openaiFormat.selectedIndex = idx
                break
            end
        end
    end

    local openaiStored = storedSettings.openai_format or storedSettings.openaiFormat
    if type(openaiStored) == "table" then
        if openaiStored.baseUrl or openaiStored.base_url then
            local legacyBase = Utils.trim(openaiStored.baseUrl or openaiStored.base_url or "")
            if legacyBase ~= "" then
                state.openaiFormat.baseUrl = legacyBase
            end
        end
        if openaiStored.apiKey or openaiStored.api_key then
            local legacyKey = openaiStored.apiKey or openaiStored.api_key
            if type(legacyKey) == "string" and legacyKey ~= "" then
                state.openaiFormat.apiKey = legacyKey
            end
        end
        if openaiStored.temperature or openaiStored.temp then
            local legacyTemp = tonumber(openaiStored.temperature or openaiStored.temp)
            if legacyTemp then
                state.openaiFormat.temperature = legacyTemp
            end
        end
        if openaiStored.systemPrompt and type(openaiStored.systemPrompt) == "string" and Utils.trim(openaiStored.systemPrompt) ~= "" then
            state.openaiFormat.systemPrompt = openaiStored.systemPrompt
        end
        if openaiStored.selectedIndex or openaiStored.selected_index then
            local legacyIndex = tonumber(openaiStored.selectedIndex or openaiStored.selected_index)
            if legacyIndex then
                state.openaiFormat.selectedIndex = legacyIndex
            end
        end
    end

    Storage.ensureOpenAIModelList(state.openaiFormat)
    Storage.saveOpenAIModelStore()
end
if not Translate.isSupportedProvider(state.translate.provider) then
    state.translate.provider = TRANSLATE_PROVIDER_AZURE_LABEL
end
Storage.ensureOpenAIModelList(state.openaiFormat)




-- ==============================================================
-- UI Layout: Main Window and Tabs (Edit / Translate / Config)
-- ==============================================================

local win = disp:AddWindow(
  {
    ID          = "SubtitleUtilityWin",
    WindowTitle = string.format("%s %s", SCRIPT_NAME, SCRIPT_VERSION),
    Geometry    = { X_CENTER, Y_CENTER, WINDOW_WIDTH, WINDOW_HEIGHT },
    StyleSheet  = "*{font-size:14px;}",
  },
  ui:VGroup{
    ID     = "root",
    Weight = 1,

    ui:TabBar{ ID = "MainTabs", Weight = 0 },

    ui:Stack{
      ID     = "MainStack",
      Weight = 1,

      ------------------------------------------------------------------
      -- Edit Tab
      ------------------------------------------------------------------
      ui:VGroup{
        ID     = "EditTab",
        Weight = 1,

        ui:VGap(10),

        ui:HGroup{
          Weight = 0,
          ui:LineEdit{ ID = "FindInput", PlaceholderText = UI.uiString("find_placeholder"), Weight = 1, Events = { TextChanged = true, EditingFinished = true } },
          ui:Button{ ID = "FindPreviousButton", Text = UI.uiString("find_previous_button"), Weight = 0 },
          ui:Button{ ID = "FindNextButton",     Text = UI.uiString("find_next_button"),     Weight = 0 },
          ui:LineEdit{ ID = "ReplaceInput", PlaceholderText = UI.uiString("replace_placeholder"), Weight = 1 },
          ui:Button{ ID = "AllReplaceButton",    Text = UI.uiString("all_replace_button"),    Weight = 0 },
          ui:Button{ ID = "SingleReplaceButton", Text = UI.uiString("single_replace_button"), Weight = 0 },
        },

        ui:Tree{
          ID                   = "SubtitleTree",
          AlternatingRowColors = true,
          WordWrap             = true,
          UniformRowHeights    = false,
          HorizontalScrollMode = true,
          FrameStyle           = 1,
          ColumnCount          = 3,
          SelectionMode        = "SingleSelection",
          Weight               = 1,
        },

        ui:TextEdit{ ID = "SubtitleEditor", Weight = 0, PlaceholderText = UI.uiString("editor_placeholder"), WordWrap = true },

        ui:HGroup{
          Weight = 0,
          ui:CheckBox{ ID = "AutoFollowCheck", Text = UI.uiString("auto_follow_check"), Checked = true, Weight = 0 },
        },

        ui:HGroup{
          Weight = 0,
          ui:Label{ ID = "StatusLabel", Text = "", Weight = 1, Alignment = { AlignHCenter = true, AlignVCenter = true } },
        },

        ui:HGroup{
          Weight = 0,
          ui:Label{
            ID         = "UpdateLabel",
            Text       = "",
            Weight     = 1,
            Alignment  = { AlignHCenter = true, AlignVCenter = true },
            WordWrap   = true,
            Visible    = false,
            StyleSheet = "color:#d9534f; font-weight:bold;",
          },
        },

        ui:HGroup{ Weight = 0.1, ui:Button{ ID = "RefreshButton",        Text = UI.uiString("refresh_button"), Weight = 1 }, ui:Button{ ID = "UpdateSubtitleButton", Text = UI.uiString("update_button"),  Weight = 1 } },

        ui:VGap(5),

        ui:Button{ ID = "DonationButton", Text = UI.uiString("donation"), Alignment = { AlignHCenter = true, AlignVCenter = true }, Font = ui.Font({ PixelSize = 12, StyleName = "Bold" }), Flat = true, TextColor = { 1, 1, 1, 1 }, BackgroundColor = { 1, 1, 1, 0 }, Weight = 0 },
      },

      ------------------------------------------------------------------
      -- Translate Tab
      ------------------------------------------------------------------
      ui:VGroup{
        ID     = "TranslateTab",
        Weight = 1,

        ui:VGap(10),

        ui:HGroup{
          Weight = 0,

          ui:Label{ ID = "TranslateProviderLabel", Text = UI.uiString("translate_provider_label"), Weight = 0, Alignment = { AlignVCenter = true } },
          ui:ComboBox{ ID = "TranslateProviderCombo", Weight = 1, Editable = false },

          ui:Label{ ID = "TranslateTargetLabel",   Text = UI.uiString("translate_target_label"),   Weight = 0, Alignment = { AlignVCenter = true } },
          ui:ComboBox{ ID = "TranslateTargetCombo", Weight = 1, Editable = false },

          ui:HGroup{
            Weight = 0,
            ui:Label{ ID = "TranslateConcurrencyLabel", Text = UI.uiString("concurrency_label"), Alignment = { AlignVCenter = true }, Weight = 1 },
            ui:ComboBox{ ID = "TranslateConcurrencyCombo", Weight = 0, Editable = false, Events = { CurrentIndexChanged = true } },
          },
        },

        ui:Tree{
          ID                   = "TranslateSubtitleTree",
          AlternatingRowColors = true,
          WordWrap             = true,
          UniformRowHeights    = false,
          HorizontalScrollMode = true,
          FrameStyle           = 1,
          ColumnCount          = 4,
          SelectionMode        = "SingleSelection",
          Weight               = 1,
        },

        ui:TextEdit{ ID = "TranslateSubtitleEditor", Weight = 0, PlaceholderText = UI.uiString("translate_editor_placeholder"), WordWrap = true },

        ui:HGroup{ Weight = 0, ui:Label{ ID = "TranslateStatusLabel", Text = "", Weight = 1, Alignment = { AlignHCenter = true, AlignVCenter = true }, WordWrap = true } },

        ui:HGroup{
          Weight = 0.1,
          ui:Button{ ID = "TranslateTransButton",          Text = UI.uiString("translate_trans_button"),        Weight = 1 },
          ui:Button{ ID = "TranslateRetryFailedButton",   Text = UI.uiString("translate_retry_failed_button"),  Weight = 1 },
          ui:Button{ ID = "TranslateSelectedButton",      Text = UI.uiString("translate_selected_button"),      Weight = 1 },
        },

        ui:HGroup{ Weight = 0.1, ui:Button{ ID = "TranslateUpdateSubtitleButton", Text = UI.uiString("translate_update_button"), Weight = 1 } },

        ui:VGap(5),
      },

      ------------------------------------------------------------------
      -- Config Tab
      ------------------------------------------------------------------
      ui:VGroup{
        ID     = "ConfigTab",
        Weight = 1,

        ui:VGap(20),

        ui:HGroup{ Weight = 0, ui:Label{ ID = "AzureConfigLabel",    Text = UI.uiString("azure_config_label"),    Alignment = { AlignVCenter = true }, Weight = 1 }, ui:Button{ ID = "AzureConfigButton",    Text = UI.uiString("azure_config_button"),    Weight = 0 } },
        ui:HGroup{ Weight = 0, ui:Label{ ID = "DeepLConfigLabel",    Text = UI.uiString("deepl_config_label"),    Alignment = { AlignVCenter = true }, Weight = 1 }, ui:Button{ ID = "DeepLConfigButton",    Text = UI.uiString("deepl_config_button"),    Weight = 0 } },
        ui:HGroup{ Weight = 0, ui:Label{ ID = "OpenAIFormatConfigLabel", Text = UI.uiString("openai_config_label"), Alignment = { AlignVCenter = true }, Weight = 1 }, ui:Button{ ID = "OpenAIFormatConfigButton", Text = UI.uiString("openai_config_button"), Weight = 0 } },

        ui:HGroup{ Weight = 0, ui:CheckBox{ ID = "LangCnCheckBox", Text = UI.uiString("lang_cn"), Checked = false, Weight = 0 }, ui:CheckBox{ ID = "LangEnCheckBox", Text = UI.uiString("lang_en"), Checked = true,  Weight = 0 } },

        ui:Button{ ID = "CopyrightButton", Text = UI.uiString("copyright"), Alignment = { AlignHCenter = true, AlignVCenter = true }, Font = ui.Font({ PixelSize = 12, StyleName = "Bold" }), Flat = true, TextColor = { 0.1, 0.3, 0.9, 1 }, BackgroundColor = { 1, 1, 1, 0 }, Weight = 0 },
      },
    },

  }
)

local azureConfigWin = disp:AddWindow(
  {
    ID = "AzureConfigWin",
    WindowTitle = UI.uiString("azure_config_window_title"),
    Geometry = { X_CENTER + 30, Y_CENTER + 30, 300, 150 },
    Hidden = true,
    StyleSheet = "*{font-size:14px;}",
  },
  ui:VGroup{
    ui:Label{ ID = "AzureLabel", Text = UI.uiString("azure_config_header"), Alignment = { AlignHCenter = true, AlignVCenter = true }, Weight = 0 },

    ui:HGroup{ Weight = 0, ui:Label{ ID = "AzureRegionLabel", Text = UI.uiString("azure_region_label"), Alignment = { AlignVCenter = true }, Weight = 0.3 }, ui:LineEdit{ ID = "AzureRegion", Text = state.azure.region or "", Weight = 0.7 } },

    ui:HGroup{ Weight = 0, ui:Label{ ID = "AzureApiKeyLabel", Text = UI.uiString("azure_api_key_label"), Alignment = { AlignVCenter = true }, Weight = 0.3 }, ui:LineEdit{ ID = "AzureApiKey", Text = state.azure.apiKey or "", EchoMode = "Password", Weight = 0.7 } },

    ui:HGroup{ Weight = 0, ui:Button{ ID = "AzureConfirm", Text = UI.uiString("azure_confirm_button"), Weight = 1 }, ui:Button{ ID = "AzureRegisterButton", Text = UI.uiString("azure_register_button"), Weight = 1 } },
  }
)

local deeplConfigWin = disp:AddWindow(
  {
    ID = "DeepLConfigWin",
    WindowTitle = UI.uiString("deepl_config_window_title"),
    Geometry = { X_CENTER + 35, Y_CENTER + 35, 300, 130 },
    Hidden = true,
    StyleSheet = "*{font-size:14px;}",
  },
  ui:VGroup{
    ui:Label{ ID = "DeepLLabel", Text = UI.uiString("deepl_config_header"), Alignment = { AlignHCenter = true, AlignVCenter = true }, Weight = 0 },

    ui:HGroup{ Weight = 0, ui:Label{ ID = "DeepLApiKeyLabel", Text = UI.uiString("deepl_api_key_label"), Alignment = { AlignVCenter = true }, Weight = 0.3 }, ui:LineEdit{ ID = "DeepLApiKey", Text = state.deepl.apiKey or "", EchoMode = "Password", Weight = 0.7 } },

    ui:HGroup{ Weight = 0, ui:Button{ ID = "DeepLConfirm", Text = UI.uiString("deepl_confirm_button"), Weight = 1 }, ui:Button{ ID = "DeepLRegisterButton", Text = UI.uiString("deepl_register_button"), Weight = 1 } },
  }
)

local openAIConfigWin = disp:AddWindow(
  {
    ID = "OpenAIFormatConfigWin",
    WindowTitle = UI.uiString("openai_config_window_title"),
    Geometry = { X_CENTER + 40, Y_CENTER + 40, 350, 450 },
    Hidden = true,
    StyleSheet = "*{font-size:14px;}",
  },
  ui:VGroup{
    ui:Label{ ID = "OpenAIFormatLabel", Text = UI.uiString("openai_config_header"), Alignment = { AlignHCenter = true, AlignVCenter = true }, Weight = 0 },

    ui:Label{ ID = "OpenAIFormatModelLabel", Text = UI.uiString("openai_model_label"), Weight = 0 },

    ui:HGroup{
      Weight = 0,
      ui:ComboBox{ ID = "OpenAIFormatModelCombo", Weight = 0.6, Editable = false, Events = { CurrentIndexChanged = true } },
      ui:LineEdit{ ID = "OpenAIFormatModelName", ReadOnly = true, Weight = 0.4 },
    },

    ui:Label{ ID = "OpenAIFormatBaseURLLabel", Text = UI.uiString("openai_base_url_label"), Weight = 0 },
    ui:LineEdit{ ID = "OpenAIFormatBaseURL", Text = "", PlaceholderText = OPENAI_FORMAT_DEFAULT_BASE_URL, Weight = 0 },

    ui:Label{ ID = "OpenAIFormatApiKeyLabel", Text = UI.uiString("openai_api_key_label"), Weight = 0 },
    ui:LineEdit{ ID = "OpenAIFormatApiKey", Text = state.openaiFormat.apiKey or "", EchoMode = "Password", Weight = 0 },

    ui:HGroup{ Weight = 0, ui:Label{ ID = "OpenAIFormatTemperatureLabel", Text = UI.uiString("openai_temperature_label"), Weight = 1 }, ui:DoubleSpinBox{ ID = "OpenAIFormatTemperatureSpinBox", Minimum = 0.0, Maximum = 1.0, SingleStep = 0.01, Value = state.openaiFormat.temperature or OPENAI_FORMAT_DEFAULT_TEMPERATURE, Weight = 0 } },

    ui:Label{ ID = "SystemPromptLabel", Text = UI.uiString("system_prompt_label"), Weight = 0 },
    ui:TextEdit{ ID = "SystemPromptTxt", Text = state.openaiFormat.systemPrompt or OPENAI_DEFAULT_SYSTEM_PROMPT, Weight = 1 },

    ui:HGroup{ Weight = 0, ui:Button{ ID = "VerifyModel", Text = UI.uiString("openai_verify_button"), Weight = 1 }, ui:Button{ ID = "ShowAddModel", Text = UI.uiString("openai_add_button"), Weight = 1 }, ui:Button{ ID = "DeleteModel", Text = UI.uiString("openai_delete_button"), Weight = 1 } },
  }
)

local addModelWin = disp:AddWindow(
  {
    ID = "AddModelWin",
    WindowTitle = "Add OpenAI Format Model",
    Geometry = { X_CENTER + 60, Y_CENTER + 60, 300, 200 },
    Hidden = true,
    StyleSheet = "*{font-size:14px;}",
  },
  ui:VGroup{
    ui:Label{ ID = "AddModelTitle",           Text = "Add OpenAI Format Model", Alignment = { AlignHCenter = true, AlignVCenter = true }, Weight = 0 },
    ui:Label{ ID = "NewModelDisplayLabel",    Text = "Display name", Weight = 0 },
    ui:LineEdit{ ID = "addOpenAIFormatModelDisplay", Weight = 0 },
    ui:Label{ ID = "OpenAIFormatModelNameLabel", Text = "Model name", Weight = 0 },
    ui:LineEdit{ ID = "addOpenAIFormatModelName", Weight = 0 },
    ui:HGroup{ Weight = 0, ui:Button{ ID = "AddModelBtn", Text = "Add", Weight = 1 } },
  }
)

local messageWin = disp:AddWindow(
  {
    ID = "MessageBoxWin",
    WindowTitle = "Info",
    Geometry = { X_CENTER + 60, Y_CENTER + 80, 360, 160 },
    Hidden = true,
    StyleSheet = "*{font-size:14px;}",
  },
  ui:VGroup{
    ID     = "MessageBoxLayout",
    Weight = 1,

    ui:Label{ ID = "MessageLabel", Weight = 1, WordWrap = true, Alignment = { AlignHCenter = true, AlignVCenter = true }, Text = "" },

    ui:HGroup{ Weight = 0, ui:Button{ ID = "MessageBoxOk", Text = "OK", Weight = 1, MinimumSize = { 80, 28 } } },
  }
)


local it = win:GetItems()
local azureConfigItems = azureConfigWin:GetItems() or {}
local deeplConfigItems = deeplConfigWin:GetItems() or {}
local openAIConfigItems = openAIConfigWin:GetItems() or {}
local addModelItems = addModelWin:GetItems() or {}
local messageItems = messageWin:GetItems() or {}

local function findConcurrencyOptionIndexByValue(value)
    local numeric = tonumber(value) or DEFAULT_TRANSLATE_CONCURRENCY
    local bestIndex = 1
    local bestDiff = math.huge
    for idx, option in ipairs(TRANSLATE_CONCURRENCY_OPTIONS) do
        if option.value == numeric then
            return idx, option.value
        end
        local diff = math.abs(option.value - numeric)
        if diff < bestDiff then
            bestDiff = diff
            bestIndex = idx
        end
    end
    local matched = TRANSLATE_CONCURRENCY_OPTIONS[bestIndex] and TRANSLATE_CONCURRENCY_OPTIONS[bestIndex].value or DEFAULT_TRANSLATE_CONCURRENCY
    return bestIndex, matched
end

local function setConcurrencyComboSelection(value)
    if not it.TranslateConcurrencyCombo then
        return
    end
    local idx, matchedValue = findConcurrencyOptionIndexByValue(value)
    it.TranslateConcurrencyCombo.CurrentIndex = (idx or 1) - 1
    if matchedValue and state.translate.concurrency ~= matchedValue then
        state.translate.concurrency = matchedValue
    end
end

local function populateConcurrencyCombo(value)
    if not it.TranslateConcurrencyCombo then
        return
    end
    local combo = it.TranslateConcurrencyCombo
    combo:Clear()
    for _, option in ipairs(TRANSLATE_CONCURRENCY_OPTIONS) do
        combo:AddItem(UI.uiString(option.labelKey))
    end
    setConcurrencyComboSelection(value)
end

populateConcurrencyCombo(state.translate.concurrency or DEFAULT_TRANSLATE_CONCURRENCY)

local playheadTimer = ui:Timer{
    ID = "PlayheadTimer",
    Interval = 100,
    SingleShot = false,
    TimerType = "CoarseTimer",
}
state.playheadTimer = playheadTimer


local function getCurrentTimelineFrame()
    local timeline = state.timeline
    if not timeline then
        return nil
    end
    if timeline.GetCurrentFrame then
        local ok, frame = pcall(function()
            return timeline:GetCurrentFrame()
        end)
        if ok and type(frame) == "number" then
            return math.floor(frame + 0.5)
        end
    end
    if timeline.GetCurrentTimecode then
        local ok, tc = pcall(function()
            return timeline:GetCurrentTimecode()
        end)
        if ok and tc and tc ~= "" then
            return Subtitle.timecodeToFrames(tc, state.fps_frac or state.fps or { num = 24, den = 1 })
        end
    end
    return nil
end

-- / [start, end) 
local function findEntryIndexByFrame(absFrame)
    local entries = state.entries or {}
    local total = #entries
    if total == 0 then return nil end

    --  /   start >= absFrame
    local lo, hi = 1, total
    local insertPos = total + 1
    while lo <= hi do
        local mid = math.floor((lo + hi) / 2)
        local s = entries[mid] and entries[mid].startFrame or 0
        if s >= absFrame then
            insertPos = mid
            hi = mid - 1
        else
            lo = mid + 1
        end
    end

    --   [start, end)
    local prevIndex = insertPos - 1
    if prevIndex >= 1 then
        local e = entries[prevIndex]
        if e then
            local s = e.startFrame or 0
            local t = e.endFrame   or s
            if t <= s then t = s + 1 end  -- 
            if absFrame >= s and absFrame < t then
                return prevIndex
            end
        end
    end

    --   
    if insertPos >= 1 and insertPos <= total then
        return insertPos
    end
    return total
end


function UI.followPlayheadTick()
    if not state.autoFollow then
        return
    end
    if state.suppressTreeSelection then
        return
    end
    local entries = state.entries
    if not entries or #entries == 0 then
        return
    end
    local frame = getCurrentTimelineFrame()
    if not frame then
        return
    end
    if state.manualJumpFrame and state.manualJumpAt then
        local elapsed = os.clock() - state.manualJumpAt
        if math.abs(frame - state.manualJumpFrame) <= 1 and elapsed < 0.25 then
            return
        elseif elapsed >= 0.25 then
            state.manualJumpFrame = nil
            state.manualJumpAt = nil
        end
    end
    local index = findEntryIndexByFrame(frame)
    if not index then
        state.lastFollowIndex = nil
        return
    end
    if state.manualJumpFrame and (math.abs(frame - state.manualJumpFrame) > 1 or index ~= state.lastFollowIndex) then
        state.manualJumpFrame = nil
        state.manualJumpAt = nil
    end
    if state.lastFollowIndex == index then
        return
    end
    if not it.SubtitleTree then
        return
    end
    UI.jumpToEntry(index, false, { includeTranslate = true, jumpTimeline = false })
end

local function updatePlayheadTimerState(triggerTick)
    if not playheadTimer then
        return
    end
    local isActive = false
    if playheadTimer.GetIsActive then
        local ok, active = pcall(function()
            return playheadTimer:GetIsActive()
        end)
        isActive = ok and active or false
    end
    if state.autoFollow then
        if not isActive then
            pcall(function() playheadTimer:Start() end)
        end
        if triggerTick then
            UI.followPlayheadTick()
        end
    elseif isActive then
        pcall(function() playheadTimer:Stop() end)
    end
end

if it.AutoFollowCheck then
    it.AutoFollowCheck.Checked = state.autoFollow and true or false
    function win.On.AutoFollowCheck.Clicked(ev)
        state.autoFollow = it.AutoFollowCheck.Checked == true
        state.lastFollowIndex = nil
        state.manualJumpFrame = nil
        state.manualJumpAt = nil
        updatePlayheadTimerState(true)
    end
end

local previousTimeoutHandler = disp.On.Timeout
function disp.On.Timeout(ev)
    local handled
    if previousTimeoutHandler then
        handled = previousTimeoutHandler(ev)
    end
    local who = ev and (ev.who or ev.ID or ev.Name or ev.TimerID or ev.TimerId)
    if who == "PlayheadTimer" then
        if state.autoFollow then
            UI.followPlayheadTick()
        end
        return true
    end
    return handled
end

updatePlayheadTimerState(true)


function Azure.refreshConfigTexts()
    if not azureConfigItems then
        return
    end
    if azureConfigWin then
        azureConfigWin.WindowTitle = UI.uiString("azure_config_window_title")
    end
    local textMap = {
        AzureLabel = "azure_config_header",
        AzureRegionLabel = "azure_region_label",
        AzureApiKeyLabel = "azure_api_key_label",
        AzureConfirm = "azure_confirm_button",
        AzureRegisterButton = "azure_register_button",
    }
    for id, key in pairs(textMap) do
        local widget = azureConfigItems[id]
        if widget and widget.Text ~= nil then
            widget.Text = UI.uiString(key)
        end
    end
    
end

function Azure.syncConfigControls()
    if not azureConfigItems then
        return
    end
    if azureConfigItems.AzureRegion then
        azureConfigItems.AzureRegion.Text = state.azure.region or ""
    end
    if azureConfigItems.AzureApiKey then
        azureConfigItems.AzureApiKey.Text = state.azure.apiKey or ""
    end
end

function Azure.applyConfigFromControls()
    if not azureConfigItems then
        return
    end
    if azureConfigItems.AzureRegion then
        state.azure.region = Utils.trim(azureConfigItems.AzureRegion.Text or "")
    end
    if azureConfigItems.AzureApiKey then
        state.azure.apiKey = Utils.trim(azureConfigItems.AzureApiKey.Text or "")
    end
end

function Azure.openConfigWindow()
    if not azureConfigWin then
        return
    end
    Azure.refreshConfigTexts()
    Azure.syncConfigControls()
    azureConfigWin:Show()
end

function Azure.closeConfigWindow()
    if not azureConfigWin then
        return
    end
    Azure.applyConfigFromControls()
    azureConfigWin:Hide()
end

function DeepL.refreshConfigTexts()
    if not deeplConfigItems then
        return
    end
    if deeplConfigWin then
        deeplConfigWin.WindowTitle = UI.uiString("deepl_config_window_title")
    end
    local textMap = {
        DeepLLabel = "deepl_config_header",
        DeepLApiKeyLabel = "deepl_api_key_label",
        DeepLConfirm = "deepl_confirm_button",
        DeepLRegisterButton = "deepl_register_button",
    }
    for id, key in pairs(textMap) do
        local widget = deeplConfigItems[id]
        if widget and widget.Text ~= nil then
            widget.Text = UI.uiString(key)
        end
    end
end

function DeepL.syncConfigControls()
    if not deeplConfigItems then
        return
    end
    if deeplConfigItems.DeepLApiKey then
        deeplConfigItems.DeepLApiKey.Text = state.deepl.apiKey or ""
    end
end

function DeepL.applyConfigFromControls()
    if not deeplConfigItems then
        return
    end
    if deeplConfigItems.DeepLApiKey then
        state.deepl.apiKey = Utils.trim(deeplConfigItems.DeepLApiKey.Text or "")
    end
end

function DeepL.openConfigWindow()
    if not deeplConfigWin then
        return
    end
    DeepL.refreshConfigTexts()
    DeepL.syncConfigControls()
    deeplConfigWin:Show()
end

function DeepL.closeConfigWindow()
    if not deeplConfigWin then
        return
    end
    DeepL.applyConfigFromControls()
    deeplConfigWin:Hide()
end


local function hide_dynamic_message()
    if not messageWin then
        return
    end
    messageWin:Hide()
end

local function show_dynamic_message(en_text, zh_text)
    if not messageWin or not messageItems then
        return
    end
    local lang = UI.currentLanguage()
    local display = en_text or ""
    if lang == "cn" then
        display = zh_text or en_text or ""
    end
    if display == "" then
        display = en_text or zh_text or ""
    end
    if messageItems.MessageLabel then
        messageItems.MessageLabel.Text = display or ""
    end
    if messageItems.MessageBoxOk then
        messageItems.MessageBoxOk.Text = UI.uiString("azure_confirm_button")
    end
    messageWin:Show()
end

if messageWin then
    function messageWin.On.MessageBoxWin.Close(ev)
        hide_dynamic_message()
    end
    function messageWin.On.MessageBoxOk.Clicked(ev)
        hide_dynamic_message()
    end
end

function UI.withUpdatesSuspended(widget, fn)
    if not widget or type(fn) ~= "function" then
        return
    end
    local canSuspend = type(widget.SetUpdatesEnabled) == "function"
    if not canSuspend then
        fn()
        return
    end
    widget:SetUpdatesEnabled(false)
    local ok, err = pcall(fn)
    widget:SetUpdatesEnabled(true)
    if not ok then
        error(err)
    end
end

-- Programmatic update guards for editor/translate text widgets
function UI.withEditorProgrammatic(fn)
    if type(fn) ~= "function" then return end
    editorProgrammatic = true
    local ok, err = pcall(fn)
    editorProgrammatic = false
    if not ok then error(err) end
end

function UI.withTranslateProgrammatic(fn)
    if type(fn) ~= "function" then return end
    translateEditorProgrammatic = true
    local ok, err = pcall(fn)
    translateEditorProgrammatic = false
    if not ok then error(err) end
end


function OpenAIService.refreshConfigTexts()
    if not openAIConfigItems then
        return
    end
    if openAIConfigWin then
        openAIConfigWin.WindowTitle = UI.uiString("openai_config_window_title")
    end
    local textMap = {
        OpenAIFormatLabel = "openai_config_header",
        OpenAIFormatModelLabel = "openai_model_label",
        OpenAIFormatBaseURLLabel = "openai_base_url_label",
        OpenAIFormatApiKeyLabel = "openai_api_key_label",
        OpenAIFormatTemperatureLabel = "openai_temperature_label",
        SystemPromptLabel = "system_prompt_label",
        VerifyModel = "openai_verify_button",
        ShowAddModel = "openai_add_button",
        DeleteModel = "openai_delete_button",
    }
    for id, key in pairs(textMap) do
        local widget = openAIConfigItems[id]
        if widget and widget.Text ~= nil then
            widget.Text = UI.uiString(key)
        end
    end
    if addModelItems then
        local addTextMap = {
            AddModelTitle = "openai_add_model_title",
            NewModelDisplayLabel = "openai_new_model_display_label",
            OpenAIFormatModelNameLabel = "openai_new_model_name_label",
            AddModelBtn = "openai_add_button",
        }
        for id, key in pairs(addTextMap) do
            local widget = addModelItems[id]
            if widget and widget.Text ~= nil then
                widget.Text = UI.uiString(key)
            end
        end
    end
    if it.OpenAIFormatConfigLabel then
        it.OpenAIFormatConfigLabel.Text = UI.uiString("openai_config_label")
    end
    if it.OpenAIFormatConfigButton then
        it.OpenAIFormatConfigButton.Text = UI.uiString("openai_config_button")
    end
    if it.TranslateConcurrencyLabel then
        it.TranslateConcurrencyLabel.Text = UI.uiString("concurrency_label")
    end
    populateConcurrencyCombo(state.translate.concurrency or DEFAULT_TRANSLATE_CONCURRENCY)
    if openAIConfigItems.OpenAIFormatBaseURL then
        openAIConfigItems.OpenAIFormatBaseURL.PlaceholderText = OPENAI_FORMAT_DEFAULT_BASE_URL
    end
end

function OpenAIService.populateOpenAIModelCombo()
    if not openAIConfigItems or not openAIConfigItems.OpenAIFormatModelCombo then
        return
    end
    Storage.ensureOpenAIModelList(state.openaiFormat)
    local combo = openAIConfigItems.OpenAIFormatModelCombo
    combo:Clear()
    local models = state.openaiFormat.models or {}
    for _, entry in ipairs(models) do
        combo:AddItem(entry.display or entry.name or "")
    end
    if #models > 0 then
        local idx = state.openaiFormat.selectedIndex or 1
        idx = math.max(1, math.min(idx, #models))
        state.openaiFormat.selectedIndex = idx
        combo.CurrentIndex = idx - 1
        if openAIConfigItems.OpenAIFormatModelName then
            openAIConfigItems.OpenAIFormatModelName.Text = models[idx].name or ""
        end
    else
        combo.CurrentIndex = -1
        if openAIConfigItems.OpenAIFormatModelName then
            openAIConfigItems.OpenAIFormatModelName.Text = ""
        end
    end
end

function OpenAIService.applyConfigFromControls()
    if not openAIConfigItems then
        return
    end
    if openAIConfigItems.OpenAIFormatBaseURL then
        local baseUrl = Utils.trim(openAIConfigItems.OpenAIFormatBaseURL.Text or "")

        state.openaiFormat.baseUrl = baseUrl
    end
    if openAIConfigItems.OpenAIFormatApiKey then
        state.openaiFormat.apiKey = Utils.trim(openAIConfigItems.OpenAIFormatApiKey.Text or "")
    end
    if openAIConfigItems.OpenAIFormatTemperatureSpinBox then
        local value = tonumber(openAIConfigItems.OpenAIFormatTemperatureSpinBox.Value)
        if value then
            if value < 0 then value = 0 end
            if value > 1 then value = 1 end
            state.openaiFormat.temperature = value
        end
    end
    if openAIConfigItems.SystemPromptTxt then
        local promptText = openAIConfigItems.SystemPromptTxt.PlainText or openAIConfigItems.SystemPromptTxt.Text or ""
        promptText = Utils.trim(promptText)
        if promptText == "" then
            promptText = OPENAI_DEFAULT_SYSTEM_PROMPT
        end
        state.openaiFormat.systemPrompt = promptText
    end
    if openAIConfigItems.OpenAIFormatModelCombo then
        local idx = openAIConfigItems.OpenAIFormatModelCombo.CurrentIndex
        if type(idx) == "number" and idx >= 0 then
            state.openaiFormat.selectedIndex = idx + 1
        end
    end
    Storage.ensureOpenAIModelList(state.openaiFormat)
end

function OpenAIService.syncOpenAIConfigControls()
    Storage.ensureOpenAIModelList(state.openaiFormat)
    if openAIConfigItems.OpenAIFormatBaseURL then
        local currentBase = Utils.trim(state.openaiFormat.baseUrl or "")
        if currentBase ~= "" and currentBase ~= OPENAI_FORMAT_DEFAULT_BASE_URL then
            openAIConfigItems.OpenAIFormatBaseURL.Text = currentBase
        else
            openAIConfigItems.OpenAIFormatBaseURL.Text = ""
        end
    end
    if openAIConfigItems.OpenAIFormatApiKey then
        openAIConfigItems.OpenAIFormatApiKey.Text = state.openaiFormat.apiKey or ""
    end
    if openAIConfigItems.OpenAIFormatTemperatureSpinBox then
        openAIConfigItems.OpenAIFormatTemperatureSpinBox.Value = state.openaiFormat.temperature or OPENAI_FORMAT_DEFAULT_TEMPERATURE
    end
    if openAIConfigItems.SystemPromptTxt then
        local prompt = state.openaiFormat.systemPrompt or OPENAI_DEFAULT_SYSTEM_PROMPT
        openAIConfigItems.SystemPromptTxt.PlainText = prompt
        openAIConfigItems.SystemPromptTxt.Text = prompt
    end
    OpenAIService.populateOpenAIModelCombo()
end

function OpenAIService.openConfigWindow()
    if not openAIConfigWin then
        return
    end
    OpenAIService.refreshConfigTexts()
    OpenAIService.syncOpenAIConfigControls()
    if addModelItems.addOpenAIFormatModelDisplay then
        addModelItems.addOpenAIFormatModelDisplay.Text = ""
    end
    if addModelItems.addOpenAIFormatModelName then
        addModelItems.addOpenAIFormatModelName.Text = ""
    end
    if addModelWin then
        addModelWin:Hide()
    end
    openAIConfigWin:Show()
end

function OpenAIService.closeConfigWindow()
    if not openAIConfigWin then
        return
    end
    OpenAIService.applyConfigFromControls()
    openAIConfigWin:Hide()
    if addModelWin then
        addModelWin:Hide()
    end
end

function OpenAIService.verifyModel(baseUrl, apiKey, model)
    local cleanBase = Utils.trim(baseUrl or "")
    if cleanBase == "" then
        cleanBase = OPENAI_FORMAT_DEFAULT_BASE_URL
    end
    local normalizedBase = cleanBase:gsub("/*$", "")
    local url = normalizedBase .. "/v1/chat/completions"
    local payload = json.encode({
        model = model,
        messages = {
            { role = "system", content = "You are a health check assistant." },
            { role = "user", content = "Reply with OK." },
        },
        temperature = 0,
        max_tokens = 5,
    })
    local headers = {
        Authorization = "Bearer " .. apiKey,
        ["Content-Type"] = "application/json",
        ["User-Agent"] = string.format("%s/%s", SCRIPT_NAME, SCRIPT_VERSION),
    }
    local body, status = Services.httpPostJson(url, payload, headers, OPENAI_FORMAT_TIMEOUT)
    if not body then
        return false, status or "request_failed"
    end

    local code = tonumber(status)
    local ok, decoded = pcall(json.decode, body)
    if ok and type(decoded) == "table" then
        if decoded.error and decoded.error.message then
            return false, decoded.error.message
        end
        local choices = decoded.choices
        if choices and type(choices) == "table" and choices[1] and choices[1].message then
            return true, tostring(code or "200")
        end
    end

    if code and code >= 200 and code < 300 then
        return true, tostring(code)
    end
    return false, tostring(status or "error")
end

-- ==============================================================
-- Translate Tab: Controller & Helpers
-- ==============================================================

local function formatTranslateStatusForLang(key, args, lang)
    local template = translateStatusTemplates[key]
    if not template then
        return ""
    end
    local text = template[lang] or template.cn or ""
    if text == "" then
        return text
    end
    if args and #args > 0 then
        local ok, formatted = pcall(string.format, text, table.unpack(args))
        if ok then
            return formatted
        end
    end
    return text
end

local function formatTranslateStatus(key, args)
    return formatTranslateStatusForLang(key, args, UI.currentLanguage())
end

local function notifyTranslateStatus(key, argsEn, argsCn)
    argsEn = argsEn or {}
    argsCn = argsCn or argsEn
    local enText = formatTranslateStatusForLang(key, argsEn, "en")
    local cnText = formatTranslateStatusForLang(key, argsCn, "cn")
    if enText == "" and cnText == "" then
        return
    end
    local finalEn = enText ~= "" and enText or cnText
    local finalCn = cnText ~= "" and cnText or enText
    show_dynamic_message(finalEn, finalCn)
end

local function applyTranslateStatusInternal(key, args)
    if it.TranslateStatusLabel then
        it.TranslateStatusLabel.Text = formatTranslateStatus(key, args)
    end
end

local function setTranslateStatus(key, ...)
    local args = { ... }
    local tState = state.translate
    if tState then
        tState.lastStatusKey = key
        tState.lastStatusArgs = args
    end
    applyTranslateStatusInternal(key, args)
end

local function computeTranslateSummary(entries)
    local dataset = entries
    if dataset == nil then
        dataset = state.translate and state.translate.entries or {}
    end

    local failedMap = (state.translate and state.translate.failed) or {}
    local total, failed = 0, 0

    if type(dataset) == "table" then
        for _, item in ipairs(dataset) do
            if item then
                total = total + 1
                local idx
                if type(item) == "table" then
                    idx = item.index or item.idx or item.rowIndex or item.originalIndex or item.id
                elseif type(item) == "number" then
                    idx = item
                end
                if idx and failedMap[idx] then
                    failed = failed + 1
                end
            end
        end
    end

    local success = total - failed
    if success < 0 then
        success = 0
    end
    return total, success, failed
end

local function applyTranslateSuccessStatus(entries, tokenCount, shouldNotify)
    local total, success, failed = computeTranslateSummary(entries)
    local tokens = tokenCount or 0
    setTranslateStatus("success", total, success, failed, tokens)
    if shouldNotify then
        notifyTranslateStatus("success", { total, success, failed, tokens }, { total, success, failed, tokens })
    end
    return total, success, failed
end

local function resolveTranslateErrorForLang(code, lang)
    if code == nil or code == "" then
        return ""
    end
    local bucket = translateErrorMessages[code]
    if bucket then
        if lang == "en" then
            return bucket.en or bucket.cn or tostring(code)
        end
        return bucket.cn or bucket.en or tostring(code)
    end
    if type(code) == "string" then
        return code
    end
    return tostring(code)
end

local function resolveTranslateError(code)
    return resolveTranslateErrorForLang(code, UI.currentLanguage())
end

local function resolveTranslateErrorPair(code)
    local enText = resolveTranslateErrorForLang(code, "en")
    local cnText = resolveTranslateErrorForLang(code, "cn")
    return enText, cnText
end

local function notifyTranslateFailure(reason)
    if reason == nil then
        notifyTranslateStatus("failed", { "" }, { "" })
        return
    end
    if type(reason) == "table" then
        local enReason = reason.en or reason[1] or ""
        local cnReason = reason.cn or reason[2] or enReason
        notifyTranslateStatus("failed", { enReason }, { cnReason })
        return
    end
    local enReason, cnReason = resolveTranslateErrorPair(reason)
    notifyTranslateStatus("failed", { enReason }, { cnReason })
end

local function handleOpenAIVerify()
    if not openAIConfigItems then
        return
    end
    OpenAIService.applyConfigFromControls()
    Storage.ensureOpenAIModelList(state.openaiFormat)
    local selected = Storage.getOpenAISelectedModel(state.openaiFormat)
    if not selected then
        setTranslateStatus("failed", resolveTranslateError("openai_missing_model"))
        local enText, cnText = resolveTranslateErrorPair("openai_missing_model")
        show_dynamic_message(enText, cnText)
        return
    end
    local baseUrl = Utils.trim(state.openaiFormat.baseUrl or "")
    if baseUrl == "" then
        baseUrl = OPENAI_FORMAT_DEFAULT_BASE_URL
    end
    local apiKey = Utils.trim(state.openaiFormat.apiKey or "")
    if apiKey == "" then
        setTranslateStatus("failed", resolveTranslateError("openai_missing_key"))
        local enText, cnText = resolveTranslateErrorPair("openai_missing_key")
        show_dynamic_message(enText, cnText)
        return
    end
    local ok, message = OpenAIService.verifyModel(baseUrl, apiKey, selected.name)
    if ok then
        local enMsg = uiText.en.openai_verify_success or "Model verified successfully"
        local cnMsg = uiText.cn.openai_verify_success or enMsg
        show_dynamic_message(enMsg, cnMsg)
        print(string.format("[OpenAI] Verify success: %s (%s)", selected.name, tostring(message or "")))
    else
        local templateEn = uiText.en.openai_verify_failed or "Model verification failed: %s"
        local templateCn = uiText.cn.openai_verify_failed or templateEn
        local errMsgEn = string.format(templateEn, tostring(message or ""))
        local errMsgCn = string.format(templateCn, tostring(message or ""))
        local statusText = UI.currentLanguage() == "cn" and errMsgCn or errMsgEn
        setTranslateStatus("failed", statusText)
        show_dynamic_message(errMsgEn, errMsgCn)
        print(string.format("[OpenAI] Verify failed: %s", errMsgEn))
    end
end

local function handleOpenAIAddModel()
    if not addModelItems then
        return
    end
    local displayInput = Utils.trim((addModelItems.addOpenAIFormatModelDisplay and addModelItems.addOpenAIFormatModelDisplay.Text) or "")
    local modelInput = Utils.trim((addModelItems.addOpenAIFormatModelName and addModelItems.addOpenAIFormatModelName.Text) or "")
    if modelInput == "" then
        setTranslateStatus("failed", UI.uiString("openai_missing_fields"))
        return
    end
    if displayInput == "" then
        displayInput = modelInput
    end
    if openAIModelStore.builtin and openAIModelStore.builtin[displayInput] then
        setTranslateStatus("failed", UI.uiString("openai_add_duplicate"))
        return
    end
    Storage.ensureOpenAIModelList(state.openaiFormat)
    for _, entry in ipairs(state.openaiFormat.models or {}) do
        if entry.name == modelInput and entry.builtin then
            setTranslateStatus("failed", UI.uiString("openai_add_duplicate"))
            return
        end
    end
    for disp, info in pairs(openAIModelStore.custom or {}) do
        if info and info.model == modelInput then
            openAIModelStore.custom[disp] = nil
        end
    end
    openAIModelStore.custom = openAIModelStore.custom or {}
    openAIModelStore.custom[displayInput] = { model = modelInput }
    Storage.rebuildCustomModelListFromStore()
    state.openaiFormat.models = Utils.deepCopy(DEFAULT_OPENAI_MODELS)
    Storage.ensureOpenAIModelList(state.openaiFormat)
    state.openaiFormat.selectedIndex = nil
    for idx, entry in ipairs(state.openaiFormat.models or {}) do
        if entry.name == modelInput then
            state.openaiFormat.selectedIndex = idx
            break
        end
    end
    if not state.openaiFormat.selectedIndex then
        state.openaiFormat.selectedIndex = (#state.openaiFormat.models > 0) and 1 or nil
    end
    Storage.saveOpenAIModelStore()
    OpenAIService.populateOpenAIModelCombo()
    if addModelItems.addOpenAIFormatModelDisplay then
        addModelItems.addOpenAIFormatModelDisplay.Text = ""
    end
    if addModelItems.addOpenAIFormatModelName then
        addModelItems.addOpenAIFormatModelName.Text = ""
    end
    if addModelWin then
        addModelWin:Hide()
    end
    if openAIConfigWin then
        openAIConfigWin:Show()
    end
    OpenAIService.syncOpenAIConfigControls()
    print(string.format("[OpenAI] Model added: %s (%s)", displayInput, modelInput))
end

local function handleOpenAIDeleteModel()
    OpenAIService.applyConfigFromControls()
    Storage.ensureOpenAIModelList(state.openaiFormat)
    local models = state.openaiFormat.models or {}
    if #models == 0 then
        local en = (uiText.en.openai_missing_model or "Select a valid OpenAI model.")
        local cn = (uiText.cn.openai_missing_model or " OpenAI ")
        show_dynamic_message(en, cn)
        return
    end
    local idx = state.openaiFormat.selectedIndex or 1
    idx = math.max(1, math.min(idx, #models))
    local target = models[idx]
    if target.builtin then
        local en = (uiText.en.openai_delete_builtin_warning or "Built-in models cannot be removed")
        local cn = (uiText.cn.openai_delete_builtin_warning or "")
        show_dynamic_message(en, cn)
        return
    end
    local displayKey = target.display or target.name
    if openAIModelStore.custom then
        openAIModelStore.custom[displayKey] = nil
    end
    Storage.rebuildCustomModelListFromStore()
    state.openaiFormat.models = Utils.deepCopy(DEFAULT_OPENAI_MODELS)
    Storage.ensureOpenAIModelList(state.openaiFormat)
    if state.openaiFormat.selectedIndex and state.openaiFormat.selectedIndex > (#state.openaiFormat.models or 0) then
        state.openaiFormat.selectedIndex = (#state.openaiFormat.models > 0) and #state.openaiFormat.models or nil
    end
    Storage.saveOpenAIModelStore()
    OpenAIService.populateOpenAIModelCombo()
    OpenAIService.syncOpenAIConfigControls()
    local en = (uiText.en.openai_delete_success or "Model deleted")
    local cn = (uiText.cn.openai_delete_success or "")
    show_dynamic_message(en, cn)
    print(string.format("[OpenAI] Model removed: %s", displayKey))
end

local translateTabInitialized = false





local function refreshTranslateStatus()
    local tState = state.translate
    if not tState then
        return
    end
    applyTranslateStatusInternal(tState.lastStatusKey or "idle", tState.lastStatusArgs or {})
end

local function hasFailedTranslateEntries()
    local failed = state.translate and state.translate.failed
    if not failed then
        return false
    end
    for _ in pairs(failed) do
        return true
    end
    return false
end

local function updateRetryButtonState()
    if not it.TranslateRetryFailedButton then
        return
    end
    if state.translate and state.translate.busy then
        it.TranslateRetryFailedButton.Enabled = false
        return
    end
    it.TranslateRetryFailedButton.Enabled = hasFailedTranslateEntries()
end

local function setTranslateControlsEnabled(enabled)
    local flag = enabled and true or false
    if it.TranslateProviderCombo then
        it.TranslateProviderCombo.Enabled = flag
    end
    if it.TranslateTargetCombo then
        it.TranslateTargetCombo.Enabled = flag
    end
    if it.TranslateTransButton then
        it.TranslateTransButton.Enabled = flag
    end
    if it.TranslateSelectedButton then
        it.TranslateSelectedButton.Enabled = flag and (state.translate.selectedIndex ~= nil)
    end
    if it.TranslateUpdateSubtitleButton then
        it.TranslateUpdateSubtitleButton.Enabled = flag
    end
    if it.TranslateSubtitleEditor then
        it.TranslateSubtitleEditor.Enabled = flag
    end
    if it.TranslateConcurrencyCombo then
        it.TranslateConcurrencyCombo.Enabled = flag
    end
    if it.TranslateRetryFailedButton then
        if flag then
            updateRetryButtonState()
        else
            it.TranslateRetryFailedButton.Enabled = false
        end
    end
end

local function normalizeTranslateTree()
    if not it.TranslateSubtitleTree then
        return
    end
    UI.withUpdatesSuspended(it.TranslateSubtitleTree, function()
        it.TranslateSubtitleTree:SetHeaderLabels(UI.currentTranslateHeaders())
        it.TranslateSubtitleTree.ColumnWidth[0] = 50
        it.TranslateSubtitleTree.ColumnWidth[1] = 110
        it.TranslateSubtitleTree.ColumnWidth[2] = 100
        it.TranslateSubtitleTree.ColumnWidth[3] = 260
    end)
end
local function clearAllTranslateFailures()
    if not state.translate.failed then
        return
    end
    for idx in pairs(state.translate.failed) do
        setTranslateRowHighlight(idx, nil)
    end
    state.translate.failed = {}
    updateRetryButtonState()
end
local function resetTranslateState()
    local tState = state.translate
    if not tState then
        return
    end
    tState.entries = {}
    tState.populated = false
    tState.selectedIndex = nil
    tState.totalTokens = 0
    tState.busy = false
    tState.lastStatusKey = "idle"
    tState.lastStatusArgs = nil
    clearAllTranslateFailures()
    tState.failed = {}
    if it.TranslateSubtitleTree then
        UI.withUpdatesSuspended(it.TranslateSubtitleTree, function()
            it.TranslateSubtitleTree:Clear()
        end)
    end
    normalizeTranslateTree()
    if it.TranslateSubtitleEditor then
        UI.withTranslateProgrammatic(function()
            it.TranslateSubtitleEditor.Text = ""
        end)
    end
    if it.TranslateSelectedButton then
        it.TranslateSelectedButton.Enabled = false
    end
    setTranslateStatus("idle")
    updateRetryButtonState()
end

local function cloneEditEntriesForTranslate()
    local cloned = {}
    for index, entry in ipairs(state.entries or {}) do
        cloned[index] = {
            index = index,
            startFrame = entry.startFrame,
            endFrame = entry.endFrame,
            startText = entry.startText or "",
            endText = entry.endText or "",
            original = entry.text or "",
            translation = "",
        }
    end
    return cloned
end

local function populateTranslateTree()
    normalizeTranslateTree()
    if not it.TranslateSubtitleTree then
        return
    end
    local entries = state.translate.entries or {}
    UI.withUpdatesSuspended(it.TranslateSubtitleTree, function()
        it.TranslateSubtitleTree:Clear()
        for index, entry in ipairs(entries) do
            local item = it.TranslateSubtitleTree:NewItem()
            item.Text[0] = tostring(index)
            local startDisplay = entry.startText or Subtitle.framesToTimecode(entry.startFrame or 0, state.fps or 24.0)
            local endDisplay = entry.endText or Subtitle.framesToTimecode(entry.endFrame or 0, state.fps or 24.0)
            item.Text[1] = string.format(" %s\n %s", startDisplay or "", endDisplay or "")
            item.Text[2] = entry.original or ""
            item.Text[3] = entry.translation or ""
            it.TranslateSubtitleTree:AddTopLevelItem(item)
            if state.translate.failed and state.translate.failed[index] then
                setTranslateRowHighlight(index, translateFailureColor)
            end
        end
    end)
    updateRetryButtonState()
end

local function updateTranslateTreeRow(index, text)
    if not it.TranslateSubtitleTree then
        return
    end
    UI.withUpdatesSuspended(it.TranslateSubtitleTree, function()
        local item = it.TranslateSubtitleTree:TopLevelItem(index - 1)
        if item then
            item.Text[3] = text or ""
            if state.translate and state.translate.failed and state.translate.failed[index] then
                item.BackgroundColor[3] = translateFailureColor
            else
                item.BackgroundColor[3] = transparentColor
            end
        end
    end)
end



local function setTranslateRowHighlight(index, color)
    if not it.TranslateSubtitleTree then
        return
    end
    local item = it.TranslateSubtitleTree:TopLevelItem(index - 1)
    if not item then
        return
    end
    local target = color or transparentColor
    item.BackgroundColor[3] = target
end



local function markTranslateFailure(index, reason)
    if not index then
        return
    end
    local tState = state.translate
    if not tState.failed then
        tState.failed = {}
    end
    tState.failed[index] = reason or true
    setTranslateRowHighlight(index, translateFailureColor)
    updateRetryButtonState()
end

local function clearTranslateFailure(index)
    if not index then
        return
    end
    local tState = state.translate
    if tState.failed then
        tState.failed[index] = nil
    end
    setTranslateRowHighlight(index, nil)
    updateRetryButtonState()
end

local function updateTranslateOriginalRow(index, text)
    if not it.TranslateSubtitleTree then
        return
    end
    UI.withUpdatesSuspended(it.TranslateSubtitleTree, function()
        local item = it.TranslateSubtitleTree:TopLevelItem(index - 1)
        if item then
            item.Text[2] = text or ""
        end
    end)
end

local function ensureTranslateEntries(force)
    local tState = state.translate
    if not tState then
        return
    end
    if not force and tState.populated and #tState.entries > 0 then
        normalizeTranslateTree()   
        refreshTranslateStatus()
        updateRetryButtonState()
        return
    end
    setTranslateStatus("copying")
    tState.entries = cloneEditEntriesForTranslate()
    tState.populated = true
    tState.selectedIndex = nil
    tState.totalTokens = 0
    clearAllTranslateFailures()
    tState.failed = {}
    populateTranslateTree()
    if it.TranslateSubtitleEditor then
        UI.withTranslateProgrammatic(function()
            it.TranslateSubtitleEditor.Text = ""
        end)
    end
    if it.TranslateSelectedButton then
        it.TranslateSelectedButton.Enabled = false
    end
    setTranslateStatus("idle")
end

local function refreshTranslateTargetCombo(provider, preferredLabel, preferredCode)
    if not it.TranslateTargetCombo then
        return
    end
    it.TranslateTargetCombo:Clear()
    it.TranslateTargetCombo.PlaceholderText = UI.uiString("translate_target_placeholder")
    local labels, codes, labelMap = Translate.getLangOptions(provider)
    state.translate.targetCodes = codes
    if #labels == 0 then
        it.TranslateTargetCombo.CurrentIndex = -1
        state.translate.targetLabel = nil
        state.translate.targetCode = nil
        return
    end

    local selectedIndex
    if preferredCode and preferredCode ~= "" then
        for idx, code in ipairs(codes) do
            if code == preferredCode then
                selectedIndex = idx - 1
                break
            end
        end
    end
    if selectedIndex == nil and preferredLabel and preferredLabel ~= "" then
        for idx, code in ipairs(codes) do
            if labelMap[code] == preferredLabel then
                selectedIndex = idx - 1
                break
            end
        end
    end
    if selectedIndex == nil then
        selectedIndex = 0
    end
    for _, label in ipairs(labels) do
        it.TranslateTargetCombo:AddItem(label)
    end
    it.TranslateTargetCombo.CurrentIndex = selectedIndex
    state.translate.targetLabel = it.TranslateTargetCombo.CurrentText
    state.translate.targetCode = codes[selectedIndex + 1]
end

local function initTranslateTab()
    if translateTabInitialized then
        normalizeTranslateTree()
        refreshTranslateStatus()
        return
    end
    translateTabInitialized = true
    if it.TranslateProviderLabel then
        it.TranslateProviderLabel.Text = UI.uiString("translate_provider_label")
    end
    if it.TranslateTargetLabel then
        it.TranslateTargetLabel.Text = UI.uiString("translate_target_label")
    end
    if it.TranslateProviderCombo then
        it.TranslateProviderCombo:Clear()
        it.TranslateProviderCombo.PlaceholderText = UI.uiString("translate_provider_placeholder")
        local selectedIndex = 0
        for idx, label in ipairs(TRANSLATE_PROVIDER_LIST) do
            it.TranslateProviderCombo:AddItem(label)
            if state.translate.provider == label then
                selectedIndex = idx - 1
            end
        end
        it.TranslateProviderCombo.CurrentIndex = selectedIndex
        state.translate.provider = it.TranslateProviderCombo.CurrentText or TRANSLATE_PROVIDER_AZURE_LABEL
    end
    refreshTranslateTargetCombo(state.translate.provider, state.translate.targetLabel, state.translate.targetCode)
    if it.TranslateTransButton then
        it.TranslateTransButton.Text = UI.uiString("translate_trans_button")
    end
    if it.TranslateSelectedButton then
        it.TranslateSelectedButton.Text = UI.uiString("translate_selected_button")
        it.TranslateSelectedButton.Enabled = state.translate.selectedIndex ~= nil and not state.translate.busy
    end
    if it.TranslateRetryFailedButton then
        it.TranslateRetryFailedButton.Text = UI.uiString("translate_retry_failed_button")
        updateRetryButtonState()
    end
    if it.TranslateUpdateSubtitleButton then
        it.TranslateUpdateSubtitleButton.Text = UI.uiString("translate_update_button")
    end
    if it.TranslateSubtitleEditor then
        it.TranslateSubtitleEditor.PlaceholderText = UI.uiString("translate_editor_placeholder")
    end
    normalizeTranslateTree()
    setTranslateStatus("idle")
end

local function resolveTargetSelection(provider, targetLabel)
    local label = targetLabel
    if not label or Utils.trim(label) == "" then
        return nil, nil, "missing_target_lang"
    end
    local _, codes, labelMap = Translate.getLangOptions(provider)
    state.translate.targetCodes = codes
    local code = state.translate and state.translate.targetCode
    if code and code ~= "" then
        local found = false
        for _, value in ipairs(codes) do
            if value == code then
                found = true
                break
            end
        end
        if not found then
            code = nil
        end
    end
    if not code or code == "" then
        local index = it.TranslateTargetCombo and it.TranslateTargetCombo.CurrentIndex
        code = getTargetCodeFromIndex(provider, index)
    end
    if not code or code == "" then
        for _, value in ipairs(codes) do
            if labelMap[value] == label then
                code = value
                break
            end
        end
    end
    if not code or code == "" then
        return nil, nil, "missing_target_lang"
    end
    state.translate.targetLabel = label
    state.translate.targetCode = code
    return label, code, nil
end

local function composeTranslatePrompt(targetLabel)
    if not targetLabel or Utils.trim(targetLabel) == "" then
        error("missing_target_lang")
    end
    local target = targetLabel
    local prefix = TRANSLATE_PREFIX_PROMPT:gsub("{target_lang}", target)
    local corePrompt = OPENAI_DEFAULT_SYSTEM_PROMPT
    if state and state.openaiFormat and type(state.openaiFormat.systemPrompt) == "string" then
        local trimmed = Utils.trim(state.openaiFormat.systemPrompt)
        if trimmed ~= "" then
            corePrompt = trimmed
        end
    end
    return table.concat({ prefix, corePrompt, TRANSLATE_SUFFIX_PROMPT }, "\n")
end

local function fetch_provider_secret(provider)
    local cleanProvider = Utils.trim(provider or "")
    if cleanProvider == "" then
        return nil, "missing_provider"
    end
    local cached = Translate.secretCache[cleanProvider]
    if cached and cached ~= "" then
        return cached
    end
    local url = string.format("%s/functions/v1/getApiKey?provider=%s", SUPABASE_URL, Utils.urlEncode(cleanProvider))
    local headers = {
        Authorization = "Bearer " .. SUPABASE_ANON_KEY,
        apikey = SUPABASE_ANON_KEY,
        ["Content-Type"] = "application/json",
        ["User-Agent"] = string.format("%s/%s", SCRIPT_NAME, SCRIPT_VERSION),
    }
    local body, status = Services.httpGet(url, headers, SUPABASE_TIMEOUT)
    if not body then
        return nil, status or "request_failed"
    end
    local ok, decoded = pcall(json.decode, body)
    if not ok or type(decoded) ~= "table" then
        return nil, "decode_failed"
    end
    local apiKey = decoded.api_key or decoded.apiKey or decoded.key
    if not apiKey or apiKey == "" then
        return nil, "missing_key"
    end
    Translate.secretCache[cleanProvider] = apiKey

    return apiKey
end

local function buildTranslateContext(entries, index)
    local beforeParts, afterParts = {}, {}
    if TRANSLATE_CONTEXT_WINDOW > 0 then
        for offset = 1, TRANSLATE_CONTEXT_WINDOW do
            local prev = entries[index - offset]
            if not prev then break end
            if prev.original and prev.original ~= "" then
                table.insert(beforeParts, 1, prev.original)
            end
        end
        for offset = 1, TRANSLATE_CONTEXT_WINDOW do
            local nxt = entries[index + offset]
            if not nxt then break end
            if nxt.original and nxt.original ~= "" then
                table.insert(afterParts, nxt.original)
            end
        end
    end
    return table.concat(beforeParts, "\n"), table.concat(afterParts, "\n")
end

ChatProviders.registry = ChatProviders.registry or {}
ChatProviders.labelIndex = ChatProviders.labelIndex or {}

local function getChatProviderConfig(configOrId)
    if type(configOrId) == "table" then
        return configOrId
    elseif type(configOrId) == "string" then
        if ChatProviders.registry then
            return ChatProviders.registry[configOrId]
        end
    end
    return nil
end

function ChatProviders.register(config)
    if not config or not config.id then
        return
    end
    ChatProviders.registry = ChatProviders.registry or {}
    ChatProviders.labelIndex = ChatProviders.labelIndex or {}
    ChatProviders.registry[config.id] = config
    if config.label then
        ChatProviders.labelIndex[config.label] = config.id
    end
end

function ChatProviders.get(id)
    return getChatProviderConfig(id)
end

function ChatProviders.getByLabel(label)
    if not label or label == "" then
        return nil
    end
    local idx = ChatProviders.labelIndex and ChatProviders.labelIndex[label]
    if idx then
        return ChatProviders.registry[idx]
    end
    return nil
end

function ChatProviders.buildMessages(sentence, prefixText, suffixText, targetLabel)
    local prompt = composeTranslatePrompt(targetLabel)
    local messages = {
        { role = "system", content = prompt },
    }
    local ctxParts = {}
    if prefixText and Utils.trim(prefixText) ~= "" then
        table.insert(ctxParts, prefixText)
    end
    if suffixText and Utils.trim(suffixText) ~= "" then
        table.insert(ctxParts, suffixText)
    end
    if #ctxParts > 0 then
        table.insert(messages, { role = "assistant", content = table.concat(ctxParts, "\nCONTEXT (do not translate)\n") })
    end
    table.insert(messages, { role = "user", content = string.format("<<< Sentence >>>\n%s", sentence or "") })
    return messages
end

function ChatProviders.buildRequestPayload(configOrId, sentence, prefixText, suffixText, targetLabel)
    local config = getChatProviderConfig(configOrId)
    if not config then
        return nil
    end
    local payload = {
        model = config.model,
        messages = ChatProviders.buildMessages(sentence, prefixText, suffixText, targetLabel),
        temperature = config.temperature or GLM_TEMPERATURE,
    }
    if type(config.payloadExtras) == "table" then
        for key, value in pairs(config.payloadExtras) do
            payload[key] = value
        end
    end
    if type(config.preparePayload) == "function" then
        local prepared = config.preparePayload(payload, sentence, prefixText, suffixText, targetLabel)
        if prepared ~= nil then
            payload = prepared
        end
    end
    return json.encode(payload)
end

function ChatProviders.parseResponseBody(body)
    if type(body) ~= "string" or body == "" then
        return nil, 0, "empty_response"
    end

    local ok, decoded = pcall(json.decode, body)
    if not ok or type(decoded) ~= "table" then
        return nil, 0, "decode_failed"
    end

    local choices = decoded.choices
    if type(choices) ~= "table" or not choices[1] or not choices[1].message then
        return nil, 0, "invalid_response"
    end

    local content = Utils.trim(choices[1].message.content or "")
    if content == "" then
        return nil, 0, "empty_translation"
    end

    local usage = decoded.usage
    local tokens = 0
    if type(usage) == "table" then
        tokens = tonumber(usage.total_tokens or usage.totalTokens or 0) or 0
    end
    return content, tokens, nil
end

function ChatProviders.buildHeaderTable(config, apiKey)
    if type(config.buildHeaders) == "function" then
        return config.buildHeaders(apiKey)
    end
    return {
        Authorization = "Bearer " .. apiKey,
        ["Content-Type"] = "application/json",
        ["User-Agent"] = string.format("%s/%s", SCRIPT_NAME, SCRIPT_VERSION),
    }
end

function ChatProviders.buildHeaderList(config, apiKey)
    if type(config.buildHeaderList) == "function" then
        return config.buildHeaderList(apiKey)
    end
    local headerTable = ChatProviders.buildHeaderTable(config, apiKey)
    local list = {}
    for key, value in pairs(headerTable or {}) do
        table.insert(list, string.format("%s: %s", key, value))
    end
    return list
end

function ChatProviders.resolveApiKey(config)
    if type(config.resolveApiKey) == "function" then
        return config.resolveApiKey(config)
    end
    if config.supabaseProvider and config.supabaseProvider ~= "" then
        return fetch_provider_secret(config.supabaseProvider)
    end
    return nil, "missing_key"
end

local function chatProviderPerformRequest(config, sentence, prefixText, suffixText, targetLabel, apiKey)
    local payload = ChatProviders.buildRequestPayload(config, sentence, prefixText, suffixText, targetLabel)
    if not payload then
        return nil, 0, "payload_build_failed"
    end
    local headers = ChatProviders.buildHeaderTable(config, apiKey)
    local body, status = Services.httpPostJson(config.apiUrl, payload, headers, config.timeout or GLM_TIMEOUT)
    if not body then
        return nil, 0, status or "request_failed"
    end
    local parser = config.parseResponse or ChatProviders.parseResponseBody
    return parser(body)
end

function ChatProviders.requestWithApiKey(configOrId, sentence, prefixText, suffixText, targetLabel, apiKey)
    local config = getChatProviderConfig(configOrId)
    if not config then
        return nil, 0, "provider_not_supported"
    end
    if not apiKey or apiKey == "" then
        return nil, 0, "missing_key"
    end
    return chatProviderPerformRequest(config, sentence, prefixText, suffixText, targetLabel, apiKey)
end

function ChatProviders.requestTranslation(configOrId, sentence, prefixText, suffixText, targetLabel)
    local config = getChatProviderConfig(configOrId)
    if not config then
        return nil, 0, "provider_not_supported"
    end
    local apiKey, err = ChatProviders.resolveApiKey(config)
    if not apiKey then
        return nil, 0, err or "missing_key"
    end
    return chatProviderPerformRequest(config, sentence, prefixText, suffixText, targetLabel, apiKey)
end

function ChatProviders.translateEntries(configOrId, entries, targetLabel)
    local config = getChatProviderConfig(configOrId)
    if not config then
        return nil, "provider_not_supported"
    end
    if not entries or #entries == 0 then
        return nil, "no_entries"
    end

    local apiKey, fetchErr = ChatProviders.resolveApiKey(config)
    if not apiKey then
        return nil, fetchErr or "missing_key"
    end

    local totalTokens = 0
    local total = #entries
    local concurrency = math.max(1, state.translate and state.translate.concurrency or DEFAULT_TRANSLATE_CONCURRENCY)
    local processed = 0
    local maxRetry = config.maxRetry or GLM_MAX_RETRY

    setTranslateStatus("progress", processed, total, totalTokens)

    local useParallel = (concurrency > 1) and config.allowParallel ~= false

    if useParallel then
        local startIndex = 1
        while startIndex <= total do
            local batchEnd = math.min(total, startIndex + concurrency - 1)
            local attempts, pending = {}, {}
            for idx = startIndex, batchEnd do
                attempts[idx] = 0
                pending[#pending + 1] = idx
            end

            while #pending > 0 do
                local tasks = {}
                for _, idx in ipairs(pending) do
                    local entry = entries[idx]
                    local prefixText, suffixText = buildTranslateContext(entries, idx)
                    tasks[#tasks + 1] = {
                        index = idx,
                        payload = ChatProviders.buildRequestPayload(config, entry and entry.original or "", prefixText, suffixText, targetLabel) or "",
                    }
                end

                local headersList = ChatProviders.buildHeaderList(config, apiKey)
                local results, batchErr = ParallelServices.runCurlParallel(tasks, {
                    apiUrl = config.apiUrl,
                    timeout = config.timeout or GLM_TIMEOUT,
                    parallelLimit = concurrency,
                    headers = headersList,
                    payloadPrefix = config.parallelPayloadPrefix or string.format("%s_payload", config.id or "chat"),
                    outputPrefix = config.parallelOutputPrefix or string.format("%s_output", config.id or "chat"),
                    parseResponse = config.parseResponse or ChatProviders.parseResponseBody,
                })
                if not results then
                    local errMsg = batchErr or "parallel_execution_failed"
                    if errMsg == "parallel_execution_failed" then
                        errMsg = "openai_parallel_failed"
                    end
                    for _, idx in ipairs(pending) do
                        local entry = entries[idx]
                        local rowIndex = entry and entry.index or idx
                        processed = processed + 1
                        local fallback = string.format("[Error: %s]", tostring(errMsg))
                        if entry then
                            entry.translation = fallback
                        end
                        updateTranslateTreeRow(rowIndex, fallback)
                        markTranslateFailure(rowIndex, errMsg)
                        setTranslateStatus("progress", processed, total, totalTokens)
                    end
                    break
                end

                local nextPending = {}

                for _, task in ipairs(tasks) do
                    local result = results[task.index]
                    local entry = entries[task.index]
                    local rowIndex = entry and entry.index or task.index
                    if result and result.success then
                        if entry then
                            entry.translation = result.translation
                        end
                        updateTranslateTreeRow(rowIndex, result.translation)
                        clearTranslateFailure(rowIndex)
                        totalTokens = totalTokens + (result.tokens or 0)
                        processed = processed + 1
                        setTranslateStatus("progress", processed, total, totalTokens)
                    else
                        local errMsg = (result and result.err) or batchErr or "translation_failed"
                        if errMsg == "parallel_execution_failed" then
                            errMsg = "openai_parallel_failed"
                        end
                        attempts[task.index] = (attempts[task.index] or 0) + 1
                        if attempts[task.index] < maxRetry then
                            nextPending[#nextPending + 1] = task.index
                        else
                            processed = processed + 1
                            local fallback = string.format("[Error: %s]", tostring(errMsg or "failed"))
                            if entry then
                                entry.translation = fallback
                            end
                            updateTranslateTreeRow(rowIndex, fallback)
                            markTranslateFailure(rowIndex, errMsg)
                            setTranslateStatus("progress", processed, total, totalTokens)
                        end
                    end
                end

                if #nextPending == 0 then
                    pending = {}
                else
                    pending = nextPending
                end
            end

            startIndex = batchEnd + 1
        end
    end

    if not useParallel then
        totalTokens = 0
        processed = 0
        setTranslateStatus("progress", processed, total, totalTokens)

        for startIndex = 1, total, concurrency do
            local batchEnd = math.min(total, startIndex + concurrency - 1)
            for index = startIndex, batchEnd do
                local entry = entries[index]
                local rowIndex = entry and entry.index or index
                local prefixText, suffixText = buildTranslateContext(entries, index)
                local success = false
                local lastError = nil

                for attempt = 1, maxRetry do
                    local translation, tokens, errMsg = ChatProviders.requestWithApiKey(config, entry.original or "", prefixText, suffixText, targetLabel, apiKey)
                    if translation then
                        entry.translation = translation
                        updateTranslateTreeRow(rowIndex, translation)
                        clearTranslateFailure(rowIndex)
                        totalTokens = totalTokens + (tokens or 0)
                        success = true
                        break
                    else
                        lastError = errMsg
                    end
                end

                processed = processed + 1
                setTranslateStatus("progress", processed, total, totalTokens)

                if not success then
                    local fallback = string.format("[Error: %s]", tostring(lastError or "failed"))
                    entries[index].translation = fallback
                    updateTranslateTreeRow(rowIndex, fallback)
                    markTranslateFailure(rowIndex, lastError)
                end
            end
        end
    end

    return totalTokens, nil
end

local GLM_CHAT_PROVIDER = {
    id = "glm",
    label = TRANSLATE_PROVIDER_GL_LABEL,
    supabaseProvider = GLM_SUPABASE_PROVIDER,
    apiUrl = GLM_API_URL,
    model = GLM_MODEL,
    timeout = GLM_TIMEOUT,
    maxRetry = GLM_MAX_RETRY,
    payloadExtras = { thinking = { type = "disabled" } },
}

local SILICONFLOUW_CHAT_PROVIDER = {
    id = "siliconflow",
    label = TRANSLATE_PROVIDER_SILICONFLOW_LABEL,
    supabaseProvider = SILICONFLOUW_SUPABASE_PROVIDER,
    apiUrl = SILICONFLOUW_API_URL,
    model = SILICONFLOUW_MODEL,
    timeout = GLM_TIMEOUT,
    maxRetry = GLM_MAX_RETRY,
    payloadExtras = { thinking = { type = "disabled" } },
}

ChatProviders.register(GLM_CHAT_PROVIDER)
ChatProviders.register(SILICONFLOUW_CHAT_PROVIDER)

function GLMService.buildRequestPayload(sentence, prefixText, suffixText, targetLabel)
    return ChatProviders.buildRequestPayload(GLM_CHAT_PROVIDER, sentence, prefixText, suffixText, targetLabel)
end

function GLMService.parseResponseBody(body)
    return ChatProviders.parseResponseBody(body)
end

function GLMService.requestTranslation(sentence, prefixText, suffixText, targetLabel, apiKey)
    return ChatProviders.requestWithApiKey(GLM_CHAT_PROVIDER, sentence, prefixText, suffixText, targetLabel, apiKey)
end

function GLMService.translateEntries(entries, targetLabel)
    return ChatProviders.translateEntries(GLM_CHAT_PROVIDER, entries, targetLabel)
end

function DeepL.resolveApiUrl(apiKey)
    local key = Utils.trim(apiKey or "")
    if key ~= "" and key:match(":fx$") then
        return DEEPL_FREE_API_URL
    end
    return DEEPL_PRO_API_URL
end

function DeepL.parseResponseBody(body)
    local ok, decoded = pcall(json.decode, body or "")
    if not ok or type(decoded) ~= "table" then
        return nil, 0, "decode_failed"
    end
    local translations = decoded.translations
    if type(translations) ~= "table" or type(translations[1]) ~= "table" then
        if decoded.message then
            return nil, 0, tostring(decoded.message)
        end
        return nil, 0, "invalid_response"
    end
    local translated = translations[1].text
    if not translated or Utils.trim(translated) == "" then
        return nil, 0, "empty_translation"
    end
    return translated, 0, nil
end

function DeepL.requestTranslation(text, targetCode, apiKey)
    local key = Utils.trim(apiKey or "")
    if key == "" then
        return nil, 0, "deepl_missing_key"
    end
    if not targetCode or targetCode == "" then
        return nil, 0, "missing_target_lang"
    end
    local payload = json.encode({
        text = { text or "" },
        target_lang = targetCode,
    })
    local headers = {
        Authorization = "DeepL-Auth-Key " .. key,
        ["Content-Type"] = "application/json",
        ["User-Agent"] = string.format("%s/%s", SCRIPT_NAME, SCRIPT_VERSION),
    }
    local apiUrl = DeepL.resolveApiUrl(key)
    local body, status = Services.httpPostJson(apiUrl, payload, headers, DEEPL_TIMEOUT)
    if not body then
        return nil, 0, status or "request_failed"
    end
    local translation, _, err = DeepL.parseResponseBody(body)
    if not translation then
        local ok, decoded = pcall(json.decode, body)
        if ok and type(decoded) == "table" and decoded.message then
            return nil, 0, tostring(decoded.message)
        end
    end
    return translation, 0, err
end

function DeepL.translateEntries(entries, targetLabel)
    if not entries or #entries == 0 then
        return nil, "no_entries"
    end
    local apiKey = Utils.trim(state.deepl and state.deepl.apiKey or "")
    if apiKey == "" then
        return nil, "deepl_missing_key"
    end
    local _, targetCode, targetErr = resolveTargetSelection(TRANSLATE_PROVIDER_DEEPL_LABEL, targetLabel)
    if not targetCode then
        return nil, targetErr or "missing_target_lang"
    end

    local totalTokens = 0
    local total = #entries
    local processed = 0
    local concurrency = math.max(1, state.translate and state.translate.concurrency or DEFAULT_TRANSLATE_CONCURRENCY)
    local useParallel = concurrency > 1
    local apiUrl = DeepL.resolveApiUrl(apiKey)
    local headers = {
        string.format("Authorization: DeepL-Auth-Key %s", apiKey),
        "Content-Type: application/json",
        string.format("User-Agent: %s/%s", SCRIPT_NAME, SCRIPT_VERSION),
    }

    setTranslateStatus("progress", processed, total, totalTokens)

    if useParallel then
        local startIndex = 1
	        while startIndex <= total do
	            local batchEnd = math.min(total, startIndex + concurrency - 1)
	            local tasks = {}
	            for idx = startIndex, batchEnd do
	                local entry = entries[idx]
                tasks[#tasks + 1] = {
                    index = idx,
                    payload = json.encode({
                        text = { entry and entry.original or "" },
                        target_lang = targetCode,
                    }),
                    url = apiUrl,
                }
            end

	            local results, batchErr = ParallelServices.runCurlParallel(tasks, {
	                apiUrl = apiUrl,
	                timeout = DEEPL_TIMEOUT,
	                parallelLimit = concurrency,
	                headers = headers,
	                payloadPrefix = "deepl_payload",
	                outputPrefix = "deepl_output",
	                parseResponse = DeepL.parseResponseBody,
	            })
	            if not results then
	                local errMsg = batchErr or "translation_failed"
	                for idx = startIndex, batchEnd do
	                    local entry = entries[idx]
	                    local rowIndex = entry and entry.index or idx
	                    processed = processed + 1
	                    local fallback = string.format("[Error: %s]", tostring(errMsg))
	                    if entry then
	                        entry.translation = fallback
	                    end
	                    updateTranslateTreeRow(rowIndex, fallback)
	                    markTranslateFailure(rowIndex, errMsg)
	                    setTranslateStatus("progress", processed, total, totalTokens)
	                end
	            else
	                for idx = startIndex, batchEnd do
	                    local result = results[idx]
	                    local entry = entries[idx]
	                    local rowIndex = entry and entry.index or idx
	                    if result and result.success then
	                        if entry then
	                            entry.translation = result.translation
	                        end
	                        updateTranslateTreeRow(rowIndex, result.translation)
	                        clearTranslateFailure(rowIndex)
	                    else
	                        local errMsg = (result and result.err) or batchErr or "translation_failed"
	                        local fallback = string.format("[Error: %s]", tostring(errMsg or "failed"))
	                        if entry then
	                            entry.translation = fallback
	                        end
	                        updateTranslateTreeRow(rowIndex, fallback)
	                        markTranslateFailure(rowIndex, errMsg)
	                    end
	                    processed = processed + 1
	                    setTranslateStatus("progress", processed, total, totalTokens)
	                end
	            end
	            startIndex = batchEnd + 1
	        end
	    else
	        for index = 1, total do
            local entry = entries[index]
            local rowIndex = entry and entry.index or index
            local translation, _, errMsg = DeepL.requestTranslation(entry.original or "", targetCode, apiKey)
            if translation then
                entry.translation = translation
                updateTranslateTreeRow(rowIndex, translation)
                clearTranslateFailure(rowIndex)
            else
                local fallback = string.format("[Error: %s]", tostring(errMsg or "failed"))
                entry.translation = fallback
                updateTranslateTreeRow(rowIndex, fallback)
                markTranslateFailure(rowIndex, errMsg)
            end
            processed = processed + 1
            setTranslateStatus("progress", processed, total, totalTokens)
        end
    end

    return totalTokens, nil
end

function Azure.resolveCredential()
    local key = Utils.trim(state.azure and state.azure.apiKey or "")
    local region = Utils.trim(state.azure and state.azure.region or "")
    if key ~= "" and region ~= "" then
        return key, region
    end
    local apiKey, err = fetch_provider_secret(AZURE_SUPABASE_PROVIDER)
    if not apiKey then
        return nil, nil, err
    end
    return apiKey, AZURE_FALLBACK_REGION
end

function Azure.parseResponseBody(body)
    local ok, decoded = pcall(json.decode, body or "")
    if not ok or type(decoded) ~= "table" then
        return nil, 0, "decode_failed"
    end
    local first = decoded[1]
    if type(first) ~= "table" then
        return nil, 0, "invalid_response"
    end
    local translations = first.translations
    if type(translations) ~= "table" or type(translations[1]) ~= "table" then
        return nil, 0, "translation_failed"
    end
    local translated = translations[1].text
    if not translated or Utils.trim(translated) == "" then
        return nil, 0, "empty_translation"
    end
    return translated, 0, nil
end

function Azure.requestTranslation(text, targetCode, baseUrl, apiKey, region)
    if not targetCode or targetCode == "" then
        return nil, 0, "missing_target_lang"
    end
    local cleanBase = Utils.trim(baseUrl or "")
    if cleanBase == "" then
        cleanBase = AZURE_DEFAULT_BASE_URL
    end
    cleanBase = cleanBase:gsub("/+$", "")
    local query = string.format("?api-version=3.0&to=%s", Utils.urlEncode(targetCode))
    local url = cleanBase .. "/translate" .. query
    local payload = json.encode({
        { Text = text or "" },
    })
    local headers = {
        ["Ocp-Apim-Subscription-Key"] = apiKey,
        ["Ocp-Apim-Subscription-Region"] = region,
        ["Content-Type"] = "application/json",
        ["User-Agent"] = string.format("%s/%s", SCRIPT_NAME, SCRIPT_VERSION),
    }
    local body, status = Services.httpPostJson(url, payload, headers, AZURE_TIMEOUT)
    if not body then
        return nil, 0, status or "request_failed"
    end
    return Azure.parseResponseBody(body)
end

function OpenAIService.buildRequestPayload(sentence, prefixText, suffixText, targetLabel, model, temperature)
        local prompt = composeTranslatePrompt(targetLabel)
        local messages = {
            { role = "system", content = prompt },
        }
        local ctxParts = {}
        if prefixText and Utils.trim(prefixText) ~= "" then
            table.insert(ctxParts, prefixText)
        end
        if suffixText and Utils.trim(suffixText) ~= "" then
            table.insert(ctxParts, suffixText)
        end
        if #ctxParts > 0 then
            table.insert(messages, { role = "assistant", content = table.concat(ctxParts, "\nCONTEXT (do not translate)\n") })
        end
        table.insert(messages, { role = "user", content = string.format("<<< Sentence >>>\n%s", sentence or "") })

        local payloadTable = {
            model = model,
            messages = messages,
            temperature = temperature or OPENAI_FORMAT_DEFAULT_TEMPERATURE,
        }
        return json.encode(payloadTable)
end

function OpenAIService.parseResponseBody(body)
    return GLMService.parseResponseBody(body)
end

function OpenAIService.requestTranslation(sentence, prefixText, suffixText, targetLabel, config)
        local model = config and config.model
        if not model or Utils.trim(model) == "" then
            return nil, 0, "openai_missing_model"
        end
        local baseUrl = Utils.trim(config.baseUrl or "")
        if baseUrl == "" then
            baseUrl = OPENAI_FORMAT_DEFAULT_BASE_URL
        end
        local apiKey = Utils.trim(config.apiKey or "")
        if apiKey == "" then
            return nil, 0, "openai_missing_key"
        end
        local temperature = tonumber(config.temperature) or OPENAI_FORMAT_DEFAULT_TEMPERATURE
        if temperature < 0 then
            temperature = 0
        elseif temperature > 1 then
            temperature = 1
        end

        local payload = OpenAIService.buildRequestPayload(sentence, prefixText, suffixText, targetLabel, model, temperature)
        local headers = {
            Authorization = "Bearer " .. apiKey,
            ["Content-Type"] = "application/json",
            ["User-Agent"] = string.format("%s/%s", SCRIPT_NAME, SCRIPT_VERSION),
        }
        local apiUrl = baseUrl:gsub("/+$", "") .. "/v1/chat/completions"
        local body, status = Services.httpPostJson(apiUrl, payload, headers, OPENAI_FORMAT_TIMEOUT)
        if not body then
            return nil, 0, status or "request_failed"
        end
    local translation, tokens, err = OpenAIService.parseResponseBody(body)
        if not translation then
            local ok, decoded = pcall(json.decode, body)
            if ok and type(decoded) == "table" and decoded.error and decoded.error.message then
                return nil, 0, decoded.error.message
            end
        end
        return translation, tokens, err
    end

    function Azure.translateEntries(entries, targetLabel)
        if not entries or #entries == 0 then
            return nil, "no_entries"
        end

        local _, targetCode, targetErr = resolveTargetSelection(TRANSLATE_PROVIDER_AZURE_LABEL, targetLabel)
        if not targetCode then
            return nil, targetErr or "missing_target_lang"
        end

        local userKey = Utils.trim(state.azure and state.azure.apiKey or "")
        local userRegion = Utils.trim(state.azure and state.azure.region or "")
        if userKey == "" or userRegion == "" then
            --setTranslateStatus("fetching_key")
        end
        local apiKey, region, fetchErr = Azure.resolveCredential()
        if not apiKey then
            return nil, fetchErr or "missing_key"
        end
        if not region or region == "" then
            region = AZURE_FALLBACK_REGION
        end
        local baseUrl = state.azure and state.azure.baseUrl or AZURE_DEFAULT_BASE_URL

        local totalTokens = 0
        local total = #entries
        local processed = 0
        local concurrency = math.max(1, state.translate and state.translate.concurrency or DEFAULT_TRANSLATE_CONCURRENCY)
        local useParallel = concurrency > 1

        local cleanBase = Utils.trim(baseUrl or "")
        if cleanBase == "" then
            cleanBase = AZURE_DEFAULT_BASE_URL
        end
        cleanBase = cleanBase:gsub("/+$", "")
        baseUrl = cleanBase
        local translateUrl = cleanBase .. "/translate" .. string.format("?api-version=3.0&to=%s", Utils.urlEncode(targetCode))
        local headers = {
            string.format("Ocp-Apim-Subscription-Key: %s", apiKey),
            string.format("Ocp-Apim-Subscription-Region: %s", region),
            "Content-Type: application/json",
            string.format("User-Agent: %s/%s", SCRIPT_NAME, SCRIPT_VERSION),
        }

        setTranslateStatus("progress", processed, total, totalTokens)

        if useParallel then
            local startIndex = 1
            while startIndex <= total do
                local batchEnd = math.min(total, startIndex + concurrency - 1)
                local tasks = {}
                for idx = startIndex, batchEnd do
                    local entry = entries[idx]
                    tasks[#tasks + 1] = {
                        index = idx,
                        payload = json.encode({
                            { text = entry and entry.original or "" },
                        }),
                        url = translateUrl,
                    }
                end

                local results, batchErr = ParallelServices.runCurlParallel(tasks, {
                    timeout = AZURE_TIMEOUT,
                    parallelLimit = concurrency,
                    headers = headers,
                    payloadPrefix = "azure_payload",
                    outputPrefix = "azure_output",
                    parseResponse = Azure.parseResponseBody,
                })
                if not results then
                    local errMsg = batchErr or "parallel_execution_failed"
                    for _, task in ipairs(tasks) do
                        local idx = task.index
                        local entry = entries[idx]
                        local rowIndex = entry and entry.index or idx
                        local fallback = string.format("[Error: %s]", tostring(errMsg))
                        if entry then
                            entry.translation = fallback
                        end
                        updateTranslateTreeRow(rowIndex, fallback)
                        markTranslateFailure(rowIndex, errMsg)
                        processed = processed + 1
                        setTranslateStatus("progress", processed, total, totalTokens)
                    end
                else
                    for _, task in ipairs(tasks) do
                        local result = results[task.index]
                        local entry = entries[task.index]
                        local rowIndex = entry and entry.index or task.index
                        if result and result.success then
                            local translation = result.translation
                            if entry then
                                entry.translation = translation
                            end
                            updateTranslateTreeRow(rowIndex, translation)
                            clearTranslateFailure(rowIndex)
                            processed = processed + 1
                            setTranslateStatus("progress", processed, total, totalTokens)
                        else
                            local errMsg = (result and result.err) or batchErr or "translation_failed"
                            local fallback = string.format("[Error: %s]", tostring(errMsg))
                            if entry then
                                entry.translation = fallback
                            end
                            updateTranslateTreeRow(rowIndex, fallback)
                            markTranslateFailure(rowIndex, errMsg)
                            processed = processed + 1
                            setTranslateStatus("progress", processed, total, totalTokens)
                        end
                    end
                end

                startIndex = batchEnd + 1
            end
        end

        if not useParallel then
            processed = 0
            setTranslateStatus("progress", processed, total, totalTokens)
            for index, entry in ipairs(entries) do
                local translation, _, errMsg = Azure.requestTranslation(entry.original or "", targetCode, baseUrl, apiKey, region)
                local rowIndex = entry and entry.index or index
                if translation then
                    entry.translation = translation
                    updateTranslateTreeRow(rowIndex, translation)
                    clearTranslateFailure(rowIndex)
                else
                    local fallback = string.format("[Error: %s]", tostring(errMsg or "failed"))
                    entry.translation = fallback
                    updateTranslateTreeRow(rowIndex, fallback)
                    markTranslateFailure(rowIndex, errMsg)
                end
                processed = processed + 1
                setTranslateStatus("progress", processed, total, totalTokens)
            end
        end

        return totalTokens, nil
    end

    function OpenAIService.translateEntries(entries, targetLabel)
        if not entries or #entries == 0 then
            return nil, "no_entries"
        end

        OpenAIService.applyConfigFromControls()
        Storage.ensureOpenAIModelList(state.openaiFormat)
        local selected = Storage.getOpenAISelectedModel(state.openaiFormat)
        if not selected then
            return nil, "openai_missing_model"
        end
        local apiKey = Utils.trim(state.openaiFormat.apiKey or "")
        if apiKey == "" then
            return nil, "openai_missing_key"
        end
        local baseUrl = Utils.trim(state.openaiFormat.baseUrl or "")
        if baseUrl == "" then
            baseUrl = OPENAI_FORMAT_DEFAULT_BASE_URL
        end
        local temperature = tonumber(state.openaiFormat.temperature) or OPENAI_FORMAT_DEFAULT_TEMPERATURE
        if temperature < 0 then
            temperature = 0
        elseif temperature > 1 then
            temperature = 1
        end

        local totalTokens = 0
        local total = #entries
        local concurrency = math.max(1, state.translate and state.translate.concurrency or DEFAULT_TRANSLATE_CONCURRENCY)
        local processed = 0

        setTranslateStatus("progress", processed, total, totalTokens)

        local useParallel = concurrency > 1
        local apiUrl = baseUrl:gsub("/*$", "") .. "/v1/chat/completions"

        if useParallel then
            local startIndex = 1
            while startIndex <= total do
                local batchEnd = math.min(total, startIndex + concurrency - 1)
                local attempts, pending = {}, {}
                for idx = startIndex, batchEnd do
                    attempts[idx] = 0
                    pending[#pending + 1] = idx
                end

                while #pending > 0 do
                    local tasks = {}
                    for _, idx in ipairs(pending) do
                        local entry = entries[idx]
                        local prefixText, suffixText = buildTranslateContext(entries, idx)
                        tasks[#tasks + 1] = {
                            index = idx,
                            payload = OpenAIService.buildRequestPayload(entry.original or "", prefixText, suffixText, targetLabel, selected.name, temperature),
                        }
                    end

                    local results, batchErr = ParallelServices.runCurlParallel(tasks, {
                        apiUrl = apiUrl,
                        timeout = OPENAI_FORMAT_TIMEOUT,
                        parallelLimit = concurrency,
                        headers = {
                            string.format("Authorization: Bearer %s", apiKey),
                            "Content-Type: application/json",
                            string.format("User-Agent: %s/%s", SCRIPT_NAME, SCRIPT_VERSION),
                        },
                        payloadPrefix = "openai_payload",
                        outputPrefix = "openai_output",
                        parseResponse = OpenAIService.parseResponseBody,
                    })
                    if not results then
                        local errMsg = batchErr or "parallel_execution_failed"
                        if errMsg == "parallel_execution_failed" then
                            errMsg = "openai_parallel_failed"
                        end
                        for _, idx in ipairs(pending) do
                            local entry = entries[idx]
                            local rowIndex = entry and entry.index or idx
                            processed = processed + 1
                            local fallback = string.format("[Error: %s]", tostring(errMsg))
                            if entry then
                                entry.translation = fallback
                            end
                            updateTranslateTreeRow(rowIndex, fallback)
                            markTranslateFailure(rowIndex, errMsg)
                            setTranslateStatus("progress", processed, total, totalTokens)
                        end
                        break
                    end

                    local nextPending = {}

                    for _, task in ipairs(tasks) do
                        local result = results[task.index]
                        local entry = entries[task.index]
                        local rowIndex = entry and entry.index or task.index
                        if result and result.success then
                            if entry then
                                entry.translation = result.translation
                            end
                            updateTranslateTreeRow(rowIndex, result.translation)
                            clearTranslateFailure(rowIndex)
                            totalTokens = totalTokens + (result.tokens or 0)
                            processed = processed + 1
                            setTranslateStatus("progress", processed, total, totalTokens)
                        else
                            local errMsg = (result and result.err) or batchErr or "translation_failed"
                            attempts[task.index] = (attempts[task.index] or 0) + 1
                            if attempts[task.index] < GLM_MAX_RETRY then
                                nextPending[#nextPending + 1] = task.index
                            else
                                processed = processed + 1
                                local fallback = string.format("[Error: %s]", tostring(errMsg or "failed"))
                                if entry then
                                    entry.translation = fallback
                                end
                                updateTranslateTreeRow(rowIndex, fallback)
                                markTranslateFailure(rowIndex, errMsg)
                                setTranslateStatus("progress", processed, total, totalTokens)
                            end
                        end
                    end

                    if #nextPending == 0 then
                        pending = {}
                    else
                        pending = nextPending
                    end
                end

                startIndex = batchEnd + 1
            end
        end

        if not useParallel then
            totalTokens = 0
            processed = 0
            setTranslateStatus("progress", processed, total, totalTokens)

            local requestConfig = {
                baseUrl = baseUrl,
                apiKey = apiKey,
                model = selected.name,
                temperature = temperature,
            }

            for startIndex = 1, total, concurrency do
                local batchEnd = math.min(total, startIndex + concurrency - 1)
                for index = startIndex, batchEnd do
                    local entry = entries[index]
                    local rowIndex = entry and entry.index or index
                    local prefixText, suffixText = buildTranslateContext(entries, index)
                    local success = false
                    local lastError = nil

                    for attempt = 1, GLM_MAX_RETRY do
                        local translation, tokens, errMsg = OpenAIService.requestTranslation(entry.original or "", prefixText, suffixText, targetLabel, requestConfig)
                        if translation then
                            entry.translation = translation
                            updateTranslateTreeRow(rowIndex, translation)
                            clearTranslateFailure(rowIndex)
                            totalTokens = totalTokens + (tokens or 0)
                            success = true
                            break
                        else
                            lastError = errMsg
                        end
                    end

                    processed = processed + 1
                    setTranslateStatus("progress", processed, total, totalTokens)

                    if not success then
                        local fallback = string.format("[Error: %s]", tostring(lastError or "failed"))
                        entry.translation = fallback
                        updateTranslateTreeRow(rowIndex, fallback)
                        markTranslateFailure(rowIndex, lastError)
                    end
                end
            end
        end

        return totalTokens, nil
    end

    local function performTranslateWorkflow()
        if state.translate.busy then
            return false
        end

        OpenAIService.applyConfigFromControls()

        ensureTranslateEntries(false)
        local entries = state.translate.entries or {}
        if #entries == 0 then
            setTranslateStatus("no_entries")
            return false
        end

        local provider = it.TranslateProviderCombo and it.TranslateProviderCombo.CurrentText or state.translate.provider
        if not provider or Utils.trim(provider) == "" then
            provider = TRANSLATE_PROVIDER_AZURE_LABEL
        end
        state.translate.provider = provider
        local providerConfig = ChatProviders.getByLabel(provider)
        local translateFunc
        if provider == TRANSLATE_PROVIDER_AZURE_LABEL then
            translateFunc = Azure.translateEntries
        elseif provider == TRANSLATE_PROVIDER_DEEPL_LABEL then
            translateFunc = DeepL.translateEntries
        elseif provider == TRANSLATE_PROVIDER_OPENAI_LABEL then
            translateFunc = OpenAIService.translateEntries
        elseif providerConfig then
            translateFunc = function(list, label)
                return ChatProviders.translateEntries(providerConfig, list, label)
            end
        else
            local en, cn = resolveTranslateErrorPair("provider_not_supported")
            show_dynamic_message(en, cn)
            setTranslateStatus("failed", resolveTranslateError("provider_not_supported"))
            return false
        end

        local targetLabel = it.TranslateTargetCombo and it.TranslateTargetCombo.CurrentText or state.translate.targetLabel
        local resolvedLabel, _, targetErr = resolveTargetSelection(provider, targetLabel)
        if not resolvedLabel then
            setTranslateStatus("failed", resolveTranslateError(targetErr or "missing_target_lang"))
            return false
        end
        targetLabel = resolvedLabel

        state.translate.busy = true
        setTranslateControlsEnabled(false)

        local ok, totalTokens, err = pcall(translateFunc, entries, targetLabel)

        state.translate.busy = false
        setTranslateControlsEnabled(true)

        if not ok then
            state.translate.totalTokens = 0
            local en, cn = resolveTranslateErrorPair(totalTokens or "translation_failed")
            show_dynamic_message(en, cn)
            setTranslateStatus("failed", resolveTranslateError(totalTokens) or tostring(totalTokens))
            return false
        end

        if not totalTokens then
            state.translate.totalTokens = 0
            local en, cn = resolveTranslateErrorPair(err or "translation_failed")
            show_dynamic_message(en, cn)
            setTranslateStatus("failed", resolveTranslateError(err or "translation_failed"))
            return false
        end

        state.translate.totalTokens = totalTokens
        applyTranslateSuccessStatus(entries, totalTokens, true)
        return true
    end

    local function translateSingleEntry(index, targetLabel)
        OpenAIService.applyConfigFromControls()
        local entries = state.translate.entries or {}
        local entry = entries[index]
        if not entry then
            setTranslateStatus("failed", resolveTranslateError("no_selection"))
            return false
        end
        local rowIndex = entry.index or index
        local provider = state.translate.provider or TRANSLATE_PROVIDER_AZURE_LABEL
        local resolvedLabel, targetCode, targetErr = resolveTargetSelection(provider, targetLabel)
        if not resolvedLabel then
            setTranslateStatus("failed", resolveTranslateError(targetErr or "missing_target_lang"))
            return false
        end
        targetLabel = resolvedLabel
        local providerConfig = ChatProviders.getByLabel(provider)
        if provider == TRANSLATE_PROVIDER_AZURE_LABEL then
            local userKey = Utils.trim(state.azure and state.azure.apiKey or "")
            local userRegion = Utils.trim(state.azure and state.azure.region or "")
            if userKey == "" or userRegion == "" then
                --setTranslateStatus("fetching_key")
            end
            local apiKey, region, fetchErr = Azure.resolveCredential()
            if not apiKey then
                setTranslateStatus("failed", resolveTranslateError(fetchErr or "missing_key"))
                return false
            end
            if not region or region == "" then
                region = AZURE_FALLBACK_REGION
            end
            local baseUrl = state.azure and state.azure.baseUrl or AZURE_DEFAULT_BASE_URL
            setTranslateStatus("progress", 0, 1, state.translate.totalTokens or 0)
            local translation, _, errMsg = Azure.requestTranslation(entry.original or "", targetCode, baseUrl, apiKey, region)
            if translation then
                entry.translation = translation
                updateTranslateTreeRow(rowIndex, translation)
                clearTranslateFailure(rowIndex)
                state.translate.totalTokens = state.translate.totalTokens or 0
                applyTranslateSuccessStatus({ entry }, state.translate.totalTokens)
                return true
            end
            local fallback = string.format("[Error: %s]", tostring(errMsg or "failed"))
            entry.translation = fallback
            updateTranslateTreeRow(rowIndex, fallback)
            markTranslateFailure(rowIndex, errMsg)
            applyTranslateSuccessStatus({ entry }, state.translate.totalTokens)
            return true
        elseif provider == TRANSLATE_PROVIDER_DEEPL_LABEL then
            local apiKey = Utils.trim(state.deepl and state.deepl.apiKey or "")
            if apiKey == "" then
                setTranslateStatus("failed", resolveTranslateError("deepl_missing_key"))
                return false
            end
            setTranslateStatus("progress", 0, 1, state.translate.totalTokens or 0)
            local translation, _, errMsg = DeepL.requestTranslation(entry.original or "", targetCode, apiKey)
            if translation then
                entry.translation = translation
                updateTranslateTreeRow(rowIndex, translation)
                clearTranslateFailure(rowIndex)
                state.translate.totalTokens = state.translate.totalTokens or 0
                applyTranslateSuccessStatus({ entry }, state.translate.totalTokens)
                return true
            end
            local fallback = string.format("[Error: %s]", tostring(errMsg or "failed"))
            entry.translation = fallback
            updateTranslateTreeRow(rowIndex, fallback)
            markTranslateFailure(rowIndex, errMsg)
            applyTranslateSuccessStatus({ entry }, state.translate.totalTokens)
            return true
        elseif providerConfig then
            local apiKey, fetchErr = ChatProviders.resolveApiKey(providerConfig)
            if not apiKey then
                setTranslateStatus("failed", resolveTranslateError(fetchErr or "missing_key"))
                return false
            end

            local beforeCtx, afterCtx = buildTranslateContext(entries, index)
            setTranslateStatus("progress", 0, 1, state.translate.totalTokens or 0)

            local translation, tokens, errMsg = ChatProviders.requestWithApiKey(providerConfig, entry.original or "", beforeCtx, afterCtx, targetLabel, apiKey)
            if translation then
                entry.translation = translation
                updateTranslateTreeRow(rowIndex, translation)
                clearTranslateFailure(rowIndex)
                state.translate.totalTokens = (state.translate.totalTokens or 0) + (tokens or 0)
                applyTranslateSuccessStatus({ entry }, state.translate.totalTokens)
                return true
            end

            local fallback = string.format("[Error: %s]", tostring(errMsg or "failed"))
            entry.translation = fallback
            updateTranslateTreeRow(rowIndex, fallback)
            markTranslateFailure(rowIndex, errMsg)
            applyTranslateSuccessStatus({ entry }, state.translate.totalTokens)
            return true
        elseif provider == TRANSLATE_PROVIDER_OPENAI_LABEL then
            OpenAIService.applyConfigFromControls()
            Storage.ensureOpenAIModelList(state.openaiFormat)
            local selected = Storage.getOpenAISelectedModel(state.openaiFormat)
            if not selected then
                setTranslateStatus("failed", resolveTranslateError("openai_missing_model"))
                return false
            end
            local apiKey = Utils.trim(state.openaiFormat.apiKey or "")
            if apiKey == "" then
                setTranslateStatus("failed", resolveTranslateError("openai_missing_key"))
                return false
            end
            local baseUrl = Utils.trim(state.openaiFormat.baseUrl or "")
            if baseUrl == "" then
                baseUrl = OPENAI_FORMAT_DEFAULT_BASE_URL
            end
            local temperature = tonumber(state.openaiFormat.temperature) or OPENAI_FORMAT_DEFAULT_TEMPERATURE
            if temperature < 0 then
                temperature = 0
            elseif temperature > 1 then
                temperature = 1
            end

            local beforeCtx, afterCtx = buildTranslateContext(entries, index)
            setTranslateStatus("progress", 0, 1, state.translate.totalTokens or 0)

            local translation, tokens, errMsg = OpenAIService.requestTranslation(entry.original or "", beforeCtx, afterCtx, targetLabel, {
                baseUrl = baseUrl,
                apiKey = apiKey,
                model = selected.name,
                temperature = temperature,
            })
            if translation then
                entry.translation = translation
                updateTranslateTreeRow(rowIndex, translation)
                clearTranslateFailure(rowIndex)
                state.translate.totalTokens = (state.translate.totalTokens or 0) + (tokens or 0)
                applyTranslateSuccessStatus({ entry }, state.translate.totalTokens)
                return true
            end

            local fallback = string.format("[Error: %s]", tostring(errMsg or "failed"))
            entry.translation = fallback
            updateTranslateTreeRow(rowIndex, fallback)
            markTranslateFailure(rowIndex, errMsg)
            applyTranslateSuccessStatus({ entry }, state.translate.totalTokens)
            return true
        end

        setTranslateStatus("failed", resolveTranslateError("provider_not_supported"))
        return false
    end


    local function collectFailedIndices()
        local failed = state.translate.failed
        local indices = {}
        if failed then
            for idx in pairs(failed) do
                indices[#indices + 1] = idx
            end
            table.sort(indices)
        end
        return indices
    end

    local function retryFailedEntries()
        if state.translate.busy then
            return false
        end

        ensureTranslateEntries(false)

        local indices = collectFailedIndices()
        if #indices == 0 then
            UI.updateStatus("retry_no_failed")
            updateRetryButtonState()
            return false
        end

        local entries = state.translate.entries or {}
        local subset = {}
        for _, idx in ipairs(indices) do
            local entry = entries[idx]
            if entry then
                subset[#subset + 1] = entry
            else
                if state.translate.failed then
                    state.translate.failed[idx] = nil
                end
            end
        end

        updateRetryButtonState()

        if #subset == 0 then
            state.translate.failed = {}
            updateRetryButtonState()
            UI.updateStatus("retry_no_failed")
            return false
        end

        local provider = (it.TranslateProviderCombo and it.TranslateProviderCombo.CurrentText) or state.translate.provider or TRANSLATE_PROVIDER_AZURE_LABEL
        state.translate.provider = provider
        local providerConfig = ChatProviders.getByLabel(provider)
        local translateFunc
        if provider == TRANSLATE_PROVIDER_AZURE_LABEL then
            translateFunc = Azure.translateEntries
        elseif provider == TRANSLATE_PROVIDER_DEEPL_LABEL then
            translateFunc = DeepL.translateEntries
        elseif provider == TRANSLATE_PROVIDER_OPENAI_LABEL then
            translateFunc = OpenAIService.translateEntries
        elseif providerConfig then
            translateFunc = function(list, label)
                return ChatProviders.translateEntries(providerConfig, list, label)
            end
        else
            local message = resolveTranslateError("provider_not_supported")
            setTranslateStatus("failed", message)
            updateRetryButtonState()
            return false
        end

        local targetLabel = (it.TranslateTargetCombo and it.TranslateTargetCombo.CurrentText) or state.translate.targetLabel
        local resolvedLabel, _, targetErr = resolveTargetSelection(provider, targetLabel)
        if not resolvedLabel then
            setTranslateStatus("failed", resolveTranslateError(targetErr or "missing_target_lang"))
            updateRetryButtonState()
            return false
        end
        targetLabel = resolvedLabel

        local originalConcurrency = state.translate.concurrency
        state.translate.concurrency = 3

        state.translate.busy = true
        setTranslateControlsEnabled(false)

        local ok, totalTokens, err = pcall(translateFunc, subset, targetLabel)

        state.translate.concurrency = originalConcurrency
        state.translate.busy = false
        setTranslateControlsEnabled(true)

        if not ok then
            local reasonKey = totalTokens or "translation_failed"
            local en, cn = resolveTranslateErrorPair(reasonKey)
            notifyTranslateStatus("failed", { en }, { cn })
            setTranslateStatus("failed", resolveTranslateError(reasonKey))
            updateRetryButtonState()
            return false
        end

        if not totalTokens then
            local reasonKey = err or "translation_failed"
            local en, cn = resolveTranslateErrorPair(reasonKey)
            notifyTranslateStatus("failed", { en }, { cn })
            setTranslateStatus("failed", resolveTranslateError(reasonKey))
            updateRetryButtonState()
            return false
        end

        state.translate.totalTokens = (state.translate.totalTokens or 0) + (totalTokens or 0)
        applyTranslateSuccessStatus(subset, state.translate.totalTokens, true)
        updateRetryButtonState()
        return true
    end


Translate.setStatus = setTranslateStatus
Translate.resolveError = resolveTranslateError
Translate.handleVerify = handleOpenAIVerify
Translate.handleAddModel = handleOpenAIAddModel
Translate.handleDeleteModel = handleOpenAIDeleteModel
Translate.refreshStatus = refreshTranslateStatus
Translate.setControlsEnabled = setTranslateControlsEnabled
Translate.normalizeTree = normalizeTranslateTree
Translate.resetState = resetTranslateState
Translate.ensureEntries = ensureTranslateEntries
Translate.initTab = initTranslateTab
Translate.performWorkflow = performTranslateWorkflow
Translate.translateSingleEntry = translateSingleEntry
Translate.updateTreeRow = updateTranslateTreeRow
Translate.updateOriginalRow = updateTranslateOriginalRow
Translate.retryFailedEntries = retryFailedEntries
-- Translate Tab: (moved) Export Translated Subtitles
function Subtitle.exportTranslatedSubtitles()
    local entries = state.translate.entries or {}
    if #entries == 0 then
        Translate.setStatus("no_entries")
        return false
    end
    if not state.timeline then
        Translate.setStatus("failed", Translate.resolveError("no_timeline"))
        UI.updateStatus("no_timeline")
        return false
    end

    Translate.setStatus("updating")
    local exportEntries = {}
    for idx, entry in ipairs(entries) do
        local translation = Utils.trim(entry.translation or "")
        if translation == "" then
            translation = entry.original or ""
        end
        exportEntries[idx] = {
            startFrame = entry.startFrame,
            endFrame = entry.endFrame,
            text = translation,
        }
    end

    local tempPath = Subtitle.nextSrtPathForTimeline(state.timeline)
    local ok, err = Subtitle.writeSrt(exportEntries, tempPath, state.startFrame or 0, state.fps or 24.0)
    if not ok then
        local message = UI.messageString(err or "write_failed") or Translate.resolveError(err or "translation_failed")
        Translate.setStatus("failed", message)
        UI.updateStatus(err or "write_failed")
        return false
    end

    local success, importErr = Subtitle.importSrtToTimeline(tempPath)
    if not success then
        local message = UI.messageString(importErr or "import_failed") or Translate.resolveError(importErr or "translation_failed")
        Translate.setStatus("failed", message)
        UI.updateStatus(importErr or "import_failed")
        return false
    end

    Translate.setStatus("updated")
    return true
end

-- Subtitle Domain: Timeline IO / SRT / Jump
-- ==============================================================
function Subtitle.refreshFromTimeline()
    local function handleStage(stage, a)
        if stage == "loading_tracks" then
            UI.updateStatus("loading_tracks")
        elseif stage == "loading_collect" then
            local total = tonumber(a) or 0
            if total < 0 then total = 0 end
            UI.updateStatus("loading_collect", total)
        elseif stage == "loading_sorting" then
            UI.updateStatus("loading_sorting")
        elseif stage == "loading_empty" then
            UI.updateStatus("loading_empty")
        end
    end

    local function handleProgress(done, total)
        if total and total > 0 then
            local clamped = done
            if clamped > total then
                clamped = total
            elseif clamped < 0 then
                clamped = 0
            end
            UI.updateStatus("loading_progress", clamped, total)
        else
            UI.updateStatus("loading_started")
        end
    end

    local ok, err = Subtitle.collectSubtitles({
        onProgress = handleProgress,
        onStage = handleStage,
    })
    if not ok then
        UI.updateStatus(err or "cannot_read_subtitles")
        state.entries = {}
        state.lastFollowIndex = nil
        if it.SubtitleTree then
            UI.withUpdatesSuspended(it.SubtitleTree, function()
                it.SubtitleTree:Clear()
            end)
        end
        state.highlightedRows = {}
        state.stickyHighlights = {}
        state.findMatches = nil
        state.findIndex = nil
        state.currentMatchPos = nil
        state.currentMatchHighlight = nil
        UI.setEditorText("")
        Translate.resetState()
        updatePlayheadTimerState(false)
        return false
    end
    Translate.resetState()
    UI.populateTree()
    UI.updateStatus("loaded_count", #state.entries)
    if state.autoFollow then
        state.lastFollowIndex = nil
        UI.followPlayheadTick()
    end
    updatePlayheadTimerState(false)
    return true
end

function UI.setRowHighlight(rowIndex, color)
    if not it.SubtitleTree then
        return
    end
    local item = it.SubtitleTree:TopLevelItem(rowIndex - 1)
    if not item then
        return
    end
    local targetColor = color or transparentColor
    item.BackgroundColor[2] = targetColor
    if color then
        state.highlightedRows[rowIndex] = true
    else
        state.highlightedRows[rowIndex] = nil
    end
end

if it.MainTabs then
    local initialTabs = uiText.cn.tabs or { "", "", "" }
    for _, title in ipairs(initialTabs) do
        it.MainTabs:AddTab(title)
    end
    if it.MainStack then
        it.MainTabs.CurrentIndex = 0
        it.MainStack.CurrentIndex = 0
    end
end

Translate.initTab()

function UI.refreshUpdateNotice()
    if not it.UpdateLabel then
        return
    end
    local info = state.updateInfo
    if type(info) ~= "table" then
        it.UpdateLabel.Text = ""
        it.UpdateLabel.Visible = false
        return
    end
    local lang = UI.currentLanguage()
    local text
    if lang == "en" then
        text = info.en or info.cn
    else
        text = info.cn or info.en
    end
    text = Utils.trim(text or "")
    if text ~= "" then
        it.UpdateLabel.Text = text
        it.UpdateLabel.Visible = true
        return
    end
    it.UpdateLabel.Text = ""
    it.UpdateLabel.Visible = false
end

function UI.buildUpdateMessage(payload, lang, latest, current)
    local messageKey = lang == "cn" and "cn" or "en"
    local baseText = nil
    if type(payload) == "table" then
        baseText = payload[messageKey] or payload[lang == "cn" and "zh" or nil]
    end
    local parts = {}
    baseText = Utils.trim(baseText or "")
    if baseText ~= "" then
        table.insert(parts, baseText)
    end
    local readableCurrent = Utils.trim(current or "")
    if readableCurrent == "" then
        readableCurrent = (lang == "cn") and "" or "unknown"
    end
    local line
    if lang == "cn" then
        line = string.format("%s  %s", readableCurrent,latest)
    else
        line = string.format("Update: %s  %s, Download on your purchase page.", readableCurrent,latest)
    end
    table.insert(parts, line)
    return table.concat(parts, "\n")
end

function App.checkForUpdates()
    local ok, result = pcall(Services.supabaseCheckUpdate, SCRIPT_NAME)
    if not ok then
        print(string.format("[Update] Check failed: %s", tostring(result)))
        return
    end
    if type(result) ~= "table" then
        return
    end
    local latest = Utils.trim(tostring(result.latest or ""))
    if latest == "" then
        return
    end
    local current = Utils.trim(tostring(SCRIPT_VERSION or ""))
    if latest == current then
        return
    end
    local info = {
        latest = latest,
        current = current,
        cn = UI.buildUpdateMessage(result, "cn", latest, current),
        en = UI.buildUpdateMessage(result, "en", latest, current),
    }
    state.updateInfo = info
    UI.refreshUpdateNotice()
    local readableCurrent = current ~= "" and current or "unknown"
    print(string.format("[Update] Latest version %s available (current %s).", latest, readableCurrent))
end

function UI.updateStatus(key, ...)
    state.lastStatusKey = key
    state.lastStatusArgs = { ... }

    local text
    if not key then
        text = ""
    else
        local template = UI.messageString(key)
        if template then
            text = string.format(template, ...)
        else
            text = tostring(key)
            if select('#', ...) > 0 then
                text = string.format(text, ...)
            end
        end
    end

    if it.StatusLabel then
        it.StatusLabel.Text = text or ""
    end
    local loadingLabel = state.loadingLabel
    if loadingLabel and type(loadingLabel) == "userdata" then
        pcall(function()
            loadingLabel.Text = text or ""
        end)
    end
end

-- ==============================================================
-- Editor Tab: Controller & Helpers (find/replace/jump/update)
-- ==============================================================
function UI.setEditorText(text)
    UI.withEditorProgrammatic(function()
        it.SubtitleEditor.Text = text or ""
    end)
end

function UI.clearFindHighlights(preserveIfStillMatch)
    local current = state.currentMatchHighlight
    if not current then return end
    state.currentMatchHighlight = nil

    local preserve = false
    if preserveIfStillMatch and state.findQuery and state.findQuery ~= "" then
        local entry = state.entries[current]
        local text = entry and entry.text or ""
        preserve = text:find(state.findQuery, 1, true) ~= nil
    end

    if preserve or state.stickyHighlights[current] then
        UI.setRowHighlight(current, findHighlightColor)
    else
        UI.setRowHighlight(current, nil)
    end
end

--  
-- findHighlightColor
function UI.clearAllFindHighlights()
    local toClear = {}
    for index in pairs(state.highlightedRows or {}) do
        if not state.stickyHighlights[index] then
            table.insert(toClear, index)
        end
    end
    if it.SubtitleTree then
        UI.withUpdatesSuspended(it.SubtitleTree, function()
            for _, index in ipairs(toClear) do
                UI.setRowHighlight(index, nil)
            end
        end)
    else
        for _, index in ipairs(toClear) do
            UI.setRowHighlight(index, nil)
        end
    end
    state.currentMatchHighlight = nil
    state.currentMatchPos = nil
end


function Subtitle.performTimelineJump(entry)
    if not state.timeline then
        return
    end
    local resolve = state.resolve
    if not resolve then
        return
    end
    local currentPage = resolve:GetCurrentPage()
    if currentPage ~= "cut" and currentPage ~= "edit" and currentPage ~= "color" and currentPage ~= "fairlight" and currentPage ~= "deliver" then
        resolve:OpenPage("edit")
    end
    local timecode = Subtitle.framesToTimecode(entry.startFrame, state.fps_frac or state.fps or {num=24,den=1})
    local ok = state.timeline:SetCurrentTimecode(timecode)
    if not ok then
        UI.updateStatus("jump_failed")
    else
        --UI.updateStatus("jump_success", timecode)
    end
end



local function clearTreeSelectionNodes(widget)
    if not widget or not widget.SelectedItems then
        return
    end
    local selected = widget:SelectedItems()
    if not selected or type(selected) ~= "table" then
        return
    end
    for _, node in ipairs(selected) do
        if node and node.Selected ~= nil then
            node.Selected = false
        end
    end
end

local function selectTreeNode(widget, index, opts)
    if not widget or not widget.TopLevelItem then
        return nil
    end
    local item = widget:TopLevelItem(index - 1)
    if not item then
        return nil
    end
    opts = opts or {}
    if opts.clear ~= false then
        clearTreeSelectionNodes(widget)
    end
    item.Selected = true
    local shouldScroll = opts.scroll
    if shouldScroll == nil then
        shouldScroll = true
    end
    if shouldScroll and widget.ScrollToItem then
        widget:ScrollToItem(item)
    end
    return item
end

--  Tree 
function UI.clearTreeSelection()
    clearTreeSelectionNodes(it.SubtitleTree)
end

local function cloneOptionTable(src)
    if type(src) ~= "table" then
        return {}
    end
    local copy = {}
    for k, v in pairs(src) do
        copy[k] = v
    end
    return copy
end

local function focusEntryRow(index, opts)
    local entry = state.entries and state.entries[index]
    if not entry then
        return nil
    end
    opts = opts or {}
    local includeEdit = opts.includeEdit
    if includeEdit == nil then
        includeEdit = true
    end
    local includeTranslate = opts.includeTranslate == true
    local jumpTimeline = opts.jumpTimeline
    if jumpTimeline == nil then
        jumpTimeline = true
    end
    local scrollEdit = opts.scrollEdit
    if scrollEdit == nil then
        scrollEdit = true
    end
    local scrollTranslate = opts.scrollTranslate
    if scrollTranslate == nil then
        scrollTranslate = true
    end
    local clearEdit = opts.clearEdit
    if clearEdit == nil then
        clearEdit = true
    end
    local clearTranslate = opts.clearTranslate
    if clearTranslate == nil then
        clearTranslate = true
    end
    local updateTranslateEditor = opts.updateTranslateEditor
    if updateTranslateEditor == nil then
        updateTranslateEditor = true
    end

    if includeEdit and it.SubtitleTree then
        state.suppressTreeSelection = true
        selectTreeNode(it.SubtitleTree, index, { scroll = scrollEdit, clear = clearEdit })
        state.suppressTreeSelection = false
    end

    if includeEdit then
        state.selectedIndex = index
        state.lastFollowIndex = index
        UI.setEditorText(entry.text or "")
    else
        state.lastFollowIndex = index
    end

    local tState = state.translate
    if includeTranslate and tState and tState.entries then
        local tEntry = tState.entries[index]
        if tEntry then
            tState.selectedIndex = index
            if it.TranslateSubtitleTree then
                selectTreeNode(it.TranslateSubtitleTree, index, { scroll = scrollTranslate, clear = clearTranslate })
            end
            if updateTranslateEditor and it.TranslateSubtitleEditor then
                UI.withTranslateProgrammatic(function()
                    it.TranslateSubtitleEditor.Text = tEntry.translation or ""
                end)
            end
            if it.TranslateSelectedButton then
                it.TranslateSelectedButton.Enabled = not (tState.busy)
            end
        end
    end

    if jumpTimeline then
        Subtitle.performTimelineJump(entry)
        state.manualJumpFrame = entry.startFrame or 0
        state.manualJumpAt = os.clock()
    end

    return entry
end

local function selectTranslateRow(index, opts)
    if not state.translate then
        return
    end
    local config = {}
    if type(opts) == "boolean" then
        config.jumpTimeline = opts
    elseif type(opts) == "table" then
        config = cloneOptionTable(opts)
        if opts.jump ~= nil then
            config.jumpTimeline = opts.jump == true
        end
        if opts.scroll ~= nil then
            config.scrollTranslate = opts.scroll ~= false
        end
    end
    if config.jumpTimeline == nil then
        config.jumpTimeline = false
    end
    if config.includeEdit == nil then
        config.includeEdit = true
    end
    if config.scrollTranslate == nil then
        config.scrollTranslate = true
    end
    config.includeTranslate = true
    focusEntryRow(index, config)
end

Translate.selectRow = selectTranslateRow

-- 
function UI.jumpToEntry(index, doTimeline, opts)
    local config = cloneOptionTable(opts)
    if doTimeline == false then
        config.jumpTimeline = false
    elseif config.jumpTimeline == nil then
        config.jumpTimeline = true
    end
    if config.includeEdit == nil then
        config.includeEdit = true
    end
    return focusEntryRow(index, config)
end

function UI.countOccurrences(s, q)
    if not s or not q or q == "" then return 0 end
    local i, c = 1, 0
    while true do
        local a, b = string.find(s, q, i, true) -- 
        if not a then break end
        c, i = c + 1, b + 1
    end
    return c
end

function UI.refreshFindMatches()
    local query = it.FindInput.Text or ""
    state.findQuery = query

    UI.clearAllFindHighlights()
    state.findMatches, state.findIndex = nil, nil
    state.currentMatchPos = nil

    if query == "" then
        UI.updateStatus("enter_find_text")
        return false
    end

    local matches = {}
    local rowsMatched, occTotal = 0, 0
    for index, entry in ipairs(state.entries) do
        local text = entry.text or ""
        local c = UI.countOccurrences(text, query)
        if c > 0 then
            rowsMatched = rowsMatched + 1
            occTotal = occTotal + c
            matches[#matches + 1] = index
        elseif not state.stickyHighlights[index] and state.highlightedRows[index] then
            UI.setRowHighlight(index, nil)
        end
    end

    if rowsMatched == 0 then
        UI.updateStatus("no_find_results")
        state.findMatches = {}
        state.findRows, state.findOcc = 0, 0
        state.currentMatchPos = nil
        return false
    end

    if it.SubtitleTree then
        UI.withUpdatesSuspended(it.SubtitleTree, function()
            for _, index in ipairs(matches) do
                UI.setRowHighlight(index, findHighlightColor)
            end
        end)
    else
        for _, index in ipairs(matches) do
            UI.setRowHighlight(index, findHighlightColor)
        end
    end

    state.findMatches = matches
    state.findRows, state.findOcc = rowsMatched, occTotal
    state.currentMatchPos = nil
    UI.updateStatus("matches_rows_occ", rowsMatched, occTotal)
    return true
end


function UI.ensureFindMatches()
    local query = it.FindInput.Text or ""
    if query == "" then
        UI.updateStatus("enter_find_text")
        return false
    end
    if query ~= state.findQuery or not state.findMatches then
        return UI.refreshFindMatches()
    end
    if state.findMatches and #state.findMatches > 0 then
        return true
    end
    return UI.refreshFindMatches()
end

function UI.gotoNextMatch()
    if not UI.ensureFindMatches() then return nil end
    local matches = state.findMatches or {}
    local count = #matches
    if count == 0 then
        UI.updateStatus("no_find_results")
        return nil
    end

    local sel = state.selectedIndex
    local firstRun = (state.currentMatchPos == nil)  

    local idx
    if not sel then
        idx = 1
    else
        for i, m in ipairs(matches) do
            if (firstRun and m >= sel) or (not firstRun and m > sel) then
                idx = i
                break
            end
        end
        if not idx then idx = 1 end  
    end

    state.currentMatchPos = idx   
    local entryIndex = matches[idx]

    UI.clearFindHighlights(true)
    UI.jumpToEntry(entryIndex, true)
    UI.setRowHighlight(entryIndex, findHighlightColor)
    state.currentMatchHighlight = entryIndex
    UI.updateStatus("match_progress", idx, count)
    return entryIndex
end


function UI.gotoPreviousMatch()
    if not UI.ensureFindMatches() then return nil end
    local matches = state.findMatches or {}
    local count = #matches
    if count == 0 then
        UI.updateStatus("no_find_results")
        return nil
    end

    local sel = state.selectedIndex
    local firstRun = (state.currentMatchPos == nil)

    local idx
    if not sel then
        idx = count
    else
        for i = count, 1, -1 do
            local m = matches[i]
            if (firstRun and m <= sel) or (not firstRun and m < sel) then
                idx = i
                break
            end
        end
        if not idx then idx = count end  
    end

    state.currentMatchPos = idx
    local entryIndex = matches[idx]

    UI.clearFindHighlights(true)
    UI.jumpToEntry(entryIndex, true)
    UI.setRowHighlight(entryIndex, findHighlightColor)
    state.currentMatchHighlight = entryIndex
    UI.updateStatus("match_progress", idx, count)
    return entryIndex
end


function UI.updateTabBarTexts()
    if not it.MainTabs then
        return
    end
    local lang = UI.currentLanguage()
    local pack = uiText[lang]
    local titles = (pack and pack.tabs) or uiText.cn.tabs
    if type(titles) ~= "table" then
        return
    end
    for index, title in ipairs(titles) do
        it.MainTabs:SetTabText(index - 1, title)
    end
end

function UI.applyLanguage(lang)
    if lang ~= "en" then
        lang = "cn"
    end
    state.language = lang

    languageProgrammatic = true
    if it.LangCnCheckBox then
        it.LangCnCheckBox.Checked = (lang == "cn")
        it.LangCnCheckBox.Text = UI.uiString("lang_cn")
    end
    if it.LangEnCheckBox then
        it.LangEnCheckBox.Checked = (lang == "en")
        it.LangEnCheckBox.Text = UI.uiString("lang_en")
    end
    languageProgrammatic = false

    UI.updateTabBarTexts()

    if it.FindNextButton then
        it.FindNextButton.Text = UI.uiString("find_next_button")
    end
    if it.FindPreviousButton then
        it.FindPreviousButton.Text = UI.uiString("find_previous_button")
    end
    if it.AllReplaceButton then
        it.AllReplaceButton.Text = UI.uiString("all_replace_button")
    end
    if it.SingleReplaceButton then
        it.SingleReplaceButton.Text = UI.uiString("single_replace_button")
    end
    if it.AutoFollowCheck then
        it.AutoFollowCheck.Text = UI.uiString("auto_follow_check")
        it.AutoFollowCheck.Checked = state.autoFollow and true or false
    end
    if it.RefreshButton then
        it.RefreshButton.Text = UI.uiString("refresh_button")
    end
    if it.UpdateSubtitleButton then
        it.UpdateSubtitleButton.Text = UI.uiString("update_button")
    end
    if it.FindInput then
        it.FindInput.PlaceholderText = UI.uiString("find_placeholder")
    end
    if it.ReplaceInput then
        it.ReplaceInput.PlaceholderText = UI.uiString("replace_placeholder")
    end
    if it.SubtitleEditor then
        it.SubtitleEditor.PlaceholderText = UI.uiString("editor_placeholder")
    end
    if it.CopyrightButton then
        it.CopyrightButton.Text = UI.uiString("copyright")
    end
    if it.DonationButton then
        it.DonationButton.Text = UI.uiString("donation")
    end
    if it.TranslateConcurrencyLabel then
        it.TranslateConcurrencyLabel.Text = UI.uiString("concurrency_label")
    end
    populateConcurrencyCombo(state.translate.concurrency or DEFAULT_TRANSLATE_CONCURRENCY)
    if it.AzureConfigLabel then
        it.AzureConfigLabel.Text = UI.uiString("azure_config_label")
    end
    if it.AzureConfigButton then
        it.AzureConfigButton.Text = UI.uiString("azure_config_button")
    end
    if it.DeepLConfigLabel then
        it.DeepLConfigLabel.Text = UI.uiString("deepl_config_label")
    end
    if it.DeepLConfigButton then
        it.DeepLConfigButton.Text = UI.uiString("deepl_config_button")
    end
    if it.OpenAIFormatConfigLabel then
        it.OpenAIFormatConfigLabel.Text = UI.uiString("openai_config_label")
    end
    if it.OpenAIFormatConfigButton then
        it.OpenAIFormatConfigButton.Text = UI.uiString("openai_config_button")
    end

    if it.TranslateProviderLabel then
        it.TranslateProviderLabel.Text = UI.uiString("translate_provider_label")
    end
    if it.TranslateTargetLabel then
        it.TranslateTargetLabel.Text = UI.uiString("translate_target_label")
    end
    if it.TranslateProviderCombo then
        it.TranslateProviderCombo.PlaceholderText = UI.uiString("translate_provider_placeholder")
    end
    if it.TranslateTargetCombo then
        it.TranslateTargetCombo.PlaceholderText = UI.uiString("translate_target_placeholder")
    end
    refreshTranslateTargetCombo(state.translate.provider, state.translate.targetLabel, state.translate.targetCode)
    if it.TranslateTransButton then
        it.TranslateTransButton.Text = UI.uiString("translate_trans_button")
    end
    if it.TranslateSelectedButton then
        it.TranslateSelectedButton.Text = UI.uiString("translate_selected_button")
        it.TranslateSelectedButton.Enabled = state.translate.selectedIndex ~= nil and not state.translate.busy
    end
    if it.TranslateRetryFailedButton then
        it.TranslateRetryFailedButton.Text = UI.uiString("translate_retry_failed_button")
        updateRetryButtonState()
    end
    if it.TranslateUpdateSubtitleButton then
        it.TranslateUpdateSubtitleButton.Text = UI.uiString("translate_update_button")
    end
    if it.TranslateSubtitleEditor then
        it.TranslateSubtitleEditor.PlaceholderText = UI.uiString("translate_editor_placeholder")
    end
    Translate.normalizeTree()
    Translate.refreshStatus()

    UI.refreshUpdateNotice()

    Azure.refreshConfigTexts()
    DeepL.refreshConfigTexts()
    OpenAIService.refreshConfigTexts()

    if it.SubtitleTree then
        it.SubtitleTree:SetHeaderLabels(UI.currentHeaders())
        it.SubtitleTree.ColumnWidth[0] = 50
        it.SubtitleTree.ColumnWidth[1] = 110
        it.SubtitleTree.ColumnWidth[2] = 360
    end

    local args = state.lastStatusArgs or {}
    UI.updateStatus(state.lastStatusKey, unpack(args))
end

function UI.setLanguage(lang)
    UI.applyLanguage(lang)
end

function UI.clearHighlights()
    if it.SubtitleTree then
        local toClear = {}
        for index in pairs(state.highlightedRows or {}) do
            table.insert(toClear, index)
        end
        UI.withUpdatesSuspended(it.SubtitleTree, function()
            for _, index in ipairs(toClear) do
                UI.setRowHighlight(index, nil)
            end
        end)
    else
        for index in pairs(state.highlightedRows or {}) do
            UI.setRowHighlight(index, nil)
        end
    end
    state.currentMatchHighlight = nil
    state.stickyHighlights = {}   
    state.highlightedRows = {}
    state.currentMatchPos = nil
end

function UI.populateTree(suppressStatus)
    state.selectedIndex = nil
    state.lastFollowIndex = nil
    state.findMatches = nil
    state.findIndex = nil
    state.currentMatchPos = nil
    state.currentMatchHighlight = nil
    state.stickyHighlights = {}
    state.highlightedRows = {}
    UI.setEditorText("")

    if it.SubtitleTree then
        UI.withUpdatesSuspended(it.SubtitleTree, function()
            it.SubtitleTree:Clear()
            it.SubtitleTree:SetHeaderLabels(UI.currentHeaders())
            it.SubtitleTree.ColumnWidth[0] = 50
            it.SubtitleTree.ColumnWidth[1] = 110
            it.SubtitleTree.ColumnWidth[2] = 360
            for index, entry in ipairs(state.entries) do
                local item = it.SubtitleTree:NewItem()
                item.Text[0] = tostring(index)
                local startDisplay = entry.startText or Subtitle.framesToTimecode(entry.startFrame, state.fps) or ""
                local endDisplay = entry.endText or Subtitle.framesToTimecode(entry.endFrame, state.fps) or ""
                item.Text[1] = string.format(" %s\n %s", startDisplay, endDisplay)
                item.Text[2] = entry.text or ""
                it.SubtitleTree:AddTopLevelItem(item)
            end
        end)
    end

    if not suppressStatus then
        UI.updateStatus("current_total", #state.entries)
    end
end

-- ==============================================================
-- Editor Tab: (moved) Replace/Export helpers
function Subtitle.applyReplace()
    --UI.clearHighlights()
    UI.clearFindHighlights()
    local findText = it.FindInput.Text or ""
    local replaceText = it.ReplaceInput.Text or ""
    if findText == "" then
        UI.updateStatus("replace_no_find")
        return
    end
    local pattern = Utils.escapePlainPattern(findText)
    local replaced = 0
    for index, entry in ipairs(state.entries) do
        local newText, changes = (entry.text or ""):gsub(pattern, replaceText)
        if changes > 0 then
            entry.text = newText
            replaced = replaced + changes
            local item = it.SubtitleTree:TopLevelItem(index - 1)
            if item then
                item.Text[2] = newText
            end
            if state.translate and state.translate.entries and state.translate.entries[index] then
                local tEntry = state.translate.entries[index]
                tEntry.original = newText
                Translate.updateOriginalRow(index, newText)
            end
            UI.setRowHighlight(index, findHighlightColor)
            if state.selectedIndex == index then
                UI.setEditorText(newText)
            end
        end
    end
    if replaced == 0 then
        UI.updateStatus("no_replace")
    else
        UI.updateStatus("replace_done", replaced)
    end
    state.findMatches = nil
    state.findIndex = nil
    state.currentMatchPos = nil
end

function Subtitle.replaceSingle()
    local findText = it.FindInput.Text or ""
    if findText == "" then
        UI.updateStatus("replace_no_find")
        return
    end
    if not UI.ensureFindMatches() then return end

    local function currentContains()
        local idx = state.selectedIndex
        if not idx then return false end
        local entry = state.entries[idx]
        return entry and entry.text and entry.text:find(findText, 1, true) ~= nil
    end
    local attempts = 0
    while not currentContains() and attempts < (state.findMatches and #state.findMatches or 0) do
        local jumped = UI.gotoNextMatch()
        attempts = attempts + 1
        if not jumped then break end
    end
    if not currentContains() then
        UI.updateStatus("no_replace")
        return
    end

    local replaceText = it.ReplaceInput.Text or ""
    local pattern = Utils.escapePlainPattern(findText)
    local index = state.selectedIndex
    local entry = state.entries[index]
    local newText, count = (entry.text or ""):gsub(pattern, replaceText)
    if count == 0 then
        UI.updateStatus("no_replace")
        return
    end

    entry.text = newText
    local item = it.SubtitleTree and it.SubtitleTree:TopLevelItem(index - 1)
    if item then
        item.Text[2] = newText
    end
    if state.translate and state.translate.entries and state.translate.entries[index] then
        local tEntry = state.translate.entries[index]
        tEntry.original = newText
        Translate.updateOriginalRow(index, newText)
    end
    UI.setRowHighlight(index, findHighlightColor)
    UI.setEditorText(newText)

    state.stickyHighlights[index] = true

    state.currentMatchHighlight = nil
    UI.refreshFindMatches()
    local updatedMatches = state.findMatches or {}
    if #updatedMatches == 0 then
        UI.updateStatus("match_progress", 0, 0)
        return
    end
    local nextIdx = 1
    for i, matchIndex in ipairs(updatedMatches) do
        if matchIndex > index then
            nextIdx = i
            break
        end
        if i == #updatedMatches then nextIdx = 1 end
    end
    state.currentMatchPos = nextIdx - 1
end

function Subtitle.exportAndImport()
    if not (state and type(state.fps) == "number" and state.fps > 0) then
        Subtitle.collectSubtitles()
    end
    if not state.entries or #state.entries == 0 then
        UI.updateStatus("no_entries_update")
        return
    end
    local tempPath = Subtitle.nextSrtPathForTimeline(state.timeline)
    local ok, err = Subtitle.writeSrt(state.entries, tempPath, state.startFrame or 0, state.fps)
    if not ok then UI.updateStatus(err or "write_failed"); return end
    local success, importErr = Subtitle.importSrtToTimeline(tempPath)
    if not success then UI.updateStatus(importErr or "import_failed"); return end
    Subtitle.refreshFromTimeline()
    UI.updateStatus("updated_success")
end


function win.On.LangCnCheckBox.Clicked(ev)
    if languageProgrammatic then
        return
    end
    UI.setLanguage("cn")
end

function win.On.LangEnCheckBox.Clicked(ev)
    if languageProgrammatic then
        return
    end
    UI.setLanguage("en")
end

function win.On.MainTabs.CurrentChanged(ev)
    if not it.MainStack then return end
    local index = (ev and ev.Index) or 0
    it.MainStack.CurrentIndex = index
    if index == 1 then
        local keep = state.translate and state.translate.selectedIndex  

        Translate.initTab()  

        local t = state.translate
        if not (t and t.populated and t.entries and #t.entries > 0) then
            Translate.ensureEntries(true)  
        end

        if keep then Translate.selectRow(keep) end
    end
end


-- ==============================================================
-- Events: Editor Tab
-- ==============================================================
function win.On.FindInput.TextChanged(ev)
    UI.clearAllFindHighlights()      --  
    state.findMatches = nil
    state.findIndex = nil
    state.currentMatchPos = nil
    state.stickyHighlights = {} 
    state.findQuery = it.FindInput.Text or ""
end

function win.On.FindInput.EditingFinished(ev)
    if UI.refreshFindMatches() then
        UI.updateStatus("matches_rows_occ", state.findRows or 0, state.findOcc or 0)
    end
end


function win.On.FindNextButton.Clicked(ev)
    UI.gotoNextMatch()
end

function win.On.FindPreviousButton.Clicked(ev)
    UI.gotoPreviousMatch()
end

function win.On.AllReplaceButton.Clicked(ev)
    Subtitle.applyReplace()
end

function win.On.SingleReplaceButton.Clicked(ev)
    Subtitle.replaceSingle()
end

function win.On.RefreshButton.Clicked(ev)
    UI.clearHighlights()
    state.findMatches = nil
    state.findIndex = nil
    state.currentMatchPos = nil
    local refreshBtn = it.RefreshButton
    if refreshBtn then
        refreshBtn.Enabled = false
    end
    UI.updateStatus("loading_tracks")
    local ok, result = pcall(Subtitle.refreshFromTimeline)
    if not ok then
        print(string.format("[Subtitle] Refresh failed: %s", tostring(result)))
        UI.updateStatus("cannot_read_subtitles")
    end
    if refreshBtn then
        refreshBtn.Enabled = true
    end
end

function win.On.UpdateSubtitleButton.Clicked(ev)
    Subtitle.exportAndImport()
end

function win.On.DonationButton.Clicked(ev)
    if UI.currentLanguage() == "cn" then
        Utils.openExternalUrl(SCRIPT_TAOBAO_URL)
    else
        Utils.openExternalUrl(SCRIPT_KOFI_URL)
    end
end

function win.On.SubtitleEditor.TextChanged(ev)
    if editorProgrammatic then
        return
    end
    local index = state.selectedIndex
    if not index then
        return
    end
    local entry = state.entries[index]
    if not entry then
        return
    end
    local newText = it.SubtitleEditor.PlainText or it.SubtitleEditor.Text or ""
    entry.text = newText
    local item = it.SubtitleTree and it.SubtitleTree:TopLevelItem(index - 1)
    if item then
        item.Text[2] = newText
    end
    if state.translate and state.translate.entries and state.translate.entries[index] then
        local tEntry = state.translate.entries[index]
        tEntry.original = newText
        Translate.updateOriginalRow(index, newText)
    end
end

function win.On.SubtitleTree.ItemClicked(ev)
    if state.suppressTreeSelection then
        return
    end
    local item = it.SubtitleTree and it.SubtitleTree:CurrentItem()
    if not item then
        return
    end
    local index = tonumber(item.Text[0] or "")
    if not index then
        return
    end
    UI.jumpToEntry(index, true)
end


-- ==============================================================
-- Events: Config Tab
-- ==============================================================
function win.On.CopyrightButton.Clicked(ev)
    local preferEnglish = false
    if it.LangEnCheckBox and it.LangEnCheckBox.Checked then
        preferEnglish = true
    elseif state.language == "en" then
        preferEnglish = true
    end
    local targetUrl = preferEnglish and SCRIPT_KOFI_URL or SCRIPT_TAOBAO_URL
    Utils.openExternalUrl(targetUrl)
end

function win.On.AzureConfigButton.Clicked(ev)
    Azure.openConfigWindow()
end

function win.On.DeepLConfigButton.Clicked(ev)
    DeepL.openConfigWindow()
end

function win.On.OpenAIFormatConfigButton.Clicked(ev)
    OpenAIService.openConfigWindow()
end

Azure.refreshConfigTexts()
Azure.syncConfigControls()
DeepL.refreshConfigTexts()
DeepL.syncConfigControls()
OpenAIService.refreshConfigTexts()
OpenAIService.syncOpenAIConfigControls()

if azureConfigWin then
    function azureConfigWin.On.AzureConfirm.Clicked(ev)
        Azure.closeConfigWindow()
    end
    function azureConfigWin.On.AzureConfigWin.Close(ev)
        Azure.closeConfigWindow()
    end
    function azureConfigWin.On.AzureRegisterButton.Clicked(ev)
        Utils.openExternalUrl(AZURE_REGISTER_URL)
    end
end

if deeplConfigWin then
    function deeplConfigWin.On.DeepLConfirm.Clicked(ev)
        DeepL.closeConfigWindow()
    end
    function deeplConfigWin.On.DeepLConfigWin.Close(ev)
        DeepL.closeConfigWindow()
    end
    function deeplConfigWin.On.DeepLRegisterButton.Clicked(ev)
        Utils.openExternalUrl(DEEPL_REGISTER_URL)
    end
end

if openAIConfigWin then
    function openAIConfigWin.On.OpenAIFormatConfigWin.Close(ev)
        OpenAIService.closeConfigWindow()
    end

    function openAIConfigWin.On.OpenAIFormatModelCombo.CurrentIndexChanged(ev)
        local combo = openAIConfigItems.OpenAIFormatModelCombo
        local index = ev and ev.Index
        if (not index) and combo then
            index = combo.CurrentIndex
        end
        if type(index) == "number" and index >= 0 then
            state.openaiFormat.selectedIndex = index + 1
            Storage.ensureOpenAIModelList(state.openaiFormat)
            if openAIConfigItems.OpenAIFormatModelName then
                local models = state.openaiFormat.models or {}
                openAIConfigItems.OpenAIFormatModelName.Text = (models[state.openaiFormat.selectedIndex] and models[state.openaiFormat.selectedIndex].name) or ""
            end
        end
    end

    function openAIConfigWin.On.VerifyModel.Clicked(ev)
        Translate.handleVerify()
    end

    function openAIConfigWin.On.ShowAddModel.Clicked(ev)
        OpenAIService.applyConfigFromControls()
        if addModelItems.addOpenAIFormatModelDisplay then
            addModelItems.addOpenAIFormatModelDisplay.Text = ""
        end
        if addModelItems.addOpenAIFormatModelName then
            addModelItems.addOpenAIFormatModelName.Text = ""
        end
        if addModelWin then
            addModelWin:Show()
        end
        openAIConfigWin:Hide()
    end

    function openAIConfigWin.On.DeleteModel.Clicked(ev)
        Translate.handleDeleteModel()
    end
end

if addModelWin then
    function addModelWin.On.AddModelBtn.Clicked(ev)
        Translate.handleAddModel()
    end

    function addModelWin.On.AddModelWin.Close(ev)
        if openAIConfigWin then
            OpenAIService.syncOpenAIConfigControls()
            addModelWin:Hide()
            openAIConfigWin:Show()
        end
    end
end


-- ==============================================================
-- Events: Translate Tab
-- ==============================================================
function win.On.TranslateSubtitleTree.ItemClicked(ev)
    if not it.TranslateSubtitleTree then
        return
    end
    local item = it.TranslateSubtitleTree:CurrentItem()
    if not item then
        return
    end
    local index = tonumber(item.Text[0] or "")
    if not index then
        return
    end
    Translate.selectRow(index, true)
end

function win.On.TranslateSubtitleEditor.TextChanged(ev)
    if translateEditorProgrammatic then
        return
    end
    local idx = state.translate.selectedIndex
    if not idx then
        return
    end
    local entry = state.translate.entries and state.translate.entries[idx]
    if not entry then
        return
    end
    local text = (it.TranslateSubtitleEditor and (it.TranslateSubtitleEditor.PlainText or it.TranslateSubtitleEditor.Text)) or ""
    
    -- 
    local originalText = entry.translation or ""
    local textChanged = (text ~= originalText)
    
    -- 
    if textChanged then
        entry.translation = text
        Translate.updateTreeRow(idx, text)
        clearTranslateFailure(idx)
    end
    -- 
end

function win.On.TranslateProviderCombo.CurrentIndexChanged(ev)
    if it.TranslateProviderCombo then
        local provider = it.TranslateProviderCombo.CurrentText or state.translate.provider
        state.translate.provider = provider
        refreshTranslateTargetCombo(provider, state.translate.targetLabel, state.translate.targetCode)
    end
end

function win.On.TranslateConcurrencyCombo.CurrentIndexChanged(ev)
    if not it.TranslateConcurrencyCombo then
        return
    end
    local index = it.TranslateConcurrencyCombo.CurrentIndex
    if not index or index < 0 then
        state.translate.concurrency = DEFAULT_TRANSLATE_CONCURRENCY
        setConcurrencyComboSelection(state.translate.concurrency)
        return
    end
    local option = TRANSLATE_CONCURRENCY_OPTIONS[index + 1]
    local value = option and option.value or DEFAULT_TRANSLATE_CONCURRENCY
    state.translate.concurrency = value
    if not option then
        setConcurrencyComboSelection(state.translate.concurrency)
    end
end

function win.On.TranslateTargetCombo.CurrentIndexChanged(ev)
    if it.TranslateTargetCombo then
        local provider = state.translate.provider or TRANSLATE_PROVIDER_AZURE_LABEL
        local index = it.TranslateTargetCombo.CurrentIndex
        state.translate.targetLabel = it.TranslateTargetCombo.CurrentText
        state.translate.targetCode = getTargetCodeFromIndex(provider, index)
    end
end
function win.On.TranslateTransButton.Clicked(ev)
    Translate.performWorkflow()
end

function win.On.TranslateRetryFailedButton.Clicked(ev)
    Translate.retryFailedEntries()
end

function win.On.TranslateSelectedButton.Clicked(ev)
    if state.translate.busy then return end

    local preserveIdx = state.translate and state.translate.selectedIndex
    local tState = state.translate

    if not (tState and tState.populated and (tState.entries and #tState.entries > 0)) then
        Translate.ensureEntries(true)  
        if preserveIdx then Translate.selectRow(preserveIdx) end
    end

    local idx = state.translate.selectedIndex
    if not idx then
        Translate.setStatus("failed", Translate.resolveError("no_selection"))
        return
    end

    local targetLabel = it.TranslateTargetCombo and it.TranslateTargetCombo.CurrentText or state.translate.targetLabel
    local provider = state.translate.provider or TRANSLATE_PROVIDER_AZURE_LABEL
    local resolvedLabel, _, targetErr = resolveTargetSelection(provider, targetLabel)
    if not resolvedLabel then
        Translate.setStatus("failed", Translate.resolveError(targetErr or "missing_target_lang"))
        return
    end
    targetLabel = resolvedLabel

    state.translate.busy = true
    Translate.setControlsEnabled(false)
    local ok, err = pcall(Translate.translateSingleEntry, idx, targetLabel)
    state.translate.busy = false
    Translate.setControlsEnabled(true)

    if not ok then
        Translate.setStatus("failed", Translate.resolveError(err or "translation_failed"))
    end
end


function win.On.TranslateUpdateSubtitleButton.Clicked(ev)
    if state.translate.busy then
        return
    end
    if Subtitle.exportTranslatedSubtitles and Subtitle.exportTranslatedSubtitles() then
        if Subtitle.refreshFromTimeline() then
            Translate.setStatus("updated")
        end
    end
end

function win.On.SubtitleUtilityWin.Close(ev)
    if playheadTimer and playheadTimer.Stop then
        pcall(function()
            playheadTimer:Stop()
        end)
    end
    OpenAIService.applyConfigFromControls()
    Azure.applyConfigFromControls()
    DeepL.applyConfigFromControls()
    Storage.ensureOpenAIModelList(state.openaiFormat)
    local selectedModel = Storage.getOpenAISelectedModel(state.openaiFormat)
    local settingsPayload = {
        TranslateProviderCombo = state.translate and state.translate.provider or "",
        TranslateTargetCombo = state.translate and state.translate.targetLabel or "",
        TranslateConcurrencyCombo = state.translate and state.translate.concurrency or DEFAULT_TRANSLATE_CONCURRENCY,
        AzureRegion = state.azure and state.azure.region or "",
        AzureApiKey = state.azure and state.azure.apiKey or "",
        DeepLApiKey = state.deepl and state.deepl.apiKey or "",
        OpenAIFormatModelCombo = selectedModel and (selectedModel.display or selectedModel.name) or "",
        OpenAIFormatBaseURL = state.openaiFormat and state.openaiFormat.baseUrl or OPENAI_FORMAT_DEFAULT_BASE_URL,
        OpenAIFormatApiKey = state.openaiFormat and state.openaiFormat.apiKey or "",
        OpenAIFormatTemperatureSpinBox = state.openaiFormat and state.openaiFormat.temperature or OPENAI_FORMAT_DEFAULT_TEMPERATURE,
        SystemPromptTxt = state.openaiFormat and state.openaiFormat.systemPrompt or OPENAI_DEFAULT_SYSTEM_PROMPT,
        LangCnCheckBox = it.LangCnCheckBox and it.LangCnCheckBox.Checked or false,
        LangEnCheckBox = it.LangEnCheckBox and it.LangEnCheckBox.Checked or false,
    }
    Storage.saveSettings(settingsFile, settingsPayload, Storage.settingsKeyOrder)
    Storage.saveOpenAIModelStore()
    Subtitle.cleanupTempDir()
    disp:ExitLoop()
end

UI.applyLanguage(state.language)
function App.performInitialLoad()
    App.checkForUpdates()
    Subtitle.refreshFromTimeline()
end
UI.runWithLoading(App.performInitialLoad)
win:Show()
disp:RunLoop()
win:Hide()
