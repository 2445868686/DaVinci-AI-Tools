math.randomseed(os.time())

local json = require("dkjson")
local SEP = package.config:sub(1, 1)
local IS_WINDOWS = (SEP == "\\")
local SCRIPT_KOFI_URL = "https://ko-fi.com/heiba"
local SCRIPT_TAOBAO_URL = "https://shop120058726.taobao.com/"
local FREE_VERION = false
local function join_path(base, rel)
    if base == "" then
        return rel
    end
    if base:sub(-1) == SEP then
        return base .. rel
    end
    return base .. SEP .. rel
end

local function detect_script_dir()
    local source = debug.getinfo(1, "S").source or ""
    if source:sub(1, 1) == "@" then
        source = source:sub(2)
    end
    local pattern = SEP == "\\" and "(.*[\\/])" or "(.*" .. SEP .. ")"
    return source:match(pattern) or "."
end

local SCRIPT_DIR = detect_script_dir()

local App = {}
local httpClient = {}

--
-- 1. 配置模块 (App.Config)
--
do
    local Config = {}

    Config.SCRIPT_NAME    = "DaVinci Batch Render"
    Config.SCRIPT_VERSION = "1.1.3"
    Config.SCRIPT_AUTHOR  = "HEIBA"
    Config.SCRIPT_DIR     = SCRIPT_DIR

    Config.SCREEN_WIDTH, Config.SCREEN_HEIGHT = 1920, 1080
    Config.WINDOW_WIDTH, Config.WINDOW_HEIGHT = 650, 650
    Config.X_CENTER = math.floor((Config.SCREEN_WIDTH - Config.WINDOW_WIDTH) / 2)
    Config.Y_CENTER = math.floor((Config.SCREEN_HEIGHT - Config.WINDOW_HEIGHT) / 2)
    Config.LOADING_WINDOW_WIDTH, Config.LOADING_WINDOW_HEIGHT = 260, 140
    Config.LOADING_X_CENTER = math.floor((Config.SCREEN_WIDTH - Config.LOADING_WINDOW_WIDTH) / 2)
    Config.LOADING_Y_CENTER = math.floor((Config.SCREEN_HEIGHT - Config.LOADING_WINDOW_HEIGHT) / 2)

    Config.MARK_COLOR = "Cyan"
    Config.MARK_TAG = "DaVinciBatchRender"
    Config.DEFAULT_INTERVAL_SECONDS = 30
    Config.DEFAULT_MARK_COUNT = 5
    Config.LOG_MAX_LINES = 400
    Config.CONFIG_DIR = join_path(Config.SCRIPT_DIR, "config")
    Config.SETTINGS_FILE = join_path(Config.CONFIG_DIR, "setting.json")
    Config.TEMP_DIR = join_path(Config.SCRIPT_DIR, "temp")
    Config.SUPABASE_URL = "https://tbjlsielfxmkxldzmokc.supabase.co"
    Config.SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRiamxzaWVsZnhta3hsZHptb2tjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgxMDc3MDIsImV4cCI6MjA3MzY4MzcwMn0.FTgYJJ-GlMcQKOSWu63TufD6Q_5qC_M4cvcd3zpcFJo"
    Config.SUPABASE_TIMEOUT = 5
    Config.QR_PAYPAL_BASE64 = [[
    /9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABkAAD/4QMxaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA5LjEtYzAwMyA3OS45NjkwYTg3ZmMsIDIwMjUvMDMvMDYtMjA6NTA6MTYgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCAyNy4xIChNYWNpbnRvc2gpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjBGNDZCRjQwQ0ZFMzExRjA5M0U2QUVBMDE0OTI2RURFIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjBGNDZCRjQxQ0ZFMzExRjA5M0U2QUVBMDE0OTI2RURFIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6RjAwMkVDN0ZDRjQyMTFGMDkzRTZBRUEwMTQ5MjZFREUiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6RjAwMkVDODBDRjQyMTFGMDkzRTZBRUEwMTQ5MjZFREUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7/7gAmQWRvYmUAZMAAAAABAwAVBAMGCg0AAB0fAABmOAAA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
    ]]
    Config.QR_WECHAT_BASE64 = [[
    /9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABkAAD/4QMxaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA5LjEtYzAwMyA3OS45NjkwYTg3ZmMsIDIwMjUvMDMvMDYtMjA6NTA6MTYgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCAyNy4xIChNYWNpbnRvc2gpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkYwMDJFQzdEQ0Y0MjExRjA5M0U2QUVBMDE0OTI2RURFIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkYwMDJFQzdFQ0Y0MjExRjA5M0U2QUVBMDE0OTI2RURFIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6RjAwMkVDN0JDRjQyMTFGMDkzRTZBRUEwMTQ5MjZFREUiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6RjAwMkVDN0NDRjQyMTFGMDkzRTZBRUEwMTQ5MjZFREUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7/7gAmQWRvYmUAZMAAAAABAwAVBAMGCg0AAB54AABssQAA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
    ]]
    App.Config = Config
end

local SUPABASE_TIMEOUT = App.Config.SUPABASE_TIMEOUT

------------------------------------------------------------------
-- runShellCommand
------------------------------------------------------------------

local runHiddenWindowsCommand, runShellCommand
do
    local okHttps, https = pcall(require, "ssl.https")
    local okLtn12, ltn12 = pcall(require, "ltn12")
    if okHttps and okLtn12 and https and ltn12 then
        httpClient.https = {
            get = function(url, headers, timeout)
                local sinkTable = {}
                local requestHeaders = {}
                if headers then
                    for k, v in pairs(headers) do
                        requestHeaders[k] = v
                    end
                end
                requestHeaders["content-length"] = "0"
                local ok, statusCode, respHeaders, statusLine = https.request({
                    url = url,
                    method = "GET",
                    headers = requestHeaders,
                    sink = ltn12.sink.table(sinkTable),
                    protocol = "tlsv1_2",
                    verify = "none",
                    timeout = timeout or SUPABASE_TIMEOUT,
                })
                if not ok then
                    return nil, statusCode or statusLine or "request_failed"
                end
                local body = table.concat(sinkTable)
                local code = tonumber(statusCode) or tonumber(respHeaders and respHeaders.status) or statusCode
                return body, code
            end,
            postJson = function(url, payload, headers, timeout)
                local sinkTable = {}
                local requestHeaders = {}
                if headers then
                    for k, v in pairs(headers) do
                        requestHeaders[k] = v
                    end
                end
                local bodyStr = payload or ""
                requestHeaders["content-type"] = "application/json"
                requestHeaders["content-length"] = tostring(#bodyStr)
                local ok, statusCode, respHeaders, statusLine = https.request({
                    url = url,
                    method = "POST",
                    headers = requestHeaders,
                    source = ltn12.source.string(bodyStr),
                    sink = ltn12.sink.table(sinkTable),
                    protocol = "tlsv1_2",
                    verify = "none",
                    timeout = timeout or SUPABASE_TIMEOUT,
                })
                if not ok then
                    return nil, statusCode or statusLine or "request_failed"
                end
                local body = table.concat(sinkTable)
                local code = tonumber(statusCode) or tonumber(respHeaders and respHeaders.status) or statusCode
                return body, code
            end
        }
    end
end

do
    if IS_WINDOWS then
        local ok, ffi = pcall(require, "ffi")
        if ok and ffi then
            local kernel32 = ffi.load("kernel32")
            local CP_UTF8 = 65001
            local CREATE_NO_WINDOW = 0x08000000
            local STARTF_USESHOWWINDOW = 0x00000001
            local INFINITE = 0xFFFFFFFF

            ffi.cdef[[
                typedef unsigned short WORD;
                typedef unsigned long DWORD;
                typedef int BOOL;
                typedef void* HANDLE;
                typedef wchar_t* LPWSTR;
                typedef const wchar_t* LPCWSTR;
                typedef void* LPVOID;
                typedef unsigned char BYTE;

                typedef struct _STARTUPINFOW {
                    DWORD cb;
                    LPWSTR lpReserved;
                    LPWSTR lpDesktop;
                    LPWSTR lpTitle;
                    DWORD dwX;
                    DWORD dwY;
                    DWORD dwXSize;
                    DWORD dwYSize;
                    DWORD dwXCountChars;
                    DWORD dwYCountChars;
                    DWORD dwFillAttribute;
                    DWORD dwFlags;
                    WORD wShowWindow;
                    WORD cbReserved2;
                    BYTE *lpReserved2;
                } STARTUPINFOW;

                typedef struct _PROCESS_INFORMATION {
                    HANDLE hProcess;
                    HANDLE hThread;
                    DWORD dwProcessId;
                    DWORD dwThreadId;
                } PROCESS_INFORMATION;

                BOOL CreateProcessW(
                    LPCWSTR lpApplicationName,
                    LPWSTR lpCommandLine,
                    LPVOID lpProcessAttributes,
                    LPVOID lpThreadAttributes,
                    BOOL bInheritHandles,
                    DWORD dwCreationFlags,
                    LPVOID lpEnvironment,
                    LPCWSTR lpCurrentDirectory,
                    STARTUPINFOW *lpStartupInfo,
                    PROCESS_INFORMATION *lpProcessInformation
                );

                DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
                BOOL GetExitCodeProcess(HANDLE hProcess, DWORD *lpExitCode);
                BOOL CloseHandle(HANDLE hObject);
                DWORD GetLastError(void);
                int MultiByteToWideChar(unsigned int CodePage, DWORD dwFlags,
                                        const char *lpMultiByteStr, int cbMultiByte,
                                        wchar_t *lpWideCharStr, int cchWideChar);
            ]]

            local function utf8ToWideBuffer(str)
                local required = kernel32.MultiByteToWideChar(CP_UTF8, 0, str, -1, nil, 0)
                if required == 0 then
                    return nil
                end
                local buffer = ffi.new("wchar_t[?]", required)
                if kernel32.MultiByteToWideChar(CP_UTF8, 0, str, -1, buffer, required) == 0 then
                    return nil
                end
                return buffer
            end

            runHiddenWindowsCommand = function(command)
                local comspec = os.getenv("COMSPEC") or "C:\\Windows\\System32\\cmd.exe"
                local fullCommand = string.format('"%s" /c %s', comspec, command)
                local cmdBuffer = utf8ToWideBuffer(fullCommand)
                if not cmdBuffer then
                    return false, "command_encoding_failed"
                end

                local startupInfo = ffi.new("STARTUPINFOW")
                startupInfo.cb = ffi.sizeof(startupInfo)
                startupInfo.dwFlags = STARTF_USESHOWWINDOW
                startupInfo.wShowWindow = 0 -- SW_HIDE

                local processInfo = ffi.new("PROCESS_INFORMATION")
                local created = kernel32.CreateProcessW(
                    nil,
                    cmdBuffer,
                    nil,
                    nil,
                    false,
                    CREATE_NO_WINDOW,
                    nil,
                    nil,
                    startupInfo,
                    processInfo
                )

                if created == 0 then
                    return false, kernel32.GetLastError()
                end

                kernel32.WaitForSingleObject(processInfo.hProcess, INFINITE)

                local exitCodeArr = ffi.new("DWORD[1]", 0)
                kernel32.GetExitCodeProcess(processInfo.hProcess, exitCodeArr)
                kernel32.CloseHandle(processInfo.hProcess)
                kernel32.CloseHandle(processInfo.hThread)

                return exitCodeArr[0] == 0, exitCodeArr[0]
            end
        end
    end
end

function runShellCommand(command)
    if IS_WINDOWS and type(runHiddenWindowsCommand) == "function" then
        local ok, code = runHiddenWindowsCommand(command)
        if not ok then
            print(string.format("Command failed (%s)", tostring(code)))
        end
        return ok == true
    end

    local res, how, code = os.execute(command)
    if type(res) == "number" then
        return res == 0
    end
    if res == true then
        if how == "exit" then
            return (code or 0) == 0
        end
        return true
    end
    return false
end
------------------------------------------------------------------
-- runShellCommand
------------------------------------------------------------------


--
-- 1.a 语言模块 (App.Locale)
--
do
    local Locale = {
        current = "en",
        strings = {
            en = {
                app_title = App.Config.SCRIPT_NAME,
                tab_batch_render = "Batch Render",
                tab_settings = "Settings",
                add_mark = "Add",
                interval_label = "Interval (s)",
                count_label = "Count",
                base_name_label = "Filename Prefix",
                get_queue = "Load Queue",
                start_render = "Start Render",
                clear_marks = "Remove",
                target_placeholder = "Select output directory",
                browse = "Browse",
                tree_header_index = "Index",
                tree_header_start = "Start",
                tree_header_end = "End",
                tree_header_name = "Name",
                tree_header_status = "Status",
                tree_header_timeline = "Timeline",

                no_timelines_found = "No timelines found in project.",
                timeline_switch_success = "Switched to timeline: %s",
                timeline_disabled = "Timeline disabled",
                language_checkbox = "简体中文",
                lang_cn_label = "简体中文",
                lang_en_label = "English",
                donation_button = "☕ Explore More Features ☕",
                sponsor_label = "If you find this project helpful, consider supporting my work! \nYour support helps me continue development and bring even more exciting features to life! 💡✨",
                loading_updates = "Checking updates...",
                loading_complete = "Ready.",
                status_pending = "Not queued",
                status_queued = "Queued",
                status_waiting = "Waiting",
                status_rendering = "Rendering",
                status_done = "Completed",
                status_failed = "Failed",
                status_unknown = "Unknown",
                log_active_timeline_missing = "Active timeline not found.",
                log_interval_invalid = "Interval must be greater than 0.",
                log_count_invalid = "Count must be at least 2.",
                log_marker_add_failed = "Failed to add marker at frame %d.",
                log_marker_add_success = "Added %d markers with a %d-frame interval.",
                log_need_duration_marker = "Add at least one marker with duration before building segments.",
                log_marker_duration_missing = "Marker %s at %s has no duration; skipped.",
                log_marker_duration_too_short = "Marker %s at %s has duration 1 frame; Alt-drag the marker to stretch the interval.",
                log_segment_skipped = "Segment %s - %s contains no video and was skipped.",
                log_no_valid_segments = "No valid segments detected. Check marker spacing.",
                log_segments_generated = "Generated %d render segments.",
                log_markers_removed = "Removed %d markers created by the script.",
                log_mark_range_failed = "Failed to set in/out range for %s.",
                log_row_status_pattern = "%s: %s",
                log_render_sequence_finished = "Render sequence finished.",
                log_render_env_failed = "Render environment initialization failed: %s",
                log_render_settings_failed = "Failed to configure render settings for %s.",
                log_add_job_failed = "Failed to add render job: %s.",
                log_job_added = "Added render job %s.",
                log_start_job_failed = "Failed to start job %s.",
                log_attempts = "Attempts: %s",
                log_job_started = "Started rendering job %s.",
                log_project_missing = "Active project not found.",
                log_target_dir_required = "Set an output directory before rendering.",
                log_base_name_required = "Set a filename prefix before rendering.",
                log_no_jobs_available = "No render jobs available.",
                log_jobs_prepared = "Prepared %d render jobs.",
                log_render_in_progress = "Rendering already in progress.",
                log_starting_sequential = "Starting sequential render for %d segments.",
                log_sequential_started = "Sequential render started.",
                log_start_render_failed = "Failed to start rendering.",
                log_job_failed_cancel_rest = "Job %s failed; cancelling remaining tasks.",
                log_render_interrupted_stop = "Rendering interrupted; stopping tasks.",
                log_detected_failure_stop = "Detected render failure; stopped all tasks.",
                log_render_interrupted = "Rendering interrupted.",
                log_window_closed = "Window closed.",
                log_dir_picker_unavailable = "Directory picker is not available in this environment.",
                log_dir_selected = "Selected output directory: %s",
                log_queue_required = "Load the render queue first."
            },
            zh = {
                app_title = "DaVinci 批量渲染",
                tab_batch_render = "批量渲染",
                tab_settings = "设置",
                add_mark = "添加",
                interval_label = "间隔(秒)",
                count_label = "数量",
                base_name_label = "文件名前缀",
                get_queue = "获取渲染队列",
                start_render = "开始渲染",
                clear_marks = "删除",
                target_placeholder = "请选择输出目录",
                browse = "浏览",
                tree_header_index = "序号",
                tree_header_start = "开始",
                tree_header_end = "结束",
                tree_header_name = "名称",
                tree_header_status = "状态",
                tree_header_timeline = "时间线",

                no_timelines_found = "项目中未找到时间线。",
                timeline_switch_success = "已切换到时间线：%s",
                timeline_disabled = "时间线已禁用",
                language_checkbox = "简体中文",
                lang_cn_label = "简体中文",
                lang_en_label = "English",
                donation_button = "☕ 探索更多功能 ☕",
                sponsor_label = "如果您觉得这个项目有帮助，请考虑支持我的工作！\n您的支持将帮助我继续开发，并带来更多精彩的功能！💡✨",
                loading_updates = "正在检查更新...",
                loading_complete = "准备就绪",
                status_pending = "等待队列",
                status_queued = "已添加到队列",
                status_waiting = "等待渲染",
                status_rendering = "正在渲染",
                status_done = "渲染完成",
                status_failed = "渲染失败",
                status_unknown = "未知状态",
                log_active_timeline_missing = "未找到当前时间线。",
                log_interval_invalid = "间隔必须大于 0。",
                log_count_invalid = "数量至少为 2。",
                log_marker_add_failed = "在帧 %d 处添加 Mark 失败。",
                log_marker_add_success = "已添加 %d 个 Mark，间隔 %d 帧。",
                log_need_duration_marker = "请至少添加一个带持续时间的 Mark。",
                log_marker_duration_missing = "标记 %s（%s）缺少持续时间，已跳过。",
                log_marker_duration_too_short = "标记 %s（%s）的持续时间只有 1 帧，请按住 Alt 拖动 Mark 调整长度。",
                log_segment_skipped = "区间 %s - %s 内无视频片段，已跳过。",
                log_no_valid_segments = "未生成有效区间，请检查 Mark 间距。",
                log_segments_generated = "已生成 %d 个渲染区间。",
                log_markers_removed = "已移除脚本创建的 %d 个 Mark。",
                log_mark_range_failed = "为 %s 设置 I/O 范围失败。",
                log_row_status_pattern = "%s：%s",
                log_render_sequence_finished = "渲染序列已完成。",
                log_render_env_failed = "渲染环境初始化失败：%s",
                log_render_settings_failed = "为 %s 配置渲染设置失败。",
                log_add_job_failed = "添加渲染任务失败：%s。",
                log_job_added = "已添加渲染任务 %s。",
                log_start_job_failed = "启动任务 %s 失败。",
                log_attempts = "尝试记录：%s",
                log_job_started = "已开始渲染任务 %s。",
                log_project_missing = "未找到当前项目。",
                log_target_dir_required = "渲染前请先设置输出目录。",
                log_base_name_required = "渲染前请先设置文件名前缀。",
                log_no_jobs_available = "没有可渲染的任务。",
                log_jobs_prepared = "已准备 %d 个渲染任务。",
                log_render_in_progress = "渲染已在进行中。",
                log_starting_sequential = "正在启动 %d 个区间的顺序渲染。",
                log_sequential_started = "顺序渲染已启动。",
                log_start_render_failed = "启动渲染失败。",
                log_job_failed_cancel_rest = "任务 %s 失败；正在取消剩余任务。",
                log_render_interrupted_stop = "渲染被中断，正在停止任务。",
                log_detected_failure_stop = "检测到渲染失败，已停止所有任务。",
                log_render_interrupted = "渲染被中断。",
                log_window_closed = "窗口已关闭。",
                log_dir_picker_unavailable = "此环境下无法打开目录选择器。",
                log_dir_selected = "已选择输出目录：%s",
                log_queue_required = "请先加载渲染队列。"
            }
        }
    }

    function Locale:t(key)
        local langTable = self.strings[self.current] or {}
        return langTable[key] or (self.strings.en and self.strings.en[key]) or key
    end

    function Locale:format(key, ...)
        local text = self:t(key)
        if select("#", ...) > 0 then
            local ok, formatted = pcall(string.format, text, ...)
            if ok then
                return formatted
            end
        end
        return text
    end

    function Locale:set_language(lang)
        if self.strings[lang] then
            self.current = lang
        end
    end

    App.Locale = Locale
end

--
-- 2. 核心模块 (App.Core)
--
do
    local Core = {
        initialized = false,
        resolve = nil,
        fusion = nil,
        ui = nil,
        dispatcher = nil,
        projectManager = nil,
        project = nil,
        timeline = nil
    }

    local function init()
        Core.resolve = resolve
        if not Core.resolve and Resolve then
            local ok, res = pcall(Resolve)
            if ok then
                Core.resolve = res
            end
        end

        if not Core.resolve then
            print("[DaVinci Batch Render] 无法获取 Resolve 对象")
            return
        end

        local okFusion, fusionObj = pcall(function()
            return Core.resolve:Fusion()
        end)
        if okFusion then
            Core.fusion = fusionObj
        end
        if not Core.fusion then
            print("[DaVinci Batch Render] 无法获取 Fusion 对象")
            return
        end

        Core.ui = Core.fusion.UIManager
        if not Core.ui then
            print("[DaVinci Batch Render] 无法获取 UIManager")
            return
        end

        if bmd and bmd.UIDispatcher then
            Core.dispatcher = bmd.UIDispatcher(Core.ui)
        end
        if not Core.dispatcher then
            print("[DaVinci Batch Render] 无法创建 UIDispatcher")
            return
        end

        Core.initialized = true
        print(string.format("[%s] 初始化成功", App.Config.SCRIPT_NAME))
    end

    function Core:getProjectManager()
        if not self.projectManager and self.resolve and self.resolve.GetProjectManager then
            self.projectManager = self.resolve:GetProjectManager()
        end
        return self.projectManager
    end

    function Core:getProject()
        local pm = self:getProjectManager()
        if pm then
            self.project = pm:GetCurrentProject()
        end
        return self.project
    end

    function Core:getTimeline()
        local project = self:getProject()
        if project then
            self.timeline = project:GetCurrentTimeline()
        end
        return self.timeline
    end

    init()
    App.Core = Core
end

--
-- 3. 工具模块 (App.Helpers)
--
do
    local Helpers = {}

    local fpsAliases = {
        ["23.976"] = { num = 24000, den = 1001 },
        ["29.97"]  = { num = 30000, den = 1001 },
        ["59.94"]  = { num = 60000, den = 1001 },
        ["47.952"] = { num = 48000, den = 1001 },
        ["119.88"] = { num = 120000, den = 1001 },
    }

    function Helpers:deep_copy(tbl)
        if type(tbl) ~= "table" then return tbl end
        local res = {}
        for k, v in pairs(tbl) do
            if type(v) == "table" then
                res[k] = self:deep_copy(v)
            else
                res[k] = v
            end
        end
        return res
    end

    function Helpers:merge_tables(a, b)
        local res = self:deep_copy(a)
        for k, v in pairs(b or {}) do
            res[k] = v
        end
        return res
    end

    function Helpers:trim(str)
        if type(str) ~= "string" then
            return ""
        end
        return (str:gsub("^%s+", ""):gsub("%s+$", ""))
    end

    function Helpers:url_encode(str)
        if not str then
            return ""
        end
        return tostring(str):gsub("([^%w%-_%.%~])", function(c)
            return string.format("%%%02X", string.byte(c))
        end)
    end

    function Helpers:script_dir()
        return App.Config.SCRIPT_DIR or "."
    end

    function Helpers:join_path(a, b)
        return join_path(a or "", b or "")
    end

    function Helpers:file_exists(path)
        if not path or path == "" then
            return false
        end
        local ok = os.rename(path, path)
        return ok ~= nil
    end

    function Helpers:ensure_dir(path)
        path = self:trim(path or "")
        if path == "" then
            return false
        end
        if self:file_exists(path) then
            return true
        end
        local cmd
        if IS_WINDOWS then
            cmd = string.format('if not exist "%s" mkdir "%s"', path, path)
        else
            cmd = string.format('mkdir -p "%s"', path)
        end
        return runShellCommand(cmd)
    end

    function Helpers:remove_dir(path)
        path = self:trim(path or "")
        if path == "" then
            return
        end
        if IS_WINDOWS then
            runShellCommand(string.format('rmdir /S /Q "%s"', path))
            return
        end
        local escaped = path:gsub("'", "'\\''")
        runShellCommand("rm -rf '" .. escaped .. "'")
    end

    function Helpers:openExternalUrl(url)
        if not url or url == "" then
            return
        end
        if bmd and bmd.openurl then
            local ok, err = pcall(bmd.openurl, url)
            if not ok then
                print("openurl failed: " .. tostring(err))
            end
            return
        end
        if IS_WINDOWS then
            runShellCommand(string.format('start "" "%s"', url))
            return
        end
        local escaped = url:gsub("'", "'\\''")
        if not runShellCommand("open '" .. escaped .. "'") then
            runShellCommand("xdg-open '" .. escaped .. "'")
        end
    end

    function Helpers:read_file(path)
        local file = io.open(path, "rb")
        if not file then
            return nil
        end
        local content = file:read("*a")
        file:close()
        return content
    end

    function Helpers:write_file(path, content)
        local dir = path and path:match("^(.*)[/\\][^/\\]+$")
        if dir then
            self:ensure_dir(dir)
        end
        local file, err = io.open(path, "wb")
        if not file then
            return false, err
        end
        file:write(content or "")
        file:close()
        return true
    end

    function Helpers:read_json(path)
        local data = self:read_file(path)
        if not data or data == "" then
            return nil
        end
        local ok, decoded = pcall(json.decode, data)
        if ok then
            return decoded
        end
        return nil
    end

    function Helpers:write_json(path, tbl)
        local ok, encoded = pcall(json.encode, tbl or {})
        if not ok then
            return false
        end
        return self:write_file(path, encoded)
    end

    function Helpers:split_path(path)
        if type(path) ~= "string" or path == "" then
            return "", ""
        end
        local dir, file = path:match("^(.*[\\/])([^\\/]+)$")
        if not dir then
            return "", path
        end
        return dir, file
    end

    function Helpers:strip_extension(filename)
        if type(filename) ~= "string" then
            return ""
        end
        return filename:gsub("%.[^%.]+$", "")
    end

    function Helpers:get_temp_dir()
        local dir = App.Config.TEMP_DIR or self:join_path(self:script_dir(), "temp")
        self:ensure_dir(dir)
        return dir
    end

    function Helpers:make_temp_path(ext)
        local dir = self:get_temp_dir()
        local suffix = self:trim(ext or "")
        if suffix ~= "" and not suffix:match("^%.") then
            suffix = "." .. suffix
        end
        local seed = tostring(os.time())
        for i = 1, 1000 do
            local candidate = self:join_path(dir, string.format("tmp_%s_%06d%s", seed, i, suffix))
            if not self:file_exists(candidate) then
                return candidate
            end
        end
        return self:join_path(dir, string.format("tmp_%s_%d%s", seed, math.random(999999), suffix))
    end

    function Helpers:safe_number(value)
        local num = tonumber(value)
        if num then return num end
        if type(value) == "string" then
            num = tonumber(value:match("[0-9%.]+"))
        end
        return tonumber(num)
    end

    function Helpers:base64_decode(data)
        data = tostring(data or ""):gsub("[^%w%+/%=]", "")
        local alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
        local output = {}
        local padding = 0
        if data:sub(-2) == "==" then
            padding = 2
        elseif data:sub(-1) == "=" then
            padding = 1
        end
        for i = 1, #data, 4 do
            local n = 0
            for j = 0, 3 do
                local c = data:sub(i + j, i + j)
                if c ~= "" and c ~= "=" then
                    local idx = alphabet:find(c, 1, true)
                    if not idx then
                        error("invalid base64 character")
                    end
                    n = n * 64 + (idx - 1)
                else
                    n = n * 64
                end
            end
            local bytes = string.char(
                math.floor(n / 65536) % 256,
                math.floor(n / 256) % 256,
                n % 256
            )
            table.insert(output, bytes)
        end
        local result = table.concat(output)
        if padding > 0 then
            result = result:sub(1, #result - padding)
        end
        return result
    end

    function Helpers:create_image_from_base64(base64Data, destinationPath)
        local ok, bytes = pcall(function()
            return self:base64_decode(base64Data)
        end)
        if not ok or not bytes then
            return false
        end
        local file, err = io.open(destinationPath, "wb")
        if not file then
            return false, err
        end
        file:write(bytes)
        file:close()
        return true
    end

    function Helpers:httpGet(url, headers, timeout)
        if httpClient.https then
            local body, code = httpClient.https.get(url, headers, timeout)
            if body then return body, code end
        end

        local headerParts = {}
        if headers then
            for k, v in pairs(headers) do
                local cleanValue = tostring(v):gsub('"', '\\"')
                table.insert(headerParts, string.format('-H "%s: %s"', k, cleanValue))
            end
        end
        local maxTime = timeout or SUPABASE_TIMEOUT
        local curlCommand = string.format('curl -sS -m %d %s "%s"', maxTime, table.concat(headerParts, " "), url)
        local sep = package.config:sub(1, 1)

        if sep == "\\" then
            local outPath, err = self:make_temp_path("out")
            if not outPath then return nil, "tmpname_failed:" .. tostring(err) end
            local redirected = string.format('%s > "%s" 2>nul', curlCommand, outPath)
            local ok = runShellCommand and runShellCommand(redirected)
            local file = io.open(outPath, "rb")
            local body = file and file:read("*a") or ""
            if file then file:close() end
            os.remove(outPath)
            if not ok then return nil, "curl_hidden_failed" end
            if body == "" then return nil, "empty_response" end
            return body, nil
        end

        curlCommand = curlCommand .. " 2>/dev/null"
        local pipe = io.popen(curlCommand, "r")
        if not pipe then return nil, "curl_popen_failed" end
        local body = pipe:read("*a") or ""
        pipe:close()
        if body == "" then return nil, "empty_response" end
        return body, nil
    end

    function Helpers:httpPostJson(url, payload, headers, timeout)
        local bodyStr = payload or ""
        if httpClient.https and httpClient.https.postJson then
            local body, code = httpClient.https.postJson(url, bodyStr, headers, timeout)
            if body then return body, code end
        end

        local headerParts, hasContentType = {}, false
        if headers then
            for k, v in pairs(headers) do
                local cleanValue = tostring(v):gsub('"', '\\"')
                table.insert(headerParts, string.format('-H "%s: %s"', k, cleanValue))
                if type(k) == "string" and k:lower() == "content-type" then
                    hasContentType = true
                end
            end
        end
        if not hasContentType then
            table.insert(headerParts, '-H "Content-Type: application/json"')
        end

        local maxTime = timeout or SUPABASE_TIMEOUT
        local sep = package.config:sub(1, 1)

        local tempPayload, err1 = self:make_temp_path("json")
        if not tempPayload then return nil, "tmpname_failed:" .. tostring(err1) end
        local f, err2 = io.open(tempPayload, "wb")
        if not f then
            os.remove(tempPayload)
            return nil, "payload_tmp_open_failed:" .. tostring(err2)
        end
        f:write(bodyStr)
        f:close()

        if sep == "\\" then
            local outputPath, err3 = self:make_temp_path("out")
            if not outputPath then
                os.remove(tempPayload)
                return nil, "tmpname_failed:" .. tostring(err3)
            end

            local curlCommand = string.format(
                'curl -sS -m %d -X POST %s --data-binary "@%s" "%s"',
                maxTime, table.concat(headerParts, " "), tempPayload, url
            )
            local redirected = string.format('%s > "%s" 2>nul', curlCommand, outputPath)
            local ok = runShellCommand and runShellCommand(redirected)

            local of = io.open(outputPath, "rb")
            local body = of and of:read("*a") or ""
            if of then of:close() end
            os.remove(outputPath)
            os.remove(tempPayload)

            if not ok then return nil, "curl_hidden_failed" end
            if body == "" then return nil, "empty_response" end
            return body, nil
        else
            local curlCommand = string.format(
                'curl -sS -m %d -X POST %s --data-binary @%q "%s" 2>/dev/null',
                maxTime, table.concat(headerParts, " "), tempPayload, url
            )
            local pipe = io.popen(curlCommand, "r")
            if not pipe then
                os.remove(tempPayload)
                return nil, "curl_popen_failed"
            end
            local body = pipe:read("*a") or ""
            pipe:close()
            os.remove(tempPayload)
            if body == "" then return nil, "empty_response" end
            return body, nil
        end
    end

    local function gcd(a, b)
        a, b = math.abs(a), math.abs(b)
        while b ~= 0 do
            a, b = b, a % b
        end
        return a
    end

    local function normalize_fraction(num, den)
        if den == 0 then
            return 0, 1
        end
        if den < 0 then
            num, den = -num, -den
        end
        local g = gcd(num, den)
        return math.floor(num / g), math.floor(den / g)
    end

    function Helpers:fps_to_fraction(value)
        if type(value) == "table" and value.num and value.den then
            local num, den = normalize_fraction(value.num, value.den)
            return { num = num, den = den }
        end
        if value == nil then
            return { num = 24, den = 1 }
        end
        if type(value) == "number" then
            for str, frac in pairs(fpsAliases) do
                if math.abs(value - (frac.num / frac.den)) < 1e-3 then
                    return { num = frac.num, den = frac.den }
                end
            end
            if value > 0 then
                return { num = math.floor(value + 0.5), den = 1 }
            end
            return { num = 24, den = 1 }
        end
        local s = tostring(value)
        local alias = fpsAliases[s]
        if alias then
            return { num = alias.num, den = alias.den }
        end
        if s:find("/") then
            local num, den = s:match("^(%d+)%s*/%s*(%d+)$")
            num, den = tonumber(num), tonumber(den)
            if num and den and den ~= 0 then
                local n, d = normalize_fraction(num, den)
                return { num = n, den = d }
            end
        end
        local asNumber = tonumber(s)
        if asNumber then
            return self:fps_to_fraction(asNumber)
        end
        return { num = 24, den = 1 }
    end

    function Helpers:fps_as_float(fpsSpec)
        local frac = self:fps_to_fraction(fpsSpec)
        return frac.num / frac.den
    end

    function Helpers:fps_timebase(fpsSpec)
        local value = self:fps_as_float(fpsSpec)
        return math.max(1, math.floor(value + 0.5))
    end

    function Helpers:frames_to_timecode(frames, fpsSpec)
        return self:frames_to_timecode_precise(frames, fpsSpec)
    end

    function Helpers:frames_to_timecode_precise(frames, fpsSpec)
        local frac = self:fps_to_fraction(fpsSpec or { num = 24, den = 1 })
        local base = self:fps_timebase(frac)
        local totalFrames = math.max(0, math.floor((frames or 0) + 0.5))
        local framesPerHour = base * 3600
        local framesPerMinute = base * 60
        local hh = math.floor(totalFrames / framesPerHour)
        totalFrames = totalFrames - hh * framesPerHour
        local mm = math.floor(totalFrames / framesPerMinute)
        totalFrames = totalFrames - mm * framesPerMinute
        local ss = math.floor(totalFrames / base)
        local ff = totalFrames - ss * base
        return string.format("%02d:%02d:%02d:%02d", hh, mm, ss, ff)
    end

    function Helpers:timecode_to_frames(timecode, fpsSpec)
        if not timecode or timecode == "" then
            return nil
        end
        local hh, mm, ss, ff = timecode:match("^(%d+):(%d+):(%d+):(%d+)$")
        if not hh then
            return nil
        end
        hh, mm, ss, ff = tonumber(hh), tonumber(mm), tonumber(ss), tonumber(ff)
        if not (hh and mm and ss and ff) then
            return nil
        end
        local frac = self:fps_to_fraction(fpsSpec or { num = 24, den = 1 })
        local base = self:fps_timebase(frac)
        local totalFrames = ((hh * 3600) + (mm * 60) + ss) * base + ff
        return math.floor(totalFrames * frac.den / base + 0.5)
    end

    function Helpers:get_timeline_fps_fraction(timeline)
        if not timeline or not timeline.GetSetting then
            return { num = 24, den = 1 }
        end
        local keys = { "timelineFrameRate", "timelinePlaybackFrameRate", "timelineProxyFrameRate" }
        for _, key in ipairs(keys) do
            local ok, value = pcall(function()
                return timeline:GetSetting(key)
            end)
            if ok and value then
                return self:fps_to_fraction(value)
            end
        end
        return { num = 24, den = 1 }
    end

    function Helpers:get_timeline_fps(timeline)
        local frac = self:get_timeline_fps_fraction(timeline)
        return frac.num / frac.den
    end

    function Helpers:sort_markers(markerDict)
        local list = {}
        for frame, meta in pairs(markerDict or {}) do
            local f = tonumber(frame)
            if f then
                table.insert(list, { frame = f, meta = meta })
            end
        end
        table.sort(list, function(a, b) return a.frame < b.frame end)
        return list
    end

    function Helpers:http_get(url, headers, timeout)
        return self:httpGet(url, headers, timeout)
    end

    App.Helpers = Helpers
end

App.Helpers:ensure_dir(App.Config.CONFIG_DIR)
App.Helpers:ensure_dir(App.Config.TEMP_DIR)

--
-- 4. 状态模块 (App.State)
--
do
    local State = {
        interval_seconds = App.Config.DEFAULT_INTERVAL_SECONDS,
        mark_count = App.Config.DEFAULT_MARK_COUNT,
        target_dir = "",
        base_name = "",
        language = App.Locale and App.Locale.current or "en",
        all_timelines = {},
        editing_timeline_index = nil,
        tree_rows = {},
        job_ids = {},
        job_rows = {},
        logs = {},
        created_markers = {},
        timeline_fps = 24,
        timeline_fps_fraction = { num = 24, den = 1 },
        timeline_start_frame = 0,
        update_info = nil,
    }

    function State:reset_job_tracking()
        self.job_ids = {}
        self.job_rows = {}
    end

    function State:set_tree_rows(rows, timeline_index)
        if timeline_index ~= nil then
            timeline_index = tonumber(timeline_index)
        end
        local normalized = {}
        for _, row in ipairs(rows or {}) do
            if row then
                local rowTimelineIndex = tonumber(row.timeline_index) or timeline_index
                if rowTimelineIndex then
                    row.timeline_index = rowTimelineIndex
                end
                if row.timeline_index and not row.timeline_name then
                    local entry = self:get_timeline_entry(row.timeline_index)
                    if entry and entry.name then
                        row.timeline_name = entry.name
                    end
                end
                table.insert(normalized, row)
            end
        end
        if timeline_index ~= nil then
            local merged = {}
            for _, row in ipairs(self.tree_rows or {}) do
                local rowTimelineIndex = row and tonumber(row.timeline_index)
                if row and rowTimelineIndex ~= timeline_index then
                    table.insert(merged, row)
                end
            end
            for _, row in ipairs(normalized) do
                table.insert(merged, row)
            end
            self.tree_rows = merged
        else
            self.tree_rows = normalized
        end
        self:reset_job_tracking()
        for _, row in ipairs(self.tree_rows) do
            if row then
                row.jobId = nil
                row.statusKey = "pending"
                row.statusExtra = nil
                row.lastLoggedStatus = nil
            end
        end
        if timeline_index ~= nil then
            self:apply_base_name_to_rows(timeline_index)
        else
            for _, entry in ipairs(self.all_timelines or {}) do
                if entry and entry.index then
                    self:apply_base_name_to_rows(entry.index)
                end
            end
        end
    end

    function State:get_tree_rows()
        return self.tree_rows or {}
    end

    function State:get_row_by_index(index)
        if not index then
            return nil
        end
        index = tonumber(index)
        if not index then
            return nil
        end
        for _, row in ipairs(self.tree_rows or {}) do
            if row and row.index == index then
                return row
            end
        end
        return nil
    end

    function State:get_timeline_entry(idx)
        if not idx then
            return nil
        end
        idx = tonumber(idx)
        if not idx then
            return nil
        end
        for _, entry in ipairs(self.all_timelines or {}) do
            if entry and entry.index == idx then
                return entry
            end
        end
        return nil
    end

    function State:load_all_timelines()
        local project = App.Core:getProject()
        if not (project and project.GetTimelineCount and project.GetTimelineByIndex) then
            self.all_timelines = {}
            self.editing_timeline_index = nil
            return self.all_timelines
        end
        local count = project:GetTimelineCount() or 0
        local list = {}
        local previous = self.all_timelines or {}
        local baseById = {}
        local baseByIndex = {}
        for _, entry in ipairs(previous) do
            if entry then
                if entry.uniqueId then
                    baseById[entry.uniqueId] = entry.base_name
                end
                if entry.index then
                    baseByIndex[entry.index] = entry.base_name
                end
            end
        end
        local currentTimeline = project:GetCurrentTimeline()
        local currentId = nil
        if currentTimeline and currentTimeline.GetUniqueId then
            local ok, value = pcall(function()
                return currentTimeline:GetUniqueId()
            end)
            if ok then
                currentId = value
            end
        end
        local currentIndex = nil
        for i = 1, count do
            local timeline = project:GetTimelineByIndex(i)
            if timeline then
                local name = "Timeline " .. tostring(i)
                if timeline.GetName then
                    local ok, value = pcall(function()
                        return timeline:GetName()
                    end)
                    if ok and value then
                        name = value
                    end
                end
                local uniqueId = nil
                if timeline.GetUniqueId then
                    local ok, value = pcall(function()
                        return timeline:GetUniqueId()
                    end)
                    if ok then
                        uniqueId = value
                    end
                end
                local baseName = nil
                if uniqueId and baseById[uniqueId] then
                    baseName = baseById[uniqueId]
                elseif baseByIndex[i] then
                    baseName = baseByIndex[i]
                end
                baseName = App.Helpers:trim(baseName or "")
                if baseName == "" then
                    baseName = name
                end
                table.insert(list, {
                    index = i,
                    timeline = timeline,
                    name = name,
                    uniqueId = uniqueId,
                    enabled = false,
                    base_name = baseName,
                })
                if currentId and uniqueId and uniqueId == currentId then
                    currentIndex = i
                elseif not currentId and currentTimeline and timeline == currentTimeline then
                    currentIndex = i
                end
            end
        end
        self.all_timelines = list
        if not currentIndex and self.editing_timeline_index then
            for _, entry in ipairs(list) do
                if entry and entry.index == self.editing_timeline_index then
                    currentIndex = entry.index
                    break
                end
            end
        end
        if not currentIndex and #list > 0 then
            currentIndex = list[1].index
        end
        self.editing_timeline_index = currentIndex
        for _, entry in ipairs(list) do
            entry.enabled = (currentIndex ~= nil and entry.index == currentIndex)
        end
        return list
    end

    function State:get_timeline_by_index(idx)
        if not idx then
            return nil
        end
        idx = tonumber(idx)
        if not idx then
            return nil
        end
        local entry = self:get_timeline_entry(idx)
        if entry and entry.timeline then
            return entry.timeline
        end
        local project = App.Core:getProject()
        if project and project.GetTimelineByIndex then
            local ok, timeline = pcall(function()
                return project:GetTimelineByIndex(idx)
            end)
            if ok then
                if entry then
                    entry.timeline = timeline
                end
                return timeline
            end
        end
        return nil
    end

    function State:set_editing_timeline(idx, silent)
        idx = tonumber(idx)
        if not idx then
            return false
        end
        if not self.all_timelines or #self.all_timelines == 0 then
            self:load_all_timelines()
        end
        local entry = self:get_timeline_entry(idx)
        local timeline = (entry and entry.timeline) or self:get_timeline_by_index(idx)
        if not timeline then
            if App.Logger and App.Logger.append_localized then
                App.Logger:append_localized("log_active_timeline_missing")
            end
            return false
        end
        local project = App.Core:getProject()
        if project and project.SetCurrentTimeline then
            local current = App.Core:getTimeline()
            local same = false
            if current and timeline then
                if current == timeline then
                    same = true
                else
                    local okCurrent, currentId = pcall(function()
                        return current:GetUniqueId()
                    end)
                    local okTarget, targetId = pcall(function()
                        return timeline:GetUniqueId()
                    end)
                    if okCurrent and okTarget and currentId and targetId and currentId == targetId then
                        same = true
                    end
                end
            end
            if not same then
                local ok, result = pcall(function()
                    return project:SetCurrentTimeline(timeline)
                end)
                if ok and result == false then
                    return false
                end
            end
        end
        self.editing_timeline_index = idx
        for _, item in ipairs(self.all_timelines or {}) do
            item.enabled = (item.index == idx)
        end
        self.base_name = self:get_base_name_for_timeline(idx, entry and entry.name)
        if timeline and App.Helpers then
            local fpsFraction = App.Helpers:get_timeline_fps_fraction(timeline)
            self:set_timeline_fps(fpsFraction)
            local startFrame = 0
            if timeline.GetStartFrame then
                local ok, value = pcall(function()
                    return timeline:GetStartFrame()
                end)
                if ok then
                    startFrame = tonumber(value) or 0
                end
            end
            self:set_timeline_start_frame(startFrame)
            if entry then
                entry.fps_fraction = { num = fpsFraction.num, den = fpsFraction.den }
                entry.start_frame = startFrame
            end
        end
        if App.Core then
            App.Core.timeline = timeline
        end
        if not silent and App.Logger and App.Logger.append_localized then
            local name = entry and entry.name
            if not name and timeline and timeline.GetName then
                local ok, value = pcall(function()
                    return timeline:GetName()
                end)
                if ok then
                    name = value
                end
            end
            App.Logger:append_localized("timeline_switch_success", name or tostring(idx))
        end
        return true
    end

    function State:set_job_ids(jobIds)
        self.job_ids = jobIds or {}
    end

    function State:register_job_row(jobId, row)
        if not jobId or not row then
            return
        end
        self.job_rows[jobId] = row
    end

    function State:get_row_by_job(jobId)
        if not jobId then
            return nil
        end
        return self.job_rows[jobId]
    end

    function State:set_row_status(row, statusKey, statusExtra)
        if not row then
            return false, false
        end
        local changed = false
        local keyChanged = false
        if row.statusKey ~= statusKey then
            row.statusKey = statusKey
            changed = true
            keyChanged = true
        end
        if row.statusExtra ~= statusExtra then
            row.statusExtra = statusExtra
            changed = true
        end
        return changed, keyChanged
    end

    function State:set_target_dir(path)
        self.target_dir = App.Helpers:trim(path or "")
    end

    function State:get_base_name_for_timeline(timeline_index, fallback)
        local entry = self:get_timeline_entry(timeline_index)
        local prefix = entry and App.Helpers:trim(entry.base_name or "") or ""
        if prefix == "" and entry then
            prefix = App.Helpers:trim(entry.name or "")
            if prefix ~= "" then
                entry.base_name = prefix
            end
        end
        if prefix == "" then
            prefix = App.Helpers:trim(fallback or "")
        end
        if prefix == "" then
            prefix = App.Helpers:trim(self.base_name or "")
        end
        if prefix == "" then
            prefix = "Batch"
        end
        return prefix
    end

    function State:apply_base_name_to_rows(timeline_index)
        local idx = tonumber(timeline_index) or tonumber(self.editing_timeline_index)
        if not idx then
            return
        end
        local prefix = self:get_base_name_for_timeline(idx)
        for _, row in ipairs(self.tree_rows or {}) do
            local rowIdx = row and tonumber(row.timeline_index)
            if row and rowIdx == idx and row.index then
                row.base_name = prefix
                row.name = string.format("%s_%03d", prefix, row.index)
            end
        end
    end

    function State:set_base_name(name, timeline_index)
        local sanitized = App.Helpers:strip_extension(App.Helpers:trim(name or ""))
        if sanitized == "" then
            sanitized = "Batch"
        end
        local idx = tonumber(timeline_index) or self.editing_timeline_index
        if idx then
            local entry = self:get_timeline_entry(idx)
            if entry then
                entry.base_name = sanitized
            end
        end
        self.base_name = sanitized
        if idx then
            self:apply_base_name_to_rows(idx)
        end
    end

    function State:remember_marker(frame)
        if type(frame) ~= "number" then
            return
        end
        self.created_markers[math.floor(frame + 0.5)] = true
    end

    function State:reset_created_markers()
        self.created_markers = {}
    end

    function State:init_defaults()
        local timeline = App.Core:getTimeline()
        if timeline and timeline.GetName then
            self:set_base_name(timeline:GetName() or "Batch")
        else
            self:set_base_name("Batch")
        end
        self.target_dir = self.target_dir or ""
        self.language = self.language or (App.Locale and App.Locale.current) or "en"
        self.timeline_fps_fraction = self.timeline_fps_fraction or { num = 24, den = 1 }
        self.timeline_fps = self.timeline_fps or 24
        self.timeline_start_frame = self.timeline_start_frame or 0
    end

    function State:set_timeline_fps(fpsFraction)
        if type(fpsFraction) == "table" and fpsFraction.num and fpsFraction.den then
            self.timeline_fps_fraction = { num = fpsFraction.num, den = fpsFraction.den }
            self.timeline_fps = fpsFraction.num / fpsFraction.den
        end
    end

    function State:get_timeline_fps_fraction()
        return self.timeline_fps_fraction or { num = 24, den = 1 }
    end

    function State:set_timeline_start_frame(frame)
        local value = tonumber(frame) or 0
        self.timeline_start_frame = math.floor(value + 0.5)
    end

    function State:get_timeline_start_frame()
        return self.timeline_start_frame or 0
    end

    State:init_defaults()
    if App.Locale then
        App.Locale:set_language(State.language)
    end
    App.State = State
end

--
-- 5. 设置模块 (App.Settings)
--
do
    local Settings = { data = {} }
    local Helpers = App.Helpers

    function Settings:load()
        Helpers:ensure_dir(App.Config.CONFIG_DIR)
        local stored = Helpers:read_json(App.Config.SETTINGS_FILE)
        if type(stored) ~= "table" then
            stored = {}
        end
        self.data = stored
        local lang = stored.language
        if lang == "en" or lang == "zh" then
            App.State.language = lang
            if App.Locale then
                App.Locale:set_language(lang)
            end
        else
            stored.language = App.State.language
        end
    end

    function Settings:save()
        if not self.data then
            self.data = {}
        end
        self.data.language = App.State.language
        App.Helpers:write_json(App.Config.SETTINGS_FILE, self.data)
    end

    App.Settings = Settings
    App.Settings:load()
end

--
-- 6. 更新检测模块 (App.Update)
--
do
    local Update = {}
    local Helpers = App.Helpers

    function Update:_fetch()
        local url = string.format(
            "%s/functions/v1/check_update?pid=%s",
            App.Config.SUPABASE_URL,
            Helpers:url_encode(App.Config.SCRIPT_NAME)
        )
        local headers = {
            Authorization = "Bearer " .. App.Config.SUPABASE_ANON_KEY,
            apikey = App.Config.SUPABASE_ANON_KEY,
            ["Content-Type"] = "application/json",
            ["User-Agent"] = string.format("%s/%s", App.Config.SCRIPT_NAME, App.Config.SCRIPT_VERSION),
        }
        local body, status = Helpers:httpGet(url, headers, App.Config.SUPABASE_TIMEOUT)
        if not body then
            return nil
        end
        if status and status ~= 200 and status ~= 0 then
            return nil
        end
        local ok, decoded = pcall(json.decode, body)
        if not ok or type(decoded) ~= "table" then
            return nil
        end
        return decoded
    end

    function Update:_build_message(payload, lang, latest, current)
        local key = lang == "zh" and "cn" or "en"
        local info = ""
        if type(payload) == "table" then
            info = Helpers:trim(payload[key] or payload[lang])
        end
        local readableCurrent = Helpers:trim(current or "")
        if readableCurrent == "" then
            readableCurrent = (lang == "zh") and "未知" or "unknown"
        end
        local line
        if lang == "zh" then
            line = string.format("发现新版本：%s → %s，请前往购买页下载。", readableCurrent, latest)
        else
            line = string.format("Update available: %s → %s. Download it from your purchase page.", readableCurrent, latest)
        end
        if info ~= "" then
            return info .. "\n" .. line
        end
        return line
    end

    function Update:check_for_updates()
        local ok, payload = pcall(function()
            return self:_fetch()
        end)
        if not ok or type(payload) ~= "table" then
            return
        end
        local latest = Helpers:trim(tostring(payload.latest or ""))
        local current = Helpers:trim(tostring(App.Config.SCRIPT_VERSION or ""))
        if latest == "" or latest == current then
            return
        end
        local info = {
            latest = latest,
            current = current,
            en = self:_build_message(payload, "en", latest, current),
            zh = self:_build_message(payload, "zh", latest, current),
        }
        App.State.update_info = info
        if App.UI and App.UI.update_update_status_label then
            App.UI:update_update_status_label()
        end
    end

    App.Update = Update
end
--
-- 7. 日志模块 (App.Logger)
--
do
    local Logger = {
        lines = {},
        entries = {}
    }
    local unpack_list = (table and table.unpack) or unpack

    local function clone_args(args)
        if not args or #args == 0 then
            return {}
        end
        local copy = {}
        for i = 1, #args do
            copy[i] = args[i]
        end
        return copy
    end

    function Logger:_format_entry(entry)
        if not entry then
            return ""
        end
        local content = entry.message or ""
        if entry.key and App.Locale and App.Locale.format then
            local ok, formatted = pcall(function()
                return App.Locale:format(entry.key, unpack_list(entry.args or {}))
            end)
            if ok and formatted then
                content = formatted
            end
        end
        return string.format("[%s] %s", entry.timestamp or os.date("%H:%M:%S"), content)
    end

    function Logger:_trim()
        local maxLines = App.Config.LOG_MAX_LINES or 200
        local trimmed = false
        while #self.entries > maxLines do
            table.remove(self.entries, 1)
            trimmed = true
            if #self.lines > maxLines then
                table.remove(self.lines, 1)
            end
        end
        while #self.lines > maxLines do
            table.remove(self.lines, 1)
            trimmed = true
        end
        return trimmed
    end

    local function get_log_view()
        local items = App.UI and App.UI.items
        return items and items.LogView or nil
    end

    local function append_line(view, line)
        if not view or not line then
            return
        end
        if view.Append then
            pcall(function()
                view:Append(line)
            end)
            return
        end
        local existing = view.Text or ""
        if existing ~= "" then
            view.Text = existing .. "\n" .. line
        else
            view.Text = line
        end
    end

    function Logger:_update_view(refreshAll)
        local view = get_log_view()
        if not view then
            return
        end
        if refreshAll then
            if view.Clear then
                pcall(function()
                    view:Clear()
                end)
            end
            if view.Append then
                for _, line in ipairs(self.lines) do
                    append_line(view, line)
                end
            else
                view.Text = table.concat(self.lines, "\n")
            end
            return
        end
        append_line(view, self.lines[#self.lines])
    end

    function Logger:_append_entry(entry)
        if not entry then
            return
        end
        table.insert(self.entries, entry)
        local line = self:_format_entry(entry)
        table.insert(self.lines, line)
        local trimmed = self:_trim()
        print(line)
        self:_update_view(trimmed)
    end

    function Logger:append(message)
        if message == nil then
            return
        end
        local entry = {
            message = tostring(message),
            timestamp = os.date("%H:%M:%S")
        }
        self:_append_entry(entry)
    end

    function Logger:append_localized(key, ...)
        if not key then
            return
        end
        local args = { ... }
        local message
        if App.Locale and App.Locale.format then
            local ok, formatted = pcall(function()
                return App.Locale:format(key, unpack_list(args))
            end)
            message = ok and formatted or nil
        end
        if not message then
            if #args > 0 then
                local ok, formatted = pcall(string.format, key, unpack_list(args))
                message = ok and formatted or key
            else
                message = key
            end
        end
        local entry = {
            key = key,
            args = clone_args(args),
            message = message,
            timestamp = os.date("%H:%M:%S")
        }
        self:_append_entry(entry)
    end

    function Logger:refresh_language()
        local rebuilt = {}
        for _, entry in ipairs(self.entries) do
            table.insert(rebuilt, self:_format_entry(entry))
        end
        self.lines = rebuilt
        self:_trim()
        self:_update_view(true)
    end

    App.Logger = Logger
end

--
-- 6. 时间线模块 (App.Timeline)
--
do
    local Timeline = {}

    function Timeline:add_markers(interval_seconds, count)
        local timeline = App.Core:getTimeline()
        if not timeline then
            App.Logger:append_localized("log_active_timeline_missing")
            return false
        end

        interval_seconds = tonumber(interval_seconds)
        count = tonumber(count)
        if not interval_seconds or interval_seconds <= 0 then
            App.Logger:append_localized("log_interval_invalid")
            return false
        end
        if not count or count < 2 then
            App.Logger:append_localized("log_count_invalid")
            return false
        end

        local fpsFraction = App.Helpers:get_timeline_fps_fraction(timeline)
        local fpsBase = App.Helpers:fps_timebase(fpsFraction)
        local interval_frames = math.max(1, math.floor(interval_seconds * fpsBase + 0.5))
        local start_frame = 0

        for i = 0, count - 1 do
            local frame = start_frame + i * interval_frames
            local name = string.format("Batch_%03d", i + 1)
            local ok = timeline:AddMarker(frame, App.Config.MARK_COLOR, name, App.Config.MARK_TAG, interval_frames, App.Config.MARK_TAG)
            if not ok then
                App.Logger:append_localized("log_marker_add_failed", frame)
                return false
            else
                App.State:remember_marker(frame)
            end
        end

        App.Logger:append_localized("log_marker_add_success", count, interval_frames)
        return true
    end

    local function collect_track_items(timeline)
        local collections = {
            video = {},
            audio = {}
        }
        if not (timeline and timeline.GetTrackCount and timeline.GetItemListInTrack) then
            return collections
        end

        local function push_tracks(trackType)
            local count = timeline:GetTrackCount(trackType) or 0
            local target = collections[trackType]
            if target then
                for idx = 1, count do
                    table.insert(target, timeline:GetItemListInTrack(trackType, idx) or {})
                end
            end
        end

        push_tracks("video")
        push_tracks("audio")
        return collections
    end

    local function resolve_clip_frame(item, primaryGetter, fallbackGetter, offset)
        if not item then
            return nil
        end
        local getter = primaryGetter and item[primaryGetter]
        if type(getter) == "function" then
            local ok, value = pcall(getter, item)
            if ok then
                local num = tonumber(value)
                if num then
                    return math.floor(num + 0.5)
                end
            end
        end
        getter = fallbackGetter and item[fallbackGetter]
        if type(getter) == "function" then
            local ok, value = pcall(getter, item)
            if ok then
                local num = tonumber(value)
                if num then
                    if offset and offset ~= 0 then
                        num = num - offset
                    end
                    return math.floor(num + 0.5)
                end
            end
        end
        return nil
    end

    local function has_media_between(trackCollections, startFrame, endFrame, timelineStartFrame)
        if not startFrame or not endFrame or endFrame <= startFrame then
            return false
        end
        local offset = tonumber(timelineStartFrame) or 0
        for _, items in ipairs(trackCollections or {}) do
            for _, item in ipairs(items) do
                local clipStart = resolve_clip_frame(item, "GetStartFrame", "GetStart", offset)
                local clipEnd = resolve_clip_frame(item, "GetEndFrame", "GetEnd", offset)
                if clipStart and clipEnd and clipEnd > startFrame and clipStart < endFrame then
                    return true
                end
            end
        end
        return false
    end

    local function extract_marker_duration(meta)
        if type(meta) ~= "table" then
            return nil
        end
        local candidates = { "duration", "Duration", "length", "Length" }
        for _, key in ipairs(candidates) do
            local value = meta[key]
            if value ~= nil then
                local num = tonumber(value)
                if num and num > 0 then
                    return math.floor(num + 0.5)
                end
            end
        end
        return nil
    end

    local function marker_display_name(meta, fallback)
        if type(meta) == "table" then
            return meta.name or meta.Name or meta.text or meta.Text or fallback
        end
        return fallback
    end

    function Timeline:build_segments(timeline_index)
        if timeline_index ~= nil then
            local ok = App.State:set_editing_timeline(timeline_index, true)
            if not ok then
                App.Logger:append_localized("log_active_timeline_missing")
                return nil
            end
        else
            timeline_index = App.State.editing_timeline_index
        end
        local timeline = App.Core:getTimeline()
        if not timeline then
            App.Logger:append_localized("log_active_timeline_missing")
            return nil
        end
        if not timeline_index then
            timeline_index = App.State.editing_timeline_index
        end
        local markerDict = timeline:GetMarkers() or {}
        local sorted = App.Helpers:sort_markers(markerDict)
        local targetMarkers = {}
        for _, entry in ipairs(sorted) do
            if entry.meta then
                table.insert(targetMarkers, entry)
            end
        end
        if #targetMarkers == 0 then
            App.Logger:append_localized("log_need_duration_marker")
            return nil
        end
        local fpsFraction = App.Helpers:get_timeline_fps_fraction(timeline)
        local fps = App.Helpers:get_timeline_fps(timeline)
        App.State:set_timeline_fps(fpsFraction)
        local timelineStartFrame = 0
        if timeline.GetStartFrame then
            local ok, value = pcall(function()
                return timeline:GetStartFrame()
            end)
            if ok then
                timelineStartFrame = tonumber(value) or 0
            end
        end
        App.State:set_timeline_start_frame(timelineStartFrame)
        local trackCollections = collect_track_items(timeline)
        local timelineName = timeline:GetName() or "Timeline"
        local timelineUniqueId = nil
        if timeline.GetUniqueId then
            local ok, value = pcall(function()
                return timeline:GetUniqueId()
            end)
            if ok then
                timelineUniqueId = value
            end
        end
        local basePrefix = App.State:get_base_name_for_timeline(timeline_index, timelineName)
        local segments = {}
        local segmentIndex = 0
        for idx, marker in ipairs(targetMarkers) do
            local startFrame = math.floor(marker.frame + 0.5)
            local nextMarker = targetMarkers[idx + 1]
            local fallbackDuration = nil
            if nextMarker then
                fallbackDuration = math.floor(nextMarker.frame + 0.5) - startFrame
                if fallbackDuration <= 0 then
                    fallbackDuration = nil
                end
            end
            local durationFrames = extract_marker_duration(marker.meta)
            if (not durationFrames or durationFrames <= 0) and fallbackDuration then
                durationFrames = fallbackDuration
            end
            local displayStartFrame = startFrame + timelineStartFrame
            local startTc = App.Helpers:frames_to_timecode_precise(displayStartFrame, fpsFraction)
            if not durationFrames or durationFrames <= 0 then
                App.Logger:append_localized(
                    "log_marker_duration_missing",
                    marker_display_name(marker.meta, string.format("#%03d", idx)),
                    startTc
                )
            elseif durationFrames == 1 then
                App.Logger:append_localized(
                    "log_marker_duration_too_short",
                    marker_display_name(marker.meta, string.format("#%03d", idx)),
                    startTc
                )
            else
                local endFrame = startFrame + durationFrames
                local inclusiveEndFrame = math.max(startFrame, endFrame - 1)
                local displayEndFrame = inclusiveEndFrame + timelineStartFrame
                local endTc = App.Helpers:frames_to_timecode_precise(displayEndFrame, fpsFraction)
                if not has_media_between(trackCollections.video, startFrame, endFrame, timelineStartFrame) then
                    App.Logger:append_localized("log_segment_skipped", startTc, endTc)
                else
                    segmentIndex = segmentIndex + 1
                    local row = {
                        index = segmentIndex,
                        startFrame = startFrame,
                        endFrame = endFrame,
                        startTimecode = startTc,
                        endTimecode = endTc,
                        name = string.format("%s_%03d", basePrefix, segmentIndex),
                        base_name = basePrefix,
                        timeline_index = timeline_index,
                        timeline_name = timelineName,
                        timeline_unique_id = timelineUniqueId,
                        timeline_start_frame = timelineStartFrame,
                        timeline_fps_fraction = { num = fpsFraction.num, den = fpsFraction.den },
                        statusKey = "pending",
                        statusExtra = nil
                    }
                    table.insert(segments, row)
                end
            end
        end
        if #segments == 0 then
            App.Logger:append_localized("log_no_valid_segments")
            return nil
        end
        App.Logger:append_localized("log_segments_generated", #segments)
        return segments
    end

    function Timeline:build_segments_for_timeline(timeline_index)
        return self:build_segments(timeline_index)
    end

    function Timeline:cleanup_script_markers()
        local timeline = App.Core:getTimeline()
        if not timeline then
            return
        end
        local markers = timeline:GetMarkers() or {}
        local removed = 0
        for frame, meta in pairs(markers) do
            if meta and meta.customData == App.Config.MARK_TAG then
                timeline:DeleteMarkerAtFrame(frame)
                removed = removed + 1
            end
        end
        if removed > 0 then
            App.Logger:append_localized("log_markers_removed", removed)
        end
        App.State:reset_created_markers()
    end

    function Timeline:clear_mark_range()
        local timeline = App.Core:getTimeline()
        if not (timeline and timeline.ClearMarkInOut) then
            return false
        end
        local ok, res = pcall(function()
            return timeline:ClearMarkInOut("all")
        end)
        return ok and res ~= false
    end

    function Timeline:apply_mark_range(row)
        if not row or not row.startFrame or not row.endFrame or row.endFrame <= row.startFrame then
            return false
        end
        local timeline = App.Core:getTimeline()
        if not (timeline and timeline.SetMarkInOut) then
            return false
        end
        local markOut = math.max(row.startFrame, row.endFrame - 1)
        local ok, result = pcall(function()
            return timeline:SetMarkInOut(row.startFrame, markOut, "all")
        end)
        if ok and result == true then
            return true
        end
        if App.Logger and App.Logger.append_localized then
            App.Logger:append_localized("log_mark_range_failed", row.name or row.startTimecode or tostring(row.index or "?"))
        end
        return false
    end

    function Timeline:jump_to_frame(frame, fpsFraction, startOffset)
        if not frame then
            return false
        end
        local timeline = App.Core:getTimeline()
        if not timeline then
            return false
        end
        local resolve = App.Core.resolve
        if resolve and resolve.GetCurrentPage then
            local currentPage = resolve:GetCurrentPage()
            local allowed = {
                cut = true,
                edit = true,
                color = true,
                fairlight = true,
                deliver = true,
            }
            if not allowed[currentPage] and resolve.OpenPage then
                resolve:OpenPage("edit")
            end
        end
        local fpsFrac = fpsFraction or App.State:get_timeline_fps_fraction()
        if startOffset == nil then
            startOffset = App.State:get_timeline_start_frame() or 0
        end
        local displayFrame = (tonumber(frame) or 0) + startOffset
        local timecode = App.Helpers:frames_to_timecode_precise(displayFrame, fpsFrac)
        local ok = timeline.SetCurrentTimecode and timeline:SetCurrentTimecode(timecode)
        if not ok and timeline.SetCurrentFrame then
            ok = timeline:SetCurrentFrame(frame)
        end
        return ok == true
    end

    function Timeline:jump_to_row(row)
        if not row then
            return false
        end
        if row.timeline_index then
            App.State:set_editing_timeline(row.timeline_index, true)
        end
        local fpsFraction = row.timeline_fps_fraction
        local startOffset = row.timeline_start_frame
        local jumped = self:jump_to_frame(row.startFrame, fpsFraction, startOffset)
        if jumped then
            self:apply_mark_range(row)
        end
        return jumped
    end

    App.Timeline = Timeline
end

--
-- 7. 渲染模块 (App.Render)
--
do
    local Render = {
        monitor = nil,
        _statusDirty = false,
        sequence = nil
    }
    local unpack_list = (table and table.unpack) or unpack

    local statusLocaleKeys = {
        pending = "status_pending",
        queued = "status_queued",
        waiting = "status_waiting",
        rendering = "status_rendering",
        done = "status_done",
        failed = "status_failed"
    }

    local function localized_text(key, ...)
        local args = { ... }
        if not key then
            return ""
        end
        if App.Locale and App.Locale.format then
            local ok, text = pcall(function()
                return App.Locale:format(key, unpack_list(args))
            end)
            if ok and text then
                return text
            end
        end
        if #args > 0 then
            local ok, text = pcall(string.format, key, unpack_list(args))
            if ok and text then
                return text
            end
        end
        return key
    end

    -- 仅保留：切到 Deliver 页 + 目录校验
    local function ensure_render_env(project, targetDir)
        if not project then return false, "log_project_missing" end

        local resolver = App.Core and App.Core.resolve
        if resolver and resolver.OpenPage then
            pcall(function() resolver:OpenPage("deliver") end) -- 切到 Deliver 页（官方支持）【:contentReference[oaicite:14]{index=14}】
        end

        -- 不再调用：SetCurrentRenderMode / SetCurrentRenderFormatAndCodec
        if type(targetDir) ~= "string" or targetDir == "" then
            return false, "log_target_dir_required"
        end
        return true
    end


    local function to_display_frame(frame, startOffset)
        local base = tonumber(frame) or 0
        local offset = 0
        if startOffset ~= nil then
            offset = tonumber(startOffset) or 0
        elseif App.State and App.State.get_timeline_start_frame then
            offset = App.State:get_timeline_start_frame() or 0
        end
        return math.floor(base + offset + 0.5)
    end

    local function build_settings(row, targetDir)
        local prefix = App.Helpers:trim(row.base_name or "")
        if prefix == "" and row and row.timeline_index then
            local entry = App.State and App.State.get_timeline_entry and App.State:get_timeline_entry(row.timeline_index) or nil
            prefix = entry and App.Helpers:trim(entry.base_name or "") or ""
        end
        if prefix == "" then
            prefix = App.Helpers:trim(row.timeline_name or "")
        end
        if prefix == "" then
            prefix = "Render"
        end
        row.base_name = prefix
        local customName = string.format("%s_%03d", prefix, row.index or 0)
        row.name = customName
        local startOffset = row.timeline_start_frame
        local markIn = to_display_frame(row.startFrame, startOffset)
        local markOut = to_display_frame(math.max(row.startFrame, row.endFrame - 1), startOffset)

        -- 仅设置范围、目录、文件名；其余参数沿用 Deliver 页当前设置
        return {
            SelectAllFrames = false,   -- 使用 MarkIn/Out
            MarkIn = markIn,
            MarkOut = markOut,
            TargetDir = targetDir,
            CustomName = customName,
            -- 不再设置 ExportVideo/ExportAudio/Format/Codec/Quality...
        } -- 这些键均为官方支持【:contentReference[oaicite:15]{index=15}】
    end

    local function group_rows_by_timeline(rows)
        local grouped = {}
        for _, row in ipairs(rows or {}) do
            if row then
                local idx = tonumber(row.timeline_index) or 0
                grouped[idx] = grouped[idx] or {}
                table.insert(grouped[idx], row)
            end
        end
        local ordered = {}
        local used = {}
        for _, entry in ipairs(App.State.all_timelines or {}) do
            local idx = entry and entry.index
            if idx and grouped[idx] then
                table.insert(ordered, { timeline_index = idx, rows = grouped[idx] })
                used[idx] = true
            end
        end
        local extra = {}
        for idx, _ in pairs(grouped) do
            if not used[idx] then
                table.insert(extra, idx)
            end
        end
        table.sort(extra, function(a, b) return a < b end)
        for _, idx in ipairs(extra) do
            table.insert(ordered, { timeline_index = (idx ~= 0 and idx or nil), rows = grouped[idx] })
        end
        return ordered
    end


    local function update_row_status(row, statusKey, statusExtra)
        local changed, keyChanged = App.State:set_row_status(row, statusKey, statusExtra)
        if changed then
            Render._statusDirty = true
        end
        return changed, keyChanged
    end

    local function log_row_status(row, statusKey)
        if not row or not statusKey then
            return
        end
        if row.lastLoggedStatus == statusKey then
            return
        end
        local labelKey = statusLocaleKeys[statusKey]
        if not labelKey then
            return
        end
        row.lastLoggedStatus = statusKey
        local rowName = row.name or string.format("Segment %s", tostring(row.index or "?"))
        local labelText = App.Locale and App.Locale:format(labelKey) or labelKey
        App.Logger:append_localized("log_row_status_pattern", rowName, labelText)
    end

    local function ensure_ui_refresh()
        if Render._statusDirty and App.UI then
            App.UI:refresh_tree()
            Render._statusDirty = false
        end
    end

    local function normalize_job_status(info)
        if type(info) ~= "table" then
            return "unknown", nil
        end
        local rawStatus = info.JobStatus or info.Status or info["Job Status"] or info.State
        local normalized = "queued"
        if rawStatus and rawStatus ~= "" then
            local lower = string.lower(tostring(rawStatus))
            if lower:find("render") or lower:find("process") or lower:find("run") then
                normalized = "rendering"
            elseif lower:find("wait") or lower:find("queue") or lower:find("hold") then
                normalized = "waiting"
            elseif lower:find("fail") or lower:find("error") or lower:find("cancel") or lower:find("abort") or lower:find("stop") then
                normalized = "failed"
            elseif lower:find("complete") or lower:find("finish") or lower:find("success") or lower:find("done") then
                normalized = "done"
            else
                normalized = "queued"
            end
        end
        local progressText = nil
        local progress = info.CompletionPercentage or info.PercentComplete or info.Percentage or info.Progress
        if normalized == "rendering" and progress ~= nil then
            local numeric = tonumber(progress)
            if numeric then
                numeric = math.max(0, math.min(100, numeric))
                progressText = string.format("%d%%", math.floor(numeric + 0.5))
            elseif type(progress) == "string" and progress ~= "" then
                progressText = progress
            end
        end
        return normalized, progressText
    end

    local function finalize_rows_as(statusKey)
        local updated = false
        for _, row in ipairs(App.State:get_tree_rows() or {}) do
            if row and row.statusKey ~= "done" and row.statusKey ~= "failed" then
                local _, keyChanged = update_row_status(row, statusKey, nil)
                if keyChanged then
                    log_row_status(row, statusKey)
                end
                updated = updated or keyChanged
            end
        end
        return updated
    end

    local function delete_render_job(project, jobId)
        if not (project and jobId) then
            return
        end
        if project.DeleteRenderJob then
            pcall(function()
                project:DeleteRenderJob(jobId)
            end)
        end
    end

    local function delete_job_list(project, jobIds)
        if not jobIds or not project then
            return
        end
        for _, jobId in ipairs(jobIds) do
            delete_render_job(project, jobId)
        end
    end

    local function clear_pending_jobs(project)
        local pending = App.State and App.State.job_ids or {}
        delete_job_list(project, pending)
        if App.State and App.State.set_job_ids then
            App.State:set_job_ids({})
        end
    end

    local function complete_sequence()
        if Render.sequence then
            Render.sequence.active = false
            Render.sequence = nil
        end
        if Render.stop_monitor then
            Render:stop_monitor()
        end
        if App.State and App.State.set_job_ids then
            App.State:set_job_ids({})
        end
        if App.State and App.State.reset_job_tracking then
            App.State:reset_job_tracking()
        end
        App.Logger:append_localized("log_render_sequence_finished")
        ensure_ui_refresh()
    end

    local function abort_sequence(message, ...)
        finalize_rows_as("failed")
        if Render.sequence then
            Render.sequence.active = false
            Render.sequence = nil
        end
        if Render.stop_monitor then
            Render:stop_monitor()
        end
        local project = App.Core:getProject()
        if project then
            clear_pending_jobs(project)
        else
            if App.State and App.State.set_job_ids then
                App.State:set_job_ids({})
            end
        end
        if App.State and App.State.reset_job_tracking then
            App.State:reset_job_tracking()
        end
        if message and message ~= "" then
            if type(message) == "string" and message:match("^log_[%w_]+$") then
                App.Logger:append_localized(message, ...)
            else
                App.Logger:append(message)
            end
        end
        ensure_ui_refresh()
    end

    function Render:prepare_jobs()
        if not (self.sequence and self.sequence.rows and #self.sequence.rows > 0) then
            return nil
        end
        local project = App.Core:getProject()
        if not project then
            App.Logger:append_localized("log_project_missing")
            return nil
        end
        local seq = self.sequence
        local targetDir = seq.targetDir
        local okEnv, envReason = ensure_render_env(project, targetDir)
        if not okEnv then
            local reasonText = localized_text(envReason or "log_start_render_failed")
            App.Logger:append_localized("log_render_env_failed", reasonText ~= "" and reasonText or "-")
            return nil
        end
        App.State:reset_job_tracking()
        local createdJobIds = {}
        local timelineGroups = group_rows_by_timeline(seq.rows)
        for _, group in ipairs(timelineGroups) do
            local timelineIndex = group.timeline_index
            if timelineIndex then
                local ok = App.State:set_editing_timeline(timelineIndex, true)
                if not ok then
                    App.Logger:append_localized("log_active_timeline_missing")
                    delete_job_list(project, createdJobIds)
                    App.State:set_job_ids({})
                    App.State:reset_job_tracking()
                    return nil
                end
            end
            for _, row in ipairs(group.rows or {}) do
                row.jobId = nil
                row.statusExtra = nil
                local _, waitingChanged = update_row_status(row, "waiting", nil)
                if waitingChanged then
                    log_row_status(row, "waiting")
                end

                local settings = build_settings(row, targetDir)
                local okSettings = project:SetRenderSettings(settings)
                if not okSettings then
                    App.Logger:append_localized("log_render_settings_failed", row.name or row.index or "?")
                    update_row_status(row, "failed", nil)
                    log_row_status(row, "failed")
                    delete_job_list(project, createdJobIds)
                    App.State:set_job_ids({})
                    App.State:reset_job_tracking()
                    return nil
                end

                local jobId = project:AddRenderJob()
                if not jobId then
                    App.Logger:append_localized("log_add_job_failed", row.name or row.index or "?")
                    update_row_status(row, "failed", nil)
                    log_row_status(row, "failed")
                    delete_job_list(project, createdJobIds)
                    App.State:set_job_ids({})
                    App.State:reset_job_tracking()
                    return nil
                end

                row.jobId = jobId
                App.State:register_job_row(jobId, row)
                table.insert(createdJobIds, jobId)
                App.Logger:append_localized("log_job_added", row.name or jobId)
                local _, queuedChanged = update_row_status(row, "queued", nil)
                if queuedChanged then
                    log_row_status(row, "queued")
                end
            end
        end
        App.State:set_job_ids(createdJobIds)
        return createdJobIds
    end

    function Render:enqueue_rows(rows)
        local project = App.Core:getProject()
        if not project then
            App.Logger:append_localized("log_project_missing")
            return false
        end
        local targetDir = App.Helpers:trim(App.State.target_dir or "")
        if targetDir == "" then
            App.Logger:append_localized("log_target_dir_required")
            return false
        end
        if not rows or #rows == 0 then
            App.Logger:append_localized("log_no_jobs_available")
            return false
        end

        App.State:reset_job_tracking()
        App.State:set_job_ids({})
        for _, row in ipairs(rows) do
            row.jobId = nil
            row.statusExtra = nil
            local _, keyChanged = update_row_status(row, "pending", nil)
            if keyChanged then
                log_row_status(row, "pending")
            end
        end

        self.sequence = {
            rows = rows,
            targetDir = targetDir,
            currentIndex = 0,
            active = false
        }
        App.Logger:append_localized("log_jobs_prepared", #rows)
        ensure_ui_refresh()
        return true
    end

    function Render:start()
        if not (self.sequence and self.sequence.rows and #self.sequence.rows > 0) then
            App.Logger:append_localized("log_no_jobs_available")
            return false
        end
        if self.sequence.active then
            App.Logger:append_localized("log_render_in_progress")
            return false
        end
        self.sequence.active = true
        App.Logger:append_localized("log_starting_sequential", #self.sequence.rows)
        local jobIds = self:prepare_jobs()
        if not jobIds or #jobIds == 0 then
            self.sequence.active = false
            App.Logger:append_localized("log_start_render_failed")
            finalize_rows_as("failed")
            ensure_ui_refresh()
            return false
        end
        local project = App.Core:getProject()
        local ok, started = pcall(function()
            return project:StartRendering(jobIds, true)
        end)
        if not ok then
            started = false
        end
        if not started then
            App.Logger:append_localized("log_start_render_failed")
            delete_job_list(project, jobIds)
            App.State:set_job_ids({})
            App.State:reset_job_tracking()
            finalize_rows_as("failed")
            ensure_ui_refresh()
            self.sequence.active = false
            return false
        end
        self:stop_monitor()
        self:start_monitor()
        App.Logger:append_localized("log_sequential_started")
        return true
    end

    function Render:start_monitor()
        self.monitor = self.monitor or {}
        self.monitor.active = true
        if App.UI and App.UI.start_status_timer then
            App.UI:start_status_timer()
        end
        return true
    end

    function Render:stop_monitor()
        if self.monitor then
            self.monitor.active = false
            self.monitor = nil
        end
        if App.UI and App.UI.stop_status_timer then
            App.UI:stop_status_timer()
        end
    end

    function Render:poll_job_status()
        if not self.monitor or not self.monitor.active then
            if App.UI and App.UI.stop_status_timer then
                App.UI:stop_status_timer()
            end
            return
        end

        local project = App.Core:getProject()
        if not project then
            abort_sequence("log_project_missing")
            return
        end

        local jobIds = (App.State and App.State.job_ids) or {}
        if not jobIds or #jobIds == 0 then
            if not project:IsRenderingInProgress() then
                complete_sequence()
            end
            return
        end

        local remaining = {}
        for _, jobId in ipairs(jobIds) do
            local row = App.State:get_row_by_job(jobId)
            local statusInfo
            local ok, result = pcall(function()
                return project:GetRenderJobStatus(jobId)
            end)
            if ok then
                statusInfo = result
            end
            local statusKey, progressText = normalize_job_status(statusInfo)
            if row then
                local _, keyChanged = update_row_status(row, statusKey, progressText)
                if keyChanged then
                    log_row_status(row, statusKey)
                end
            end

            if statusKey == "done" then
                delete_render_job(project, jobId)
                if row then
                    row.jobId = nil
                end
            elseif statusKey == "failed" then
                delete_render_job(project, jobId)
                App.Logger:append_localized("log_job_failed_cancel_rest", row and row.name or tostring(jobId))
                abort_sequence("log_detected_failure_stop")
                return
            else
                table.insert(remaining, jobId)
            end
        end

        App.State:set_job_ids(remaining)
        ensure_ui_refresh()

        if #remaining == 0 then
            complete_sequence()
            return
        end

        if not project:IsRenderingInProgress() then
            App.Logger:append_localized("log_render_interrupted_stop")
            abort_sequence("log_render_interrupted")
        end
    end

    App.Render = Render
end

--
-- 8. UI 模块 (App.UI)
--
do
    local UI = {
        win = nil,
        items = nil,
        statusTimer = nil,
        _timeoutHooked = false,
        _previousTimeoutHandler = nil,
        tree_item_map = nil,
        statusLocaleKeys = {
            pending = "status_pending",
            queued = "status_queued",
            waiting = "status_waiting",
            rendering = "status_rendering",
            done = "status_done",
            failed = "status_failed",
            unknown = "status_unknown"
        },
        sponsorQr = nil,
        sessionCode = string.format("%04X", math.random(0, 0xFFFF)),
    }

    local function tr(key)
        return App.Locale and App.Locale:t(key) or key
    end

    function UI:run_with_loading(action)
        if type(action) ~= "function" then
            return
        end
        local dispatcher = App.Core.dispatcher
        local ui = App.Core.ui
        if not (dispatcher and ui) then
            return action()
        end
        local win = dispatcher:AddWindow({
            ID = "LoadingWindow",
            WindowTitle = string.format("%s - Loading", App.Config.SCRIPT_NAME),
            Geometry = {
                App.Config.LOADING_X_CENTER,
                App.Config.LOADING_Y_CENTER,
                App.Config.LOADING_WINDOW_WIDTH,
                App.Config.LOADING_WINDOW_HEIGHT
            },
        }, ui:VGroup{
            Weight = 1,
            Alignment = { AlignHCenter = true, AlignVCenter = true },
            ui:Label{
                ID = "LoadingLabel",
                Text = tr("loading_updates"),
                Alignment = { AlignHCenter = true, AlignVCenter = true },
                WordWrap = true,
            }
        })
        if not win then
            return action()
        end
        local items = win:GetItems()
        if items and items.LoadingLabel then
            items.LoadingLabel.Text = tr("loading_updates")
        end
        win:Show()
        local ok, result = pcall(action)
        if items and items.LoadingLabel then
            items.LoadingLabel.Text = tr("loading_complete")
        end
        win:Hide()
        if win.DeleteLater then
            win:DeleteLater()
        end
        if not ok then
            error(result)
        end
        return result
    end

    function UI:ensure_status_timer()
        local ui = App.Core.ui
        if not ui then
            return nil
        end
        if not self.statusTimer then
            local ok, timer = pcall(function()
                return ui:Timer{
                    ID = "RenderStatusTimer",
                    Interval = 1000,
                    SingleShot = false,
                    TimerType = "CoarseTimer"
                }
            end)
            if ok then
                self.statusTimer = timer
            end
        end
        if (not self._timeoutHooked) and App.Core.dispatcher then
            local dispatcher = App.Core.dispatcher
            local previousHandler = dispatcher.On.Timeout
            dispatcher.On.Timeout = function(ev)
                local handled
                if previousHandler then
                    handled = previousHandler(ev)
                end
                local who = ev and (ev.who or ev.ID or ev.Name or ev.TimerID or ev.TimerId)
                if who == "RenderStatusTimer" then
                    if App.Render and App.Render.poll_job_status then
                        App.Render:poll_job_status()
                    end
                    return true
                end
                return handled
            end
            self._timeoutHooked = true
            self._previousTimeoutHandler = previousHandler
        end
        return self.statusTimer
    end

    function UI:start_status_timer()
        local timer = self:ensure_status_timer()
        if timer and timer.Start then
            pcall(function() timer:Start() end)
        end
    end

    function UI:stop_status_timer()
        if self.statusTimer and self.statusTimer.Stop then
            pcall(function() self.statusTimer:Stop() end)
        end
    end

    function UI:get_row_status_text(row)
        local statusKey = row and row.statusKey or "pending"
        if not self.statusLocaleKeys[statusKey] then
            statusKey = "unknown"
        end
        local text = tr(self.statusLocaleKeys[statusKey])
        if row and row.statusExtra and row.statusExtra ~= "" then
            text = string.format("%s (%s)", text, row.statusExtra)
        end
        return text
    end

    function UI:ensureSponsorQrs()
        if self.sponsorQr and self.sponsorQr.paypal and self.sponsorQr.wechat then
            if App.Helpers:file_exists(self.sponsorQr.paypal) and App.Helpers:file_exists(self.sponsorQr.wechat) then
                return self.sponsorQr
            end
        end

        local paypalBase64 = App.Config.QR_PAYPAL_BASE64
        local wechatBase64 = App.Config.QR_WECHAT_BASE64
        if type(paypalBase64) ~= "string" or paypalBase64 == "" or type(wechatBase64) ~= "string" or wechatBase64 == "" then
            return nil, "sponsor_qr_base64_missing"
        end

        local tempDir = App.Helpers:get_temp_dir()
        App.Helpers:ensure_dir(tempDir)

        local session = tostring(self.sessionCode or "0000")
        local paypalPath = App.Helpers:join_path(tempDir, "sponsor_paypal_qr_" .. session .. ".png")
        local wechatPath = App.Helpers:join_path(tempDir, "sponsor_wechat_qr_" .. session .. ".png")

        if not App.Helpers:file_exists(paypalPath) then
            local ok = App.Helpers:create_image_from_base64(paypalBase64, paypalPath)
            if not ok then
                return nil, "create_paypal_qr_failed"
            end
        end
        if not App.Helpers:file_exists(wechatPath) then
            local ok = App.Helpers:create_image_from_base64(wechatBase64, wechatPath)
            if not ok then
                return nil, "create_wechat_qr_failed"
            end
        end

        self.sponsorQr = { paypal = paypalPath, wechat = wechatPath }
        return self.sponsorQr
    end

    function UI:build_batch_tab()
        local ui = App.Core.ui
        return ui.VGroup{
            ID = "BatchTab",
            Weight = 1,
            ui.HGroup{
                Weight = 0,
                ui.VGroup{
                    ui.Label{ Text = "Marks", Alignment = { AlignHCenter = true, AlignVCenter = true },},
                    ui.HGroup{
                        ui.Button{ ID = "AddMarkBtn", Text = tr("add_mark"),  },
                        ui.Button{
                            ID = "ClearMarksBtn",
                            Text = tr("clear_marks"),
                            Weight = 1,
                        },
                    },
                },
                ui.VGroup{
                    ui.Label{ ID = "IntervalLabel", Text = tr("interval_label"),Alignment = { AlignHCenter = true, AlignVCenter = true },  },
                    ui.LineEdit{ ID = "IntervalInput", Text = tostring(App.State.interval_seconds), }
                },
                ui.VGroup{
                    ui.Label{ ID = "CountLabel", Text = tr("count_label"), Alignment = { AlignHCenter = true, AlignVCenter = true },},
                    ui.SpinBox{ ID = "CountInput", Minimum = 2, Maximum = 200, Value = App.State.mark_count }
                },
                ui.VGroup{
                    ui.Label{ ID = "BaseNameLabel", Text = tr("base_name_label"), Alignment = { AlignHCenter = true, AlignVCenter = true }, },
                    ui.LineEdit{
                        ID = "BaseNameInput",
                        Text = App.State:get_base_name_for_timeline(App.State.editing_timeline_index),
                        Events = { EditingFinished = true },
                        Weight = 1,
                    }
                },
            },

            ui.HGroup{
                Weight = 0.65,
                ui.Tree{
                    ID = "RenderTree",
                    Weight = 1,
                    ColumnCount = 6,
                    AlternatingRowColors = true,
                    RootIsDecorated = true,
                    HeaderHidden = false,
                }
            },
            ui.HGroup{
                Weight = 0,
                ui.LineEdit{ ID = "TargetDirInput", ReadOnly = true, PlaceholderText = tr("target_placeholder"), Weight = 1 },
                ui.Button{ ID = "ChoosePathBtn", Text = tr("browse"), Weight = 0 },
            },
            ui.HGroup{
                Weight = 0,
                ui.Button{ ID = "GetQueueBtn", Text = tr("get_queue") },
                ui.Button{ ID = "StartRenderBtn", Text = tr("start_render"),  },
            },
            ui.VGroup{
                Weight = 0.15,
                ui.TextEdit{ ID = "LogView", ReadOnly = true, },
            },
            ui.Label{
                ID = "UpdateStatusLabel",
                Text = "",
                Weight = 0,
                WordWrap = true,
                Alignment = { AlignHCenter = true, AlignVCenter = true },
                Visible = false,
                StyleSheet = "color:#d9534f; font-weight:bold;",
            },
            ui.Button{
                ID = "DonationButton",
                Text = tr("donation_button"),
                Flat = true,
                Font = ui.Font({ PixelSize = 12, StyleName = "Bold" }),
                Alignment = { AlignHCenter = true, AlignVCenter = true },
                TextColor = { 1, 1, 1, 1 },
                BackgroundColor = { 1, 1, 1, 0 },
                Weight = 0,
            },
        }
    end

    function UI:build_settings_tab()
        local ui = App.Core.ui
        local sponsorQr = self:ensureSponsorQrs() or {}

        return ui.VGroup{
            ID = "SettingsTab",
            Weight = 1,
            Spacing = 10,

            ui.HGroup{
                Weight = 0,
                ui.Label{ ID = "LangSpacer", Text = "", Weight = 1 },
                ui.CheckBox{ ID = "LangEnCheckBox", Text = tr("lang_en_label"), Checked = (App.State.language ~= "zh"), Weight = 0 },
                ui.CheckBox{ ID = "LangCnCheckBox", Text = tr("lang_cn_label"), Checked = (App.State.language == "zh"), Weight = 0 },
                ui.Label{ ID = "LangSpacer", Text = "", Weight = 1 },
            },

            ui.Label{ ID = "SettingsSpacer", Text = "", Weight = 1 },

            ui.Label{
                ID = "SponsorLabel",
                Text = tr("sponsor_label"),
                Alignment = { AlignHCenter = true, AlignVCenter = true },
                WordWrap = true,
                Weight = 1,
            },

            ui.HGroup{
                ID = "SponsorQrGroup",
                Weight = 1,
                Alignment = { AlignHCenter = true, AlignVCenter = true },
                ui.Label{ ID = "SponsorQrLeftSpacer", Text = "", Weight = 1 },
                ui.Button{
                    ID = "SponsorPaypalQrButton",
                    Icon = ui.Icon({ File = sponsorQr.paypal or "" }),
                    IconSize = { 170, 170 },
                    MinimumSize = { 170, 170 },
                    StyleSheet = "border:0px dashed #444; border-radius:0px; background:transparent;",
                    Flat = true,
                    Weight = 0,
                },
                ui.Label{ ID = "SponsorQrCenterSpacer", Text = "", Weight = 1 },
                ui.Button{
                    ID = "SponsorWechatQrButton",
                    Icon = ui.Icon({ File = sponsorQr.wechat or "" }),
                    IconSize = { 170, 170 },
                    MinimumSize = { 170, 170 },
                    StyleSheet = "border:0px dashed #444; border-radius:0px; background:transparent;",
                    Flat = true,
                    Weight = 0,
                },
                ui.Label{ ID = "SponsorQrRightSpacer", Text = "", Weight = 1 },
            },

            ui.Button{
                ID = "DonationButtonSettings",
                Text = tr("donation_button"),
                Flat = true,
                Font = ui.Font({ PixelSize = 12, StyleName = "Bold" }),
                Alignment = { AlignHCenter = true, AlignVCenter = true },
                TextColor = { 1, 1, 1, 1 },
                BackgroundColor = { 1, 1, 1, 0 },
                Weight = 0,
            },
        }
    end

    function UI:build_window_content()
        local ui = App.Core.ui
        return ui.VGroup{
            Weight = 1,
            ui.TabBar{ ID = "MainTabs", Weight = 0 },
            ui.Stack{
                ID = "MainStack",
                Weight = 1,
                self:build_batch_tab(),
                self:build_settings_tab(),
            },
        }
    end

    function UI:create_main_window()
        if not App.Core.initialized then
            return nil
        end
        local win = App.Core.dispatcher:AddWindow({
            ID = "BatchRenderWin",
            WindowTitle = string.format("%s %s", tr("app_title"), App.Config.SCRIPT_VERSION),
            Geometry = {App.Config.X_CENTER, App.Config.Y_CENTER, App.Config.WINDOW_WIDTH, App.Config.WINDOW_HEIGHT},
            Spacing = 6,
            Margin = 8,
            StyleSheet = "*{font-size:14px;}"
        }, self:build_window_content())
        self.win = win
        if win then
            self.items = win:GetItems()
            if self.items and self.items.MainTabs and self.items.MainTabs.AddTab then
                self.items.MainTabs:AddTab(tr("tab_batch_render"))
                self.items.MainTabs:AddTab(tr("tab_settings"))
                self.items.MainTabs.CurrentIndex = 0
            end
            if self.items and self.items.MainStack then
                self.items.MainStack.CurrentIndex = 0
            end
            self:sync_inputs()
            self:update_language_texts()
        end
        return win
    end

    function UI:sync_inputs()
        if not self.items then return end
        if self.items.TargetDirInput then
            self.items.TargetDirInput.Text = App.State.target_dir or ""
        end
        if self.items.BaseNameInput then
            self.items.BaseNameInput.Text = App.State:get_base_name_for_timeline(App.State.editing_timeline_index)
        end
        if self.items.LangEnCheckBox then
            self.items.LangEnCheckBox.Checked = (App.State.language ~= "zh")
        end
        if self.items.LangCnCheckBox then
            self.items.LangCnCheckBox.Checked = (App.State.language == "zh")
        end
    end

    function UI:update_language_texts()
        if not self.items then return end
        local items = self.items

        if items.IntervalLabel then items.IntervalLabel.Text = tr("interval_label") end
        if items.CountLabel then items.CountLabel.Text = tr("count_label") end
        if items.BaseNameLabel then items.BaseNameLabel.Text = tr("base_name_label") end


        if items.AddMarkBtn then items.AddMarkBtn.Text = tr("add_mark") end
        if items.GetQueueBtn then items.GetQueueBtn.Text = tr("get_queue") end
        if items.StartRenderBtn then items.StartRenderBtn.Text = tr("start_render") end
        if items.ClearMarksBtn then items.ClearMarksBtn.Text = tr("clear_marks") end
        if items.ChoosePathBtn then items.ChoosePathBtn.Text = tr("browse") end
        if items.TargetDirInput then
            items.TargetDirInput.PlaceholderText = tr("target_placeholder")
        end

        if items.LangEnCheckBox then
            items.LangEnCheckBox.Text = tr("lang_en_label")
            items.LangEnCheckBox.Checked = (App.State.language ~= "zh")
        end
        if items.LangCnCheckBox then
            items.LangCnCheckBox.Text = tr("lang_cn_label")
            items.LangCnCheckBox.Checked = (App.State.language == "zh")
        end
        if items.DonationButton then
            items.DonationButton.Text = tr("donation_button")
        end
        if items.DonationButtonSettings then
            items.DonationButtonSettings.Text = tr("donation_button")
        end
        if items.SponsorLabel then
            items.SponsorLabel.Text = tr("sponsor_label")
        end
        if items.MainTabs and items.MainTabs.SetTabText then
            items.MainTabs:SetTabText(0, tr("tab_batch_render"))
            items.MainTabs:SetTabText(1, tr("tab_settings"))
        end

        if items.RenderTree and items.RenderTree.SetHeaderLabels then
            items.RenderTree:SetHeaderLabels({
                tr("tree_header_timeline"),
                tr("tree_header_index"),
                tr("tree_header_start"),
                tr("tree_header_end"),
                tr("tree_header_name"),
                tr("tree_header_status")
            })
        end

        if items.RenderTree and items.RenderTree.SetColumnWidth then
            items.RenderTree:SetColumnWidth(0, 120)  -- 时间线
            items.RenderTree:SetColumnWidth(1, 50)   -- 序号
            items.RenderTree:SetColumnWidth(2, 90)   -- 开始时间
            items.RenderTree:SetColumnWidth(3, 90)   -- 结束时间
            items.RenderTree:SetColumnWidth(4, 200)  -- 名称
            items.RenderTree:SetColumnWidth(5, 90)   -- 状态
        end
        if self.win then
            local title = string.format("%s %s", tr("app_title"), App.Config.SCRIPT_VERSION)
            if self.win.SetWindowTitle then
                self.win:SetWindowTitle(title)
            else
                self.win.WindowTitle = title
            end
        end
        self:refresh_tree()
        self:update_update_status_label()
    end

    function UI:update_update_status_label()
        if not self.items or not self.items.UpdateStatusLabel then
            return
        end
        local label = self.items.UpdateStatusLabel
        local info = App.State.update_info
        if type(info) ~= "table" then
            label.Text = ""
            label.Visible = false
            return
        end
        local langKey = (App.State.language == "zh") and "zh" or "en"
        local text = info[langKey] or info.en or info.zh or ""
        text = App.Helpers and App.Helpers:trim(text) or (text or "")
        if text == "" then
            label.Text = ""
            label.Visible = false
            return
        end
        label.Text = text
        label.Visible = true
    end

    function UI:refresh_tree()
        if not self.items or not self.items.RenderTree then return end
        local tree = self.items.RenderTree
        if tree.Clear then tree:Clear() end
        self.tree_item_map = {}
        local function map_item(item, data)
            if item then
                self.tree_item_map[tostring(item)] = data
            end
        end
        local function new_item()
            return tree.NewItem and tree:NewItem() or (App.Core.ui.TreeItem and App.Core.ui.TreeItem({})) or nil
        end
        local timelines = App.State.all_timelines or {}
        if #timelines == 0 then
            local item = new_item()
            if item then
                item.Text[0] = tr("no_timelines_found")
                item.Disabled = true
                if tree.AddTopLevelItem then
                    tree:AddTopLevelItem(item)
                end
            end
            return
        end
        local rowsByTimeline = {}
        for _, row in ipairs(App.State:get_tree_rows()) do
            local idx = tonumber(row.timeline_index) or 0
            rowsByTimeline[idx] = rowsByTimeline[idx] or {}
            table.insert(rowsByTimeline[idx], row)
        end
        local used = {}
        for _, entry in ipairs(timelines) do
            local idx = entry.index
            local name = entry.name or ("Timeline " .. tostring(idx))
            local isActive = (App.State.editing_timeline_index == idx)
            local parent = new_item()
            if parent then
                parent.Text[0] = name
                parent.Text[5] = isActive and "" or tr("timeline_disabled")
                if tree.AddTopLevelItem then
                    tree:AddTopLevelItem(parent)
                end
                if isActive then
                    parent.Selected = true
                end
                parent.Expanded = true
                map_item(parent, { type = "timeline", timeline_index = idx })
                local rows = rowsByTimeline[idx] or {}
                for _, row in ipairs(rows) do
                    local child = new_item()
                    if child then
                        child.Text[0] = ""
                        child.Text[1] = tostring(row.index or "")
                        child.Text[2] = row.startTimecode or ""
                        child.Text[3] = row.endTimecode or ""
                        child.Text[4] = row.name or ""
                        child.Text[5] = self:get_row_status_text(row)
                        if parent.AddChild then
                            parent:AddChild(child)
                        end
                        map_item(child, { type = "segment", row = row })
                    end
                end
            end
            used[idx] = true
        end
        for idx, rows in pairs(rowsByTimeline) do
            if not used[idx] then
                local name = "Timeline " .. tostring(idx)
                local parent = new_item()
                if parent then
                    parent.Text[0] = name
                    parent.Text[5] = tr("timeline_disabled")
                    if tree.AddTopLevelItem then
                        tree:AddTopLevelItem(parent)
                    end
                    parent.Expanded = true
                    map_item(parent, { type = "timeline", timeline_index = idx })
                    for _, row in ipairs(rows) do
                        local child = new_item()
                        if child then
                            child.Text[0] = ""
                            child.Text[1] = tostring(row.index or "")
                            child.Text[2] = row.startTimecode or ""
                            child.Text[3] = row.endTimecode or ""
                            child.Text[4] = row.name or ""
                            child.Text[5] = self:get_row_status_text(row)
                            if parent.AddChild then
                                parent:AddChild(child)
                            end
                            map_item(child, { type = "segment", row = row })
                        end
                    end
                end
            end
        end
    end

    function UI:jump_to_row(row)
        if not row then
            return
        end
        App.Timeline:jump_to_row(row)
    end

    function UI:activate_timeline(index, silent)
        if not index then
            return
        end
        local ok = App.State:set_editing_timeline(index, silent)
        if not ok then
            if App.Logger and App.Logger.append_localized then
                App.Logger:append_localized("timeline_disabled")
            end
            return
        end
        self:sync_inputs()
        self:refresh_tree()
    end

    function UI:bind_events()
        if not self.win or not self.items then return end
        local win = self.win
        local items = self.items

        if win.On.MainTabs and items.MainTabs and items.MainStack then
            local function syncTabToStack()
                items.MainStack.CurrentIndex = items.MainTabs.CurrentIndex
            end
            win.On.MainTabs.CurrentChanged = syncTabToStack
            win.On.MainTabs.CurrentIndexChanged = syncTabToStack
        end

        win.On.BatchRenderWin.Close = function()
            App.Timeline:cleanup_script_markers()
            App.Timeline:clear_mark_range()
            if App.Render and App.Render.stop_monitor then
                App.Render:stop_monitor()
            end
            UI:stop_status_timer()
            if App.Settings and App.Settings.save then
                App.Settings:save()
            end
            if App.Helpers and App.Helpers.remove_dir and App.Config and App.Config.TEMP_DIR then
                App.Helpers:remove_dir(App.Config.TEMP_DIR)
            end
            App.Logger:append_localized("log_window_closed")
            App.Core.dispatcher:ExitLoop()
        end

        win.On.AddMarkBtn.Clicked = function()
            local interval = tonumber(items.IntervalInput.Text)
            local count = items.CountInput.Value
            App.State.interval_seconds = interval or App.Config.DEFAULT_INTERVAL_SECONDS
            App.State.mark_count = count or App.Config.DEFAULT_MARK_COUNT
            App.Timeline:add_markers(App.State.interval_seconds, App.State.mark_count)
        end

        if win.On.ClearMarksBtn then
            win.On.ClearMarksBtn.Clicked = function()
                App.Timeline:cleanup_script_markers()
            end
        end

        win.On.CountInput.ValueChanged = function()
            App.State.mark_count = items.CountInput.Value
        end

        if win.On.IntervalInput then
            win.On.IntervalInput.EditingFinished = function()
                App.State.interval_seconds = tonumber(items.IntervalInput.Text) or App.Config.DEFAULT_INTERVAL_SECONDS
            end
        end

        win.On.ChoosePathBtn.Clicked = function()
            local fusion = App.Core.fusion
            if not (fusion and fusion.RequestDir) then
                App.Logger:append_localized("log_dir_picker_unavailable")
                return
            end
            local startDir = App.State.target_dir
            if (not startDir or startDir == "") and fusion.MapPath then
                startDir = fusion:MapPath("UserData:/")
            end
            local selected = fusion:RequestDir((startDir ~= "" and startDir or nil))
            if selected and selected ~= "" then
                App.State:set_target_dir(selected)
                UI:sync_inputs()
                App.Logger:append_localized("log_dir_selected", selected)
            end
        end

        if win.On.BaseNameInput then
            win.On.BaseNameInput.EditingFinished = function()
                App.State:set_base_name(items.BaseNameInput.Text or "")
                UI:sync_inputs()
                UI:refresh_tree()
            end
        end



        win.On.GetQueueBtn.Clicked = function()
            local timelineIndex = App.State.editing_timeline_index
            if not timelineIndex then
                App.Logger:append_localized("no_timelines_found")
                return
            end
            local segments = App.Timeline:build_segments_for_timeline(timelineIndex)
            if segments then
                App.State:set_tree_rows(segments, timelineIndex)
                UI:refresh_tree()
            end
        end

        win.On.StartRenderBtn.Clicked = function()
            local rows = App.State:get_tree_rows()
            if not rows or #rows == 0 then
                App.Logger:append_localized("log_queue_required")
                return
            end
            local ready = App.Render:enqueue_rows(rows)
            UI:refresh_tree()
            if ready then
                App.Render:start()
            end
        end

        if win.On.RenderTree then
            win.On.RenderTree.ItemClicked = function()
                local tree = items.RenderTree
                local current = tree and tree:CurrentItem()
                if not current then
                    return
                end
                local data = UI.tree_item_map and UI.tree_item_map[tostring(current)]
                if not data then
                    return
                end
                if data.type == "timeline" then
                    UI:activate_timeline(data.timeline_index)
                elseif data.type == "segment" then
                    UI:jump_to_row(data.row)
                end
            end
        end

        local function apply_language(lang)
            if lang ~= "zh" then
                lang = "en"
            end
            if App.State.language ~= lang then
                App.State.language = lang
                App.Locale:set_language(lang)
                UI:sync_inputs()
                UI:update_language_texts()
                if App.Logger and App.Logger.refresh_language then
                    App.Logger:refresh_language()
                end
                if App.Settings and App.Settings.save then
                    App.Settings:save()
                end
            else
                UI:sync_inputs()
            end
        end

        if win.On.LangEnCheckBox then
            win.On.LangEnCheckBox.Clicked = function()
                if items.LangEnCheckBox then
                    items.LangEnCheckBox.Checked = true
                end
                if items.LangCnCheckBox then
                    items.LangCnCheckBox.Checked = false
                end
                apply_language("en")
            end
        end

        if win.On.LangCnCheckBox then
            win.On.LangCnCheckBox.Clicked = function()
                if items.LangCnCheckBox then
                    items.LangCnCheckBox.Checked = true
                end
                if items.LangEnCheckBox then
                    items.LangEnCheckBox.Checked = false
                end
                apply_language("zh")
            end
        end

        if win.On.DonationButton then
            win.On.DonationButton.Clicked = function()
                if App.State.language == "zh" then
                    if App.Helpers and App.Helpers.openExternalUrl then
                        App.Helpers:openExternalUrl(SCRIPT_TAOBAO_URL)
                    end
                    return
                end
                App.Helpers:openExternalUrl(SCRIPT_KOFI_URL)
            end
        end
        if win.On.DonationButtonSettings then
            win.On.DonationButtonSettings.Clicked = win.On.DonationButton and win.On.DonationButton.Clicked or function()
                if App.State.language == "zh" then
                    if App.Helpers and App.Helpers.openExternalUrl then
                        App.Helpers:openExternalUrl(SCRIPT_TAOBAO_URL)
                    end
                    return
                end
                App.Helpers:openExternalUrl(SCRIPT_KOFI_URL)
            end
        end

    end

    App.UI = UI
end

--
-- 9. 主流程
--
local function main()

    if App.Update then
        App.UI:run_with_loading(function()
            App.Update:check_for_updates()
        end)
    end

    if not App.Core.initialized then
        print("DaVinci Batch Render 初始化失败")
        return
    end

    local win = App.UI:create_main_window()
    if not win then
        print("无法创建主窗口")
        return
    end

    if App.State and App.State.load_all_timelines then
        App.State:load_all_timelines()
        if App.State.editing_timeline_index then
            App.State:set_editing_timeline(App.State.editing_timeline_index, true)
        end
        if App.UI and App.UI.sync_inputs then
            App.UI:sync_inputs()
        end
    end

    App.UI:refresh_tree()
    App.UI:bind_events()

    win:Show()
    App.Core.dispatcher:RunLoop()
end

main()
